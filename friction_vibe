# Copyright Todd Hutchinson, Beau Ayres, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson and Beau Ayres.

import numpy as np; def friction_vibe(pos1, pos2, kappa=0.3): dist = np.linalg.norm(pos1 - pos2); if dist < 0.1: vibe = np.sin(2 * np.pi * dist / 0.05); gyro = np.cross(pos1, pos2) / dist; warp = 1 / (1 + kappa * dist); return vibe * warp, gyro else: return 0, np.zeros(3) # call: pos1 = np.array([0,0,0]); pos2 = np.array([0.05,0,0]); wave, spin = friction_vibe(pos1, pos2) Iterate: Fake close pos-get wave ~0. something oscillating, spin cross non-zero no force, far? Zero flat, adjust kappa 0.4 for softer near.
import numpy as np; def gyro_gimbal(pos1, pos2, tilt=np.array([0.1,0.1,0.1]), kappa=0.3): dist = np.linalg.norm(pos1 - pos2); if dist < 0.1: vibe, base_gyro = friction_vibe(pos1, pos2, kappa); gimbal_spin = base_gyro + tilt / dist; warp = 1 / (1 + kappa * dist); return vibe * warp, gimbal_spin else: return 0, np.zeros(3); # call: pos1 = np.array([0,0,0]); pos2 = np.array([0.05,0,0]); wave, spin = gyro_gimbal(pos1, pos2) Iterate: Fake close pos-get wave ~0 osc, spin adds tilt boost non-zero no jam, far? Flat zero, adjust tilt [0.2,0.2,0.2] for stronger map if force feels light.
