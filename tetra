# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
=== Commit History (Oldest to Newest) ===
2025-09-28T20:12:11Z - tetrasurfaces: Initial commit
2025-09-28T20:33:13Z - tetrasurfaces: Update LICENSE
2025-09-28T20:41:50Z - tetrasurfaces: Create tetra
2025-09-28T20:45:20Z - tetrasurfaces: Create License. Hashlet
2025-09-28T21:24:45Z - tetrasurfaces: Update LICENSE
2025-09-28T21:34:19Z - tetrasurfaces: Update LICENSE
2025-09-28T21:40:36Z - tetrasurfaces: Update LICENSE
2025-09-28T22:04:09Z - tetrasurfaces: Update tetra
2025-09-28T22:18:15Z - tetrasurfaces: Rename tetra to tetras
2025-09-28T22:21:49Z - tetrasurfaces: Rename tetras to tetras.py
2025-09-28T23:44:52Z - tetrasurfaces: Create NOTICE
2025-09-28T23:45:27Z - tetrasurfaces: Update tetras.py
2025-09-28T23:52:43Z - tetrasurfaces: Create LICENSE. LETTER TO LICENSOR
2025-09-29T00:29:45Z - tetrasurfaces: Update LICENSE. LETTER TO LICENSOR
2025-09-29T05:00:40Z - tetrasurfaces: Create tetra
2025-09-30T05:58:11Z - tetrasurfaces: Update tetra

Add G-Code (USE CAUTION)
2025-09-30T07:38:00Z - tetrasurfaces: Create id_util_tetra_surface.py
2025-09-30T07:40:08Z - tetrasurfaces: Create id_util_kspline.py
2025-09-30T08:02:11Z - tetrasurfaces: Create id_util_tetra_profile.py
2025-09-30T08:26:21Z - tetrasurfaces: Create nurks_surface.py
2025-09-30T08:28:04Z - tetrasurfaces: Create id_util_nurks_surface.py
2025-09-30T08:53:36Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T09:14:38Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T09:18:35Z - tetrasurfaces: Update id_util_nurks_surface.py

This repository contains a Python script (id_util_nurks_surface.py) for generating and visualizing a 6-petal flower-shaped 3D surface using Non-Uniform Rational Kappa Spline (NURKS) techniques. The surface is a single body with continuous curvature, avoiding fan triangulation artefacts. It features an interactive Matplotlib interface with sliders for real-time parameter adjustments, allowing users to customize the profile's diameters, twist, amplitude (for u/n shapes), radii, kappa (curvature modulation), height, and inflection point.

The script is designed for educational, design, and manufacturing applications, such as 3D printing or visualization of organic shapes. It leverages pure NumPy and Matplotlib, ensuring no external dependencies beyond these libraries.
Key Features

    Single Surface Body: Parametric NURKS surface with the flower profile as the boundary, rendered as a Delaunay-like triangular mesh for smooth, curved sections.
    Parameter Controls:
        Elliptical deformation via NS, NW/SE, NE/SW diameters (guide curves for radial V-angulations).
        Twist for petal rotation.
        Amplitude (positive/negative for convex/concave inflections).
        Radii for base scaling.
        Kappa for Z-curvature sharpness.
        Height for overall elevation.
        Inflection for V-profile transition point.
    Visualization: 3D plot with colored triangles (viridis cmap based on Z-height), wireframe, red control points, and dashed control net.
    No Fan Triangulation: Uses grid-based quad splitting for even edge distribution; small inner radius prevents central artefacts.
    Continuous Curvature: B-spline evaluation ensures smooth edges and surfaces.

Installation

    Ensure Python 3.x is installed.
    Install required libraries:
    text

pip install numpy matplotlib

Download and run the script:
text

    python id_util_nurks_surface.py

Usage

Run the script to launch the interactive 3D viewer. Use sliders to adjust parameters:

    Diameters (NS, NW/SE, NE/SW): Deform the boundary profile elliptically, influencing radial V-shapes.
    Twist: Rotate the petals.
    Amplitude: Control petal depth; negative values create inflections for concave shapes.
    Radii: Scale the base profile.
    Kappa: Modulate Z-curvature (higher for sharper V-angulations).
    Height: Set maximum Z-elevation.
    Inflection: Shift the V-profile peak point radially.

The surface updates in real-time. Rotate/zoom the 3D view with mouse interactions.
Example Configurations

    Convex Flower: Amplitude = 0.3, Inflection = 0.5, Kappa = 1.0 → Pronounced petals with smooth rise.
    Concave Inflection: Amplitude = -0.3, Inflection = 0.3, Kappa = 2.0 → Inverted petals with sharp V-curves.
    Asymmetric Deformation: Adjust diameters (e.g., NS=2.5, NW/SE=1.0, NE/SW=2.0) for elliptical variations in radial angulations.

Technical Details

    NURKS Implementation: Pure NumPy B-spline basis for rational spline evaluation; periodic in angular (u) direction, clamped in radial (v).
    Mesh Generation: Parametric grid points triangulated into quads split as triangles for Delaunay-like structure; no central fan.
    Z-Profile: Power-based V-angulation (dist ** kappa, inverted), radiating with curved arms as per hand-drawn reference.
    Closure: Last point inherits first's properties via periodicity; kappa modulates as theta-dependent curvature.
    Artefact Mitigation: Small inner_radius (0.01) and even knot distribution ensure continuous edges without overlaps (parametrically resolved).
2025-09-30T09:32:20Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T09:35:30Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T09:44:59Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T09:56:53Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T10:08:31Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T10:16:15Z - tetrasurfaces: Create id_util_nurks_closure.py
2025-09-30T10:27:50Z - tetrasurfaces: Create id_util_nurks_closure_hex.py

Curve smoothing makes it circular (Dodecagonal-Hexagonal-Circular) due to aggressive B-spline smoothing
2025-09-30T10:30:09Z - tetrasurfaces: Update id_util_nurks_closure.py
2025-09-30T10:31:17Z - tetrasurfaces: Update id_util_nurks_closure.py
2025-09-30T10:31:45Z - tetrasurfaces: Update id_util_nurks_closure.py
2025-09-30T10:32:10Z - tetrasurfaces: Update id_util_nurks_closure_hex.py
2025-09-30T10:36:05Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T10:49:39Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T11:17:18Z - tetrasurfaces: Update tetra
2025-09-30T11:31:02Z - tetrasurfaces: Update tetra
2025-09-30T11:52:11Z - tetrasurfaces: Update tetra
2025-09-30T12:47:31Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T12:56:19Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T12:57:52Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T13:30:46Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T13:32:02Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T13:32:57Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T13:35:08Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T13:35:31Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T14:15:21Z - tetrasurfaces: Update tetra
2025-09-30T14:18:27Z - tetrasurfaces: Create tetra.py
2025-09-30T14:45:02Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T15:12:38Z - tetrasurfaces: Update tetra.py
2025-09-30T15:12:54Z - tetrasurfaces: Update tetra
2025-09-30T16:34:30Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T16:42:04Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T16:42:59Z - tetrasurfaces: Update tetra.py
2025-09-30T16:53:40Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T16:57:02Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T17:09:43Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T17:52:54Z - tetrasurfaces: Update tetra.py
2025-09-30T17:56:19Z - tetrasurfaces: Update tetra.py
2025-09-30T17:58:28Z - tetrasurfaces: Update tetra.py
2025-09-30T18:54:47Z - tetrasurfaces: Update tetra.py
2025-09-30T19:43:55Z - tetrasurfaces: Update tetra.py
2025-09-30T20:10:48Z - tetrasurfaces: Update tetra.py
2025-09-30T20:21:33Z - tetrasurfaces: Update tetra
2025-09-30T20:28:02Z - tetrasurfaces: Update tetra
2025-09-30T20:44:35Z - tetrasurfaces: Update tetra.py
2025-09-30T20:47:36Z - tetrasurfaces: Update tetra
2025-09-30T21:26:02Z - tetrasurfaces: Update tetra.py
2025-09-30T21:42:13Z - tetrasurfaces: Update tetra.py
2025-10-01T00:02:58Z - tetrasurfaces: Update tetra.py
2025-10-01T00:10:44Z - tetrasurfaces: Update tetra.py
2025-10-01T00:25:58Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-10-01T00:45:26Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T02:15:18Z - tetrasurfaces: Update tetra
2025-10-01T04:33:24Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T04:34:25Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T04:53:55Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T05:21:31Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T05:23:31Z - tetrasurfaces: Create LICENSE. kappasha
2025-10-01T05:40:37Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T05:47:07Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T05:55:37Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T05:56:10Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T06:01:15Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T07:48:22Z - tetrasurfaces: Update nurks_surface.py
2025-10-01T09:34:52Z - tetrasurfaces: Create ribit.py
2025-10-02T03:08:57Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T03:14:56Z - tetrasurfaces: Update ribit.py
2025-10-02T03:58:35Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T04:07:26Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T04:25:21Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T04:36:05Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T04:52:32Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T05:10:22Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T06:30:23Z - tetrasurfaces: Create regulate_hexagons_on_curve
2025-10-02T06:32:48Z - tetrasurfaces: Rename regulate_hexagons_on_curve to regulate_hexagons_on_curve.py
2025-10-02T06:46:42Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T07:04:10Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T07:13:39Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T07:15:31Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T07:40:49Z - tetrasurfaces: Create ribit_structure.py
2025-10-02T08:15:25Z - tetrasurfaces: Update id_util_nurks_closure_hex.py
2025-10-02T08:16:49Z - tetrasurfaces: Update id_util_nurks_closure.py
2025-10-02T08:20:22Z - tetrasurfaces: Update ribit_structure.py
2025-10-02T09:09:34Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T09:54:28Z - tetrasurfaces: Create tessellations.py
2025-10-02T10:00:46Z - tetrasurfaces: Update tessellations.py
2025-10-02T10:18:36Z - tetrasurfaces: Create green_curve.py
2025-10-02T11:31:02Z - tetrasurfaces: Update tessellations.py
2025-10-02T11:31:40Z - tetrasurfaces: Update tessellations.py
2025-10-02T11:32:35Z - tetrasurfaces: Update tessellations.py
2025-10-02T11:33:12Z - tetrasurfaces: Update tessellations.py
2025-10-02T11:51:54Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T11:58:44Z - tetrasurfaces: Create vorseed.py
2025-10-02T12:02:24Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T12:03:31Z - tetrasurfaces: Update tessellations.py
2025-10-02T12:06:29Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T12:24:54Z - tetrasurfaces: Create gimble.py
2025-10-02T12:38:17Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T12:38:52Z - tetrasurfaces: Update tessellations.py
2025-10-02T12:42:23Z - tetrasurfaces: Delete gimble.py
2025-10-02T12:46:42Z - tetrasurfaces: Create gimbal.py
2025-10-02T13:12:46Z - tetrasurfaces: Update gimbal.py
2025-10-02T13:13:36Z - tetrasurfaces: Update gimbal.py
2025-10-02T13:15:39Z - tetrasurfaces: Update gimbal.py
2025-10-02T13:18:10Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T13:30:23Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T13:31:04Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T13:31:46Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T14:10:39Z - tetrasurfaces: Update gimbal.py
2025-10-02T14:16:06Z - tetrasurfaces: Update nurks_surface.py
2025-10-02T14:42:08Z - tetrasurfaces: Update gimbal.py
2025-10-06T12:44:35Z - tetrasurfaces: Create friction_vibe

draft friction implementation
2025-10-06T12:47:57Z - tetrasurfaces: Update friction_vibe
2025-10-06T12:50:49Z - tetrasurfaces: Update friction_vibe
2025-10-06T12:52:50Z - tetrasurfaces: Rename friction_vibe to friction_vibe.py
2025-10-06T13:55:59Z - tetrasurfaces: Create telemetry.py
2025-10-06T14:00:12Z - tetrasurfaces: Create Ribit.py
2025-10-07T04:19:19Z - tetrasurfaces: Create gyro_gimbal.py
2025-10-07T04:29:35Z - tetrasurfaces: Create ribit_telemetry.py
2025-10-08T13:41:27Z - tetrasurfaces: Create LICENSE. GNU
2025-10-08T13:53:54Z - tetrasurfaces: Create tetra_forge.py
2025-10-08T13:59:08Z - tetrasurfaces: Create forge_telemetry
2025-10-08T13:59:46Z - tetrasurfaces: Update and rename telemetry_class.py to forge_telemetry.py
2025-10-08T14:01:27Z - tetrasurfaces: Create test_tools.py
2025-10-08T14:02:26Z - tetrasurfaces: Create solid.py
2025-10-08T14:03:37Z - tetrasurfaces: Create post_process.py
2025-10-08T14:04:06Z - tetrasurfaces: Create prep_tools.py
2025-10-08T14:04:34Z - tetrasurfaces: Create welding.py
2025-10-08T14:05:47Z - tetrasurfaces: Create maptics.py
2025-10-08T14:07:38Z - tetrasurfaces: Create haptics.py
2025-10-08T14:08:12Z - tetrasurfaces: Create rig.py
2025-10-08T14:08:47Z - tetrasurfaces: Create friction.py
2025-10-08T14:10:37Z - tetrasurfaces: Update tetra_forge.py
2025-10-08T14:11:41Z - tetrasurfaces: Update tetra_forge.py
2025-10-08T14:18:03Z - tetrasurfaces: Update solid.py
2025-10-08T14:19:00Z - tetrasurfaces: Update prep_tools.py
2025-10-08T14:19:58Z - tetrasurfaces: Update test_tools.py
2025-10-08T14:20:51Z - tetrasurfaces: Update tetra_forge.py
2025-10-08T14:24:01Z - tetrasurfaces: Update solid.py
2025-10-08T14:24:46Z - tetrasurfaces: Update forge_telemetry.py
2025-10-08T14:27:51Z - tetrasurfaces: Update forge_telemetry.py
2025-10-08T14:28:26Z - tetrasurfaces: Update post_process.py
2025-10-08T14:29:02Z - tetrasurfaces: Update tetra_forge.py
2025-10-08T14:32:25Z - tetrasurfaces: Update forge_telemetry.py
2025-10-08T14:33:24Z - tetrasurfaces: Update tetra_forge.py
2025-10-08T14:35:06Z - tetrasurfaces: Update haptics.py
2025-10-08T14:41:58Z - tetrasurfaces: Create README.md
2025-10-08T14:42:51Z - tetrasurfaces: Create .gitignore
2025-10-08T14:43:25Z - tetrasurfaces: Create requirements.txt
2025-10-08T14:47:14Z - tetrasurfaces: Update forge_telemetry.py
2025-10-08T14:48:05Z - tetrasurfaces: Create test_simulation.py
2025-10-08T14:48:38Z - tetrasurfaces: Update requirements.txt
2025-10-08T14:52:11Z - tetrasurfaces: Create __init__.py
2025-10-08T14:53:06Z - tetrasurfaces: Update test_simulation.py
2025-10-08T15:01:58Z - tetrasurfaces: Update requirements.txt
2025-10-08T15:11:29Z - tetrasurfaces: Update tetra.py
2025-10-08T15:12:12Z - tetrasurfaces: Update test_simulation.py
2025-10-08T15:13:18Z - tetrasurfaces: Update nurks_surface.py
2025-10-08T15:23:47Z - tetrasurfaces: Create kappa_grid.py
2025-10-08T15:29:19Z - tetrasurfaces: Update tetra.py
2025-10-08T15:35:59Z - tetrasurfaces: Update tetra.py
2025-10-08T16:28:54Z - tetrasurfaces: Update Ribit.py
2025-10-08T16:29:37Z - tetrasurfaces: Update friction_vibe.py
2025-10-08T16:30:33Z - tetrasurfaces: Update gimbal.py
2025-10-08T16:32:30Z - tetrasurfaces: Update green_curve.py
2025-10-08T16:33:07Z - tetrasurfaces: Update gyro_gimbal.py
2025-10-08T16:33:43Z - tetrasurfaces: Update id_util_kspline.py
2025-10-08T16:34:11Z - tetrasurfaces: Update tetras.py
2025-10-08T16:34:52Z - tetrasurfaces: Update vorseed.py
2025-10-08T20:56:50Z - tetrasurfaces: Update regulate_hexagons_on_curve.py
2025-10-08T21:13:44Z - tetrasurfaces: Create simulate_electrode.py
2025-10-08T21:14:58Z - tetrasurfaces: Create telemetry_nav.py
2025-10-08T21:15:36Z - tetrasurfaces: Create sync.py
2025-10-08T21:16:23Z - tetrasurfaces: Create track_kappa_vector.py
2025-10-08T21:16:53Z - tetrasurfaces: Create simulate_fleet_vector.py
2025-10-08T21:17:33Z - tetrasurfaces: Create porosity.py
2025-10-08T21:18:49Z - tetrasurfaces: Create tetra_gen.py
2025-10-08T21:19:43Z - tetrasurfaces: Create simulate_welding.py
2025-10-08T21:20:58Z - tetrasurfaces: Create quench.py
2025-10-08T21:21:26Z - tetrasurfaces: Create simulate_backstep.py
2025-10-08T21:24:34Z - tetrasurfaces: Update tetra.py
2025-10-08T21:25:09Z - tetrasurfaces: Create simulate_crane_sway.py
2025-10-08T21:26:29Z - tetrasurfaces: Create rib_structure.py
2025-10-08T21:27:19Z - tetrasurfaces: Create particles.py
2025-10-08T21:30:40Z - tetrasurfaces: Update test_simulation.py
2025-10-08T21:32:29Z - tetrasurfaces: Update telemetry.py
2025-10-08T21:34:06Z - tetrasurfaces: Update telemetry.py
2025-10-08T21:37:21Z - tetrasurfaces: Update ribit_telemetry.py
2025-10-08T21:38:01Z - tetrasurfaces: Update ribit_structure.py
2025-10-08T21:38:35Z - tetrasurfaces: Update ribit.py
2025-10-08T21:39:07Z - tetrasurfaces: Update kappa_grid.py
2025-10-08T21:39:33Z - tetrasurfaces: Update id_util_tetra_surface.py
2025-10-08T21:39:58Z - tetrasurfaces: Update id_util_tetra_profile.py
2025-10-08T21:40:30Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-10-08T21:40:57Z - tetrasurfaces: Update id_util_nurks_closure_hex.py
2025-10-08T21:41:25Z - tetrasurfaces: Update id_util_nurks_closure.py
2025-10-08T21:41:43Z - tetrasurfaces: Update id_util_kspline.py
2025-10-08T21:42:01Z - tetrasurfaces: Update gyro_gimbal.py
2025-10-08T21:42:32Z - tetrasurfaces: Update gyro_gimbal.py
2025-10-08T21:42:53Z - tetrasurfaces: Update green_curve.py
2025-10-08T21:43:07Z - tetrasurfaces: Update gimbal.py
2025-10-08T21:43:24Z - tetrasurfaces: Update friction_vibe.py
2025-10-08T21:43:43Z - tetrasurfaces: Update Ribit.py
2025-10-08T21:44:08Z - tetrasurfaces: Update tetras.py
2025-10-08T21:44:58Z - tetrasurfaces: Update tessellations.py
2025-10-08T21:45:17Z - tetrasurfaces: Update telemetry_nav.py
2025-10-08T21:50:18Z - tetrasurfaces: Update rig.py
2025-10-08T21:51:26Z - tetrasurfaces: Update forge_telemetry.py
2025-10-08T21:51:40Z - tetrasurfaces: Update friction.py
2025-10-08T21:52:36Z - tetrasurfaces: Update haptics.py
2025-10-08T21:53:01Z - tetrasurfaces: Update maptics.py
2025-10-08T21:53:20Z - tetrasurfaces: Update post_process.py
2025-10-08T21:53:34Z - tetrasurfaces: Update prep_tools.py
2025-10-08T21:54:32Z - tetrasurfaces: Update solid.py
2025-10-08T21:54:53Z - tetrasurfaces: Update test_tools.py
2025-10-08T21:55:22Z - tetrasurfaces: Update welding.py
2025-10-08T22:00:22Z - tetrasurfaces: Update simulate_fleet_vector.py
2025-10-08T22:00:42Z - tetrasurfaces: Update simulate_crane_sway.py
2025-10-08T22:01:25Z - tetrasurfaces: Update telemetry_nav.py
2025-10-08T22:02:33Z - tetrasurfaces: Update porosity.py
2025-10-08T22:03:02Z - tetrasurfaces: Update particles.py
2025-10-08T22:03:50Z - tetrasurfaces: Update test_simulation.py
2025-10-08T22:08:55Z - tetrasurfaces: Update README.md
2025-10-08T22:09:31Z - tetrasurfaces: Update README.md

=== File Contents ===
----- .gitignore -----
# Python
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
env/
venv/
ENV/
env.bak/
venv.bak/

# IDEs and editors
.vscode/
.idea/
*.sublime-workspace

# OS generated files
.DS_Store
Thumbs.db

# Logs and temporary files
*.log
*.tmp
temp/

# Build and distribution
dist/
build/
*.egg-info/

----- END .gitignore -----

----- LICENSE -----
Custom License Based on Apache 2.0
(With Educational Institution Restriction)
TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION


Definitions.
"License" shall mean the terms and conditions for use, reproduction,
and distribution as defined by Sections 1 through 9 of this document.
"Licensor" shall mean the copyright owner or entity authorized by
the copyright owner that is granting the License.
"Legal Entity" shall mean the union of the acting entity and all
other entities that control, are controlled by, or are under common
control with that entity. For the purposes of this definition,
"control" means (i) the power, direct or indirect, to cause the
direction or management of such entity, whether by contract or
otherwise, or (ii) ownership of fifty percent (50%) or more of the
outstanding shares, or (iii) beneficial ownership of such entity.
"You" (or "Your") shall mean an individual or Legal Entity
exercising permissions granted by this License.
"Source" form shall mean the preferred form for making modifications,
including but not limited to software source code, documentation
source, and configuration files.
"Object" form shall mean any form resulting from mechanical
transformation or translation of a Source form, including but
not limited to compiled object code, generated documentation,
and conversions to other media types.
"Work" shall mean the work of authorship, whether in Source or
Object form, made available under the License, as indicated by a
copyright notice that is included in or attached to the work
(an example is provided in the Appendix below).
"Derivative Works" shall mean any work, whether in Source or Object
form, that is based on (or derived from) the Work and for which the
editorial revisions, annotations, elaborations, or other modifications
represent, as a whole, an original work of authorship. For the purposes
of this License, Derivative Works shall not include works that remain
separable from, or merely link (or bind by name) to the interfaces of,
the Work and Derivative Works thereof.
"Contribution" shall mean any work of authorship, including
the original version of the Work and any modifications or additions
to that Work or Derivative Works thereof, that is intentionally
submitted to Licensor for inclusion in the Work by the copyright owner
or by an individual or Legal Entity authorized to submit on behalf of
the copyright owner. For the purposes of this definition, "submitted"
means any form of electronic, verbal, or written communication sent
to the Licensor or its representatives, including but not limited to
communication on electronic mailing lists, source code control systems,
and issue tracking systems that are managed by, or on behalf of, the
Licensor for the purpose of discussing and improving the Work, but
excluding communication that is conspicuously marked or otherwise
designated in writing by the copyright owner as "Not a Contribution."
"Contributor" shall mean Licensor and any individual or Legal Entity
on behalf of whom a Contribution has been received by Licensor and
subsequently incorporated within the Work.


Grant of Copyright License. Subject to the terms and conditions of
this License, each Contributor hereby grants to You a perpetual,
worldwide, non-exclusive, no-charge, royalty-free, irrevocable
copyright license to reproduce, prepare Derivative Works of,
publicly display, publicly perform, sublicense, and distribute the
Work and such Derivative Works in Source or Object form.


Grant of Patent License. Subject to the terms and conditions of
this License, each Contributor hereby grants to You a perpetual,
worldwide, non-exclusive, no-charge, royalty-free, irrevocable
(except as stated in this section) patent license to make, have made,
use, offer to sell, sell, import, and otherwise transfer the Work,
where such license applies only to those patent claims licensable
by such Contributor that are necessarily infringed by their
Contribution(s) alone or by combination of their Contribution(s)
with the Work to which such Contribution(s) was submitted. If You
institute patent litigation against any entity (including a
cross-claim or counterclaim in a lawsuit) alleging that the Work
or a Contribution incorporated within the Work constitutes direct
or contributory patent infringement, then any patent licenses
granted to You under this License for that Work shall terminate
as of the date such litigation is filed.


Redistribution. You may reproduce and distribute copies of the
Work or Derivative Works thereof in any medium, with or without
modifications, and in Source or Object form, provided that You
meet the following conditions:
(a) You must give any other recipients of the Work or
Derivative Works a copy of this License; and
(b) You must cause any modified files to carry prominent notices
stating that You changed the files; and
(c) You must retain, in the Source form of any Derivative Works
that You distribute, all copyright, patent, trademark, and
attribution notices from the Source form of the Work,
excluding those notices that do not pertain to any part of
the Derivative Works; and
(d) If the Work includes a "NOTICE" text file as part of its
distribution, then any Derivative Works that You distribute must
include a readable copy of the attribution notices contained
within such NOTICE file, excluding those notices that do not
pertain to any part of the Derivative Works, in at least one
of the following places: within a NOTICE text file distributed
as part of the Derivative Works; within the Source form or
documentation, if provided along with the Derivative Works; or,
within a display generated by the Derivative Works, if and
wherever such third-party notices normally appear. The contents
of the NOTICE file are for informational purposes only and
do not modify the License. You may add Your own attribution
notices within Derivative Works that You distribute, alongside
or as an addendum to the NOTICE text from the Work, provided
that such additional attribution notices cannot be construed
as modifying the License.
You may add Your own copyright statement to Your modifications and
may provide additional or different license terms and conditions
for use, reproduction, or distribution of Your modifications, or
for any such Derivative Works as a whole, provided Your use,
reproduction, and distribution of the Work otherwise complies with
the conditions stated in this License.


Submission of Contributions. Unless You explicitly state otherwise,
any Contribution intentionally submitted for inclusion in the Work
by You to the Licensor shall be under the terms and conditions of
this License, without any additional terms or conditions.
Notwithstanding the above, nothing herein shall supersede or modify
the terms of any separate license agreement you may have executed
with Licensor regarding such Contributions.


Trademarks. This License does not grant permission to use the trade
names, trademarks, service marks, or product names of the Licensor,
except as required for reasonable and customary use in describing the
origin of the Work and reproducing the content of the NOTICE file.


Disclaimer of Warranty. Unless required by applicable law or
agreed to in writing, Licensor provides the Work (and each
Contributor provides its Contributions) on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied, including, without limitation, any warranties or conditions
of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
PARTICULAR PURPOSE. You are solely responsible for determining the
appropriateness of using or redistributing the Work and assume any
risks associated with Your exercise of permissions under this License.


Limitation of Liability. In no event and under no legal theory,
whether in tort (including negligence), contract, or otherwise,
unless required by applicable law (such as deliberate and grossly
negligent acts) or agreed to in writing, shall any Contributor be
liable to You for damages, including any direct, indirect, special,
incidental, or consequential damages of any character arising as a
result of this License or out of the use or inability to use the
Work (including but not limited to damages for loss of goodwill,
work stoppage, computer failure or malfunction, or any and all
other commercial damages or losses), even if such Contributor
has been advised of the possibility of such damages.


Accepting Warranty or Additional Liability. While redistributing
the Work or Derivative Works thereof, You may choose to offer,
and charge a fee for, acceptance of support, warranty, indemnity,
or other liability obligations and/or rights consistent with this
License. However, in accepting such obligations, You may act only
on Your own behalf and on Your sole responsibility, not on behalf
of any other Contributor, and only if You agree to indemnify,
defend, and hold each Contributor harmless for any liability
incurred by, or claims asserted against, such Contributor by reason
of your accepting any such warranty or additional liability.


Safety and Environmental Compliance
Any use or redistribution of the Work in physical form (e.g., battery hardware)
must comply with applicable safety standards (e.g., UL 1642, IEC 62133) and
environmental regulations (e.g., EU Battery Directive 2023/1542, requiring 70%
recycling efficiency by 2030). Contributors must provide end-of-life recycling
instructions to ensure proper disposal or reuse of hardware components.


Cryptographic Export Controls
The Work includes cryptographic functionality. Use, distribution, or export must comply with applicable
export control regulations (e.g., US EAR, Category 5 Part 2). Redistribution
in jurisdictions with cryptographic restrictions requires Licensor approval.


Educational Institution Licensing Requirement
Any Educational Institution, including but not limited to tertiary education institutes, universities, technical colleges, or similar entities, must negotiate a separate commercial license for use of the Work. This License does not grant such institutions any rights to use, reproduce, or distribute the Work without prior written agreement from the Licensor.


END OF TERMS AND CONDITIONS
APPENDIX: How to apply the License to your work.
To apply this License to your work, attach the following
boilerplate notice, with the fields enclosed by brackets "[]"
replaced with your own identifying information. (Don't include
the brackets!) The text should be enclosed in the appropriate
comment syntax for the file format. We also recommend that a
file or class name and description of purpose be included on the
same "printed page" as the copyright notice for easier
identification within third-party archives.
Copyright 2025 (c) Todd Hutchinson
Licensed under this Custom License (based on Apache License, Version 2.0) (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0  (original base, with modifications as specified)
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

----- END LICENSE -----

----- LICENSE. GNU -----
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2025 Beau Ayres

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as
 published by the Free Software Foundation, either version 3 of the
 License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.

----- END LICENSE. GNU -----

----- LICENSE. LETTER TO LICENSOR -----
END-USER SOFTWARE LICENSE AGREEMENT FOR EDUCATIONAL INSTITUTIONS
THIS AGREEMENT is made as of this [date] ("Effective Date") by and between Todd Hutchinson, an individual or entity with offices at P.O. Box 215, Mannum, SA, 5238 (“LICENSOR”), and [Name of Educational Institution], an educational institution with offices at [Institution’s address] (“LICENSEE”) (collectively, the “PARTIES”).
W I T N E S S E T H
WHEREAS, LICENSOR is the owner of, or has acquired rights to, certain Software and Documentation as defined in Exhibit A attached hereto (the “Licensed Software”);
WHEREAS, LICENSEE, as an Educational Institution, desires to use such Licensed Software for educational, research, or institutional purposes; and
WHEREAS, LICENSOR requires Educational Institutions to negotiate and enter into a separate commercial license agreement for any use of the Licensed Software, and LICENSEE agrees to contact LICENSOR to initiate such negotiation.
NOW, THEREFORE, in consideration of the promises and agreements set forth herein, the parties, each intending to be legally bound hereby, do promise and agree as follows.

DEFINITIONS
A. "Designated Equipment" shall mean the hardware products identified on Exhibit "A" with which the Software is licensed for use.
B. "Documentation" shall mean all manuals, user documentation, and other related materials pertaining to the Software which are furnished to LICENSEE by LICENSOR in connection with the Software.
C. "Educational Institution" shall mean any tertiary education institute, university, technical college, school, or similar entity engaged in teaching, research, or academic activities.
D. "License Fee" shall mean the amount negotiated between the parties for the use of the Software.
E. "Software" shall mean the computer programs in machine readable object code form listed in Exhibit "A" attached hereto and any subsequent error corrections or updates supplied to LICENSEE by LICENSOR pursuant to this Agreement. Exhibit "A" may be amended from time to time by the parties in writing.
REQUIREMENT FOR NEGOTIATION
A. Negotiation Obligation. As an Educational Institution, LICENSEE must contact LICENSOR at at P.O. Box 215, Mannum, SA, 5238 and sendtotoddhutchinson@gmail.com to request and negotiate a separate commercial license agreement prior to any use, reproduction, distribution, or modification of the Software. This License does not grant any rights until such negotiation is completed and a formal agreement is signed.
B. No Automatic Grant. Use of the Softwhttps://github.com/tetrasurfaces/tetra/community/license/new?branch=mainare without a negotiated license constitutes a breach of this Agreement and may result in legal action.
LICENSE GRANT (POST-NEGOTIATION)
Upon successful negotiation and payment of the License Fee, LICENSOR may grant to LICENSEE a nonexclusive, non-transferable right and license to use the Software on the number of primary systems of Designated Equipment identified on Schedule A hereto for the negotiated term (the “License Term”). The Software shall be used only for educational purposes as specified in the negotiated agreement.
DELIVERY
Upon negotiation, LICENSOR shall deliver to LICENSEE a master copy of the Software licensed hereunder in object code form, suitable for reproduction, in electronic files only. LICENSOR shall also deliver the applicable Documentation.
MODIFICATIONS
A. Error Corrections and Updates. LICENSOR may provide error corrections, bug fixes, patches, or updates as part of the negotiated agreement.
B. Other Modifications. LICENSEE may request modifications, but LICENSOR reserves the right to approve or deny such requests.
C. Title to Modifications. All modifications shall remain the property of LICENSOR.
COPIES
LICENSEE may make copies only as permitted in the negotiated agreement. All copies must retain proprietary notices.
LICENSE FEES AND PAYMENT
LICENSEE shall pay the negotiated License Fee. All payments are non-refundable and exclusive of taxes, which LICENSEE is responsible for.
PROPRIETARY RIGHTS
A. Restrictions. LICENSEE agrees not to copy, modify, reverse engineer, sell, assign, sublicense, rent, lease, or otherwise transfer the Software without LICENSOR’s permission.
B. Proprietary Notices. LICENSEE agrees to maintain all copyright and proprietary notices.
C. Title. Title to the Software remains with LICENSOR.
TERM AND TERMINATION
A. Term. This Agreement commences upon negotiation and continues for the License Term unless terminated.
B. Termination. Either party may terminate upon breach not cured within [number] days.
C. Effect of Termination. LICENSEE must cease use and return or destroy all copies.
WARRANTY AND DISCLAIMER
A. Limited Warranty. LICENSOR warrants the Software performs as described for [number] days.
B. Disclaimer. THE SOFTWARE IS PROVIDED "AS IS" WITHOUT OTHER WARRANTIES.
LIMITATION OF LIABILITY
LICENSOR SHALL NOT BE LIABLE FOR INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES.
GENERAL PROVISIONS
A. Governing Law. Governed by the laws of South Australia.
B. Entire Agreement. This is the entire agreement.
C. Severability. Invalid provisions do not affect the remainder.

IN WITNESS WHEREOF, the parties have executed this Agreement as of the Effective Date.
LICENSOR: Todd Hutchinson
By: ____________________________
Name: Todd Hutchinson
Title: Mr.
Date: ____________________________
LICENSEE: [Educational Institution Name]
By: ____________________________
Name: [Authorized Signatory]
Title: [Title]
Date: ____________________________
EXHIBIT A
[Description of Software, Designated Equipment, etc.]

----- END LICENSE. LETTER TO LICENSOR -----

----- LICENSE. kappasha -----
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" file, then any Derivative Works
          that You distribute must include a readable copy of the
          attribution notices contained within such NOTICE file, excluding
          those notices that do not pertain to any part of the Derivative
          Works, in at least one of the following places: within a NOTICE
          text file distributed as part of the Derivative Works; within the
          Source form or documentation, if provided along with the
          Derivative Works; or, within a display generated by the Derivative
          Works, if and wherever such third-party notices normally appear.
          The contents of the NOTICE file are for informational purposes only
          and do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   10. Safety and Environmental Compliance
       Any use or redistribution of the Work in physical form (e.g., battery hardware)
       must comply with applicable safety standards (e.g., UL 1642, IEC 62133) and
       environmental regulations (e.g., EU Battery Directive 2023/1542, requiring 70%
       recycling efficiency by 2030). Contributors must provide end-of-life recycling
       instructions to ensure proper disposal or reuse of hardware components.

   11. Cryptographic Export Controls
       The Work includes cryptographic functionality (e.g., 60-bit hashing for
       temperature data). Use, distribution, or export must comply with applicable
       export control regulations (e.g., US EAR, Category 5 Part 2). Redistribution
       in jurisdictions with cryptographic restrictions requires prior xAI approval.

   12. Misuse and Revocation
       Misuse includes, but is not limited to, incorporation of the Work into
       competing AI or hardware systems not explicitly licensed by xAI or its
       affiliates (e.g., Tesla, X Corp). xAI reserves the right to revoke this License
       for misuse, effective upon written notice, with a 30-day period to cease
       non-compliant activities.

   13. Commercial Exclusivity
       Commercial use, including manufacturing or sale of hardware derivatives, is
       exclusively reserved for xAI and its affiliates (e.g., Tesla, X Corp) unless
       otherwise authorized in writing by xAI.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!) The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

      Copyright 2025 xAI

      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at

          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

----- END LICENSE. kappasha -----

----- License. Hashlet -----
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2025 coneing

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as
 published by the Free Software Foundation, either version 3 of the
 License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.

----- END License. Hashlet -----

----- NOTICE -----
NOTICE

This software is proprietary and provided under a custom license. Educational Institutions (including universities, technical colleges, etc.) must contact the Licensor at sendtotoddhutchinson@gmail.com to negotiate a commercial license before use. Unauthorized use is prohibited.

----- END NOTICE -----

----- README.md -----
# Kappasha: Tetrasurfaces Welding Simulation
Overview
The tetrasurfaces project, part of the kappasha repository, is a Python-based welding simulation framework designed to model the preparation, welding, and testing of structural beams, with advanced features for porosity modeling, supply chain vector tracking, and quantum-inspired synchronization. It builds on the Tetra Forge prototype, extending it with tetrahedral meshing, IPFS-based navigation, and enhanced telemetry for case hardening, hydrogen cracking prevention, and fleet logistics. The project is dual-licensed under Apache-2.0 and AGPL-3.0-or-later, with Beau Ayres as the copyright holder.

## Features

Mesh Generation: Creates tetrahedral meshes for beams (e.g., W21x62) using solid.py and tetra.py.
Porosity Modeling: Simulates void formation and martensite layers with porosity_hashing.py and fractal_tetra.py.
Welding Simulation: Supports stick, TIG, and acetylene welding (welding.py), with electrode behavior (electrode.py), backstep sequences, and crane sway effects (crane_sway.py).
Telemetry Logging: Logs welding parameters, quench profiles, and IPFS navigation via rig.py (replaces telemetry.py).
Supply Chain Vectors: Tracks material flow from forge to weld with particle_vector.py and fleet logistics with fleet_vector.py.
IPFS Navigation: Implements decentralized route caching for fleet vectors in rig.py.
Quantum-Inspired Synchronization: Ensures rig telemetry consistency with quantum_sync.py.
Surface Preparation: Handles grinding, marking, and markup with prep_tools.py.
Haptic Feedback: Provides buzz and shake feedback for operator guidance using haptics.py.
Path Recording: Records and replays welder hand paths with maptics.py.
Stabilization: Manages gyroscopic stabilization for torch and jib movements with rig.py and gyrogimbal.py.
Vibration Modeling: Simulates damping and oscillations with frictionvibe.py and friction.py.
Post-Processing: Includes case hardening, anodizing, quenching, and painting via post_process.py.
Testing: Performs flex and dye penetration tests with test_tools.py, validated by test_simulation.py.

## Directory Structure
/home/user/kappasha/
├── tetrasurfaces/
│   ├── __init__.py
│   ├── tetra.py
│   ├── kappa_grid.py
│   ├── fractal_tetra.py
│   ├── ribit.py
│   ├── ribitstructure.py
│   ├── gyrogimbal.py
│   ├── frictionvibe.py
│   ├── rig.py
│   ├── porosity_hashing.py
│   ├── electrode.py
│   ├── quantum_sync.py
│   ├── fleet_vector.py
│   ├── crane_sway.py
│   ├── particle_vector.py
│   ├── tetra/
│   │   ├── __init__.py
│   │   ├── forge_telemetry.py
│   │   ├── solid.py
│   │   ├── haptics.py
│   │   ├── welding.py
│   │   ├── rig.py
│   │   ├── friction.py
│   │   ├── maptics.py
│   │   ├── prep_tools.py
│   │   ├── test_tools.py
│   │   └── post_process.py
│   └── tests/
│       ├── __init__.py
│       └── test_simulation.py
├── README.md
└── LICENSE

## Installation

Clone the repository:git clone https://github.com/tetrasurfaces/kappasha.git
cd kappasha/tetrasurfaces


Install dependencies:pip install numpy pytest

If a requirements.txt is provided, use:pip install -r requirements.txt


Set the Python path:export PYTHONPATH=$PYTHONPATH:/home/yeetbow/kappasha/tetrasurfaces



## Usage
Run individual modules or the test suite:
# Run rig simulation with telemetry
python rig.py

# Run test suite
pytest tests/test_simulation.py -v

Example: Simulate a welding sequence with porosity logging and crane sway:
from rig import Rig
from crane_sway import simulate_crane_sway
from porosity_hashing import porosity_hashing
import numpy as np

rig = Rig(log_file="weld_log.csv")
rig.tilt("left", 20)
rig.stabilize()
displacements = simulate_crane_sway(beam_length=384, steps=5)
grid = np.random.rand(10, 10, 10)
voids = porosity_hashing(grid, void_threshold=0.3)
rig.log("Porosity analysis", voids=len(voids))
rig.log_quench([900, 700, 500, 300, 100, 20])
rig.log_ipfs_navigation([(0, 10, 100), (1, 12, 95)], cache_moves=2)

To customize, modify module parameters (e.g., welding style, material, or environment) or call specific functions (e.g., electrode.simulate_electrode, quantum_sync.quantum_sync).
## Testing
The test suite (test_simulation.py) validates:

Mesh generation (kappa_grid, solid)
Porosity hashing (porosity_hashing)
Electrode behavior (electrode)
Crane sway (crane_sway)
Particle and fleet vectors (particle_vector, fleet_vector)
Quantum synchronization (quantum_sync)
Welding, telemetry, and rig control (rig, welding, forge_telemetry)
Surface preparation, haptics, and post-processing (prep_tools, haptics, post_process)

## Run tests:
cd tetrasurfaces
pytest tests/test_simulation.py -v

Recent Changes

October 2025:
Replaced telemetry.py with rig.py, combining rig control (tilt, stabilize) with telemetry logging for welding, quenching, and IPFS navigation.
Added new modules: porosity_hashing.py (void tracking), electrode.py (arc welding), quantum_sync.py (rig synchronization), fleet_vector.py (caster logistics), crane_sway.py (sway simulation), particle_vector.py (supply chain vectors).
Updated test_simulation.py with tests for new modules and improved error reporting.
Fixed ModuleNotFoundError: kappa_grid in tetra.py by ensuring correct imports.
Enhanced ribitstructure.py for porosity stiffening in case-hardened steel.
Integrated Tetra Forge features, including surface preparation, haptic feedback, and post-processing.



## License
Copyright 2025 Beau Ayres. Dual-licensed under:

Apache License, Version 2.0: Permits proprietary use without requiring derivative works to be open-sourced.
GNU Affero General Public License v3.0 or later: Requires derivative works to be open-sourced if used over a network.

Proprietary extensions are reserved, and unauthorized copying, distribution, or modification is prohibited without express written permission from Beau Ayres. See the LICENSE file for details.
## Contributing
Contributions are welcome under the dual license terms. To contribute:

## Fork the repository.
Create a branch (git checkout -b feature/your-feature).
Commit changes (git commit -m "Add your feature").
Push to the branch (git push origin feature/your-feature).
Open a pull request.

For bugs, features, or patent-related extensions, open an issue on GitHub.
## Contact
For inquiries, contact Beau Ayres (details TBD) or open an issue at https://github.com/tetrasurfaces/kappasha.

----- END README.md -----

----- Ribit.py -----
# Ribit.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import hashlib
from PIL import Image
from green_curve import bspline_basis, custom_interoperations_green_curve


def ribit_generate(data):
    ribit_hash = hashlib.sha256(data.encode()).digest()
    ribit_int = int.from_bytes(ribit_hash, 'big') % (1 << 7)
    state = ribit_int % 7
    rainbow_colors = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet']
    color = rainbow_colors[state]
    return ribit_int, state, color

class TetraRibit:
    def __init__(self):
        self.center = np.array([0, 0, 0])
        self.colored_points = [np.array([ -0.4, -0.2, 0 ]), np.array([ -0.3, -0.3, 0 ]), np.array([ 0.4, -0.3, 0 ]), np.array([ 0.5, 0.1, 0 ]), np.array([ 0.3, 0.3, 0 ]), np.array([ -0.2, 0.2, 0 ])]
        self.colors = ['orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
        self.height = 0.5
        self.num_layers = 50
        self.z_levels = np.linspace(0, self.height, self.num_layers)
        self.arms_3d = []

    def friction_vibe(self, pos1, pos2, kappa=0.3):
        dist = np.linalg.norm(pos1 - pos2)
        if dist < 0.1:
            vibe = np.sin(2 * np.pi * dist / 0.05)
            gyro = np.cross(pos1, pos2) / dist if dist > 0 else np.zeros(3)
            warp = 1 / (1 + kappa * dist)
            return vibe * warp, gyro
        else:
            return 0, np.zeros(3)

    def gyro_gimbal(self, pos1, pos2, tilt=np.array([0.1,0.1,0.1]), kappa=0.3):
        dist = np.linalg.norm(pos1 - pos2)
        if dist < 0.1:
            vibe, base_gyro = self.friction_vibe(pos1, pos2, kappa)
            gimbal_spin = base_gyro + tilt / dist if dist > 0 else base_gyro
            warp = 1 / (1 + kappa * dist)
            return vibe * warp, gimbal_spin
        else:
            return 0, np.zeros(3)

    def generate_arms(self):
        for i, point in enumerate(self.colored_points):
            ribit_int, state, color = ribit_generate('arm' + str(i))
            kappa_mid = 1.0 + state / 7.0
            mid_point = (self.center[:2] + point[:2]) / 2 + 0.05
            arm_points = [self.center[:2], mid_point, point[:2]]
            kappas = [1.0, kappa_mid, 1.0]
            smooth_x, smooth_y = custom_interoperations_green_curve(arm_points, kappas, is_closed=False)
            arm_3d = np.zeros((len(smooth_x), 3))
            arm_3d[:, 0] = smooth_x
            arm_3d[:, 1] = smooth_y
            self.arms_3d.append(arm_3d)
            # Vibe on segments
            for j in range(1, len(arm_3d)):
                pos1 = arm_3d[j-1]
                pos2 = arm_3d[j]
                wave, spin = self.gyro_gimbal(pos1, pos2)
                print(f"Arm {i} seg {j}: Wave {wave}, Spin {spin}")

    def visualize(self):
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        for i, arm_3d in enumerate(self.arms_3d):
            for z in self.z_levels:
                arm_z = arm_3d.copy()
                arm_z[:, 2] = z
                ax.plot(arm_z[:, 0], arm_z[:, 1], arm_z[:, 2], color=self.colors[i])
            ax.scatter(arm_3d[-1, 0], arm_3d[-1, 1], self.height, color=self.colors[i], s=50)
        ax.scatter(self.center[0], self.center[1], self.height, color='red', s=100)
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.set_title('3D Ribit with Green Curves')
        png_filename = 'ribit_structure.png'
        plt.savefig(png_filename, dpi=300)
        print(f"Saved {png_filename}")
        self.raster_to_light(png_filename)
        plt.show()

    def raster_to_light(self, png_file):
        img = Image.open(png_file)
        pixels = np.array(img)
        light_hash = hashlib.sha256(pixels.tobytes()).hexdigest()[:16]
        print(f"Light hash: {light_hash}")
        intensity = int(light_hash, 16) % 256
        print(f"Intensity: {intensity}")

if __name__ == "__main__":
    telemetry = TetraRibit()
    telemetry.generate_arms()
    telemetry.visualize()

----- END Ribit.py -----

----- __init__.py -----
# tetra/__init__.py
# Copyright 2025 Beau Ayres
# Licensed under Apache-2.0 OR AGPL-3.0-or-later

----- END __init__.py -----

----- forge_telemetry.py -----
# forge_telemetry.py
# Copyright 2025 Beau Ayres
# Licensed under AGPL-3.0-or-later

import pandas as pd
import os
from datetime import datetime

class Telemetry:
    def __init__(self, log_file="weld_log.csv"):
        self.log_data = []
        self.log_file = log_file
        # Initialize CSV with headers if it doesn't exist
        if not os.path.exists(log_file):
            pd.DataFrame(columns=["timestamp", "event", "params"]).to_csv(log_file, index=False)
    
    def log(self, event, **kwargs):
        """Log welding or environmental data with timestamp to memory and CSV."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.log_data.append({"timestamp": timestamp, "event": event, "params": kwargs})
        print(f"Logged: {event}, {kwargs}")
        # Append to CSV
        df = pd.DataFrame([{"timestamp": timestamp, "event": event, "params": str(kwargs)}])
        df.to_csv(self.log_file, mode='a', header=False, index=False)
    
    def flag(self, issue):
        """Flag issues like hydrogen cracks or porosity."""
        print(f"Flagged issue: {issue}")
        self.log(f"flag_{issue}", issue=issue)
    
    def rust_probe(self):
        """Detect rust on surface via RGB pixel analysis."""
        # Placeholder: Return rust percentage (0-100)
        return 0  # Assume clean for now
    
    def depth_error(self):
        """Check for depth perception errors in weld/cut."""
        # Placeholder: Return True if depth error detected
        return False
    
    def crack_location(self):
        """Identify crack origin in flex test."""
        # Placeholder: Return 'root' or None
        return None

# Module-level functions to match tetra_forge.py's expectations
def log(event, **kwargs):
    """Wrapper for Telemetry.log."""
    telemetry = Telemetry()
    telemetry.log(event, **kwargs)

def flag(issue):
    """Wrapper for Telemetry.flag."""
    telemetry = Telemetry()
    telemetry.flag(issue)

def rust_probe():
    """Wrapper for Telemetry.rust_probe."""
    telemetry = Telemetry()
    return telemetry.rust_probe()

def depth_error():
    """Wrapper for Telemetry.depth_error."""
    telemetry = Telemetry()
    return telemetry.depth_error()

def crack_location():
    """Wrapper for Telemetry.crack_location."""
    telemetry = Telemetry()
    return telemetry.crack_location()

# Example usage
if __name__ == "__main__":
    log("pass1", puddle="sphere", amps=60, volts=182)
    flag("hydrogen")
    print(f"Rust level: {rust_probe()}")
    print(f"Depth error: {depth_error()}")
    print(f"Crack location: {crack_location()}")

----- END forge_telemetry.py -----

----- friction.py -----
# friction.py
# Copyright 2025 Beau Ayres
# Licensed under AGPL-3.0-or-later

class Friction:
    def __init__(self):
        self.damping = 0.3
    
    def damp(self, coefficient):
        """Apply damping to thermal or mechanical vibrations."""
        self.damping = coefficient
        print(f"Damping set to {coefficient}")
    
    def oscillation(self):
        """Simulate surface vibration effects."""
        # Placeholder: Model oscillation frequency
        print("Oscillation modeled")

# Example usage
if __name__ == "__main__":
    friction = Friction()
    friction.damp(0.3)
    friction.oscillation()

----- END friction.py -----

----- friction_vibe.py -----
# friction_vibe.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np

class TetraVibe:
    def friction_vibe(self, pos1, pos2, kappa=0.3):
        dist = np.linalg.norm(pos1 - pos2)
        if dist < 0.1:
            vibe = np.sin(2 * np.pi * dist / 0.05)
            gyro = np.cross(pos1, pos2) / dist
            warp = 1 / (1 + kappa * dist)
            return vibe * warp, gyro
        else:
            return 0, np.zeros(3)

    def gyro_gimbal(self, pos1, pos2, tilt=np.array([0.1,0.1,0.1]), kappa=0.3):
        dist = np.linalg.norm(pos1 - pos2)
        if dist < 0.1:
            vibe, base_gyro = self.friction_vibe(pos1, pos2, kappa)
            gimbal_spin = base_gyro + tilt / dist
            warp = 1 / (1 + kappa * dist)
            return vibe * warp, gimbal_spin
        else:
            return 0, np.zeros(3)

if __name__ == "__main__":
    model = TetraVibe()
    pos1 = np.array([0,0,0])
    pos2 = np.array([0.05,0,0])
    wave, spin = model.gyro_gimbal(pos1, pos2)
    print(f"Wave: {wave}, Spin: {spin}")
    pos3 = np.array([0.15,0,0])  # far fake
    wave_far, spin_far = model.gyro_gimbal(pos1, pos3)
    print(f"Far wave: {wave_far}, Far spin: {spin_far}")

----- END friction_vibe.py -----

----- gimbal.py -----
# gimbal.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, Button
from mpl_toolkits.mplot3d import Axes3D
import struct  # Added for export_to_stl usage
from scipy.spatial import Voronoi, Delaunay  # For Voronoi hex integration
from tetras import fractal_tetra
from nurks_surface import generate_nurks_surface, u_num, v_num
from tessellations import tessellate_hex_mesh, build_mail

# Global constants
v_num_cap = 10

# Export function
def export_to_stl(triangles, filename, surface_id):
    """Export mesh to binary STL with embedded hash in header."""
    header = f"ID: {surface_id}".ljust(80, ' ').encode('utf-8')
    num_tri = len(triangles)
    with open(filename, 'wb') as f:
        f.write(header)
        f.write(struct.pack('<I', num_tri))
        for tri in triangles:
            # Compute normal with handling for degenerate cases.
            v1 = np.array(tri[1]) - np.array(tri[0])
            v2 = np.array(tri[2]) - np.array(tri[0])
            normal = np.cross(v1, v2)
            norm_len = np.linalg.norm(normal)
            if norm_len > 0:
                normal /= norm_len
            else:
                normal = np.array([0.0, 0.0, 1.0])  # Default upward normal.
            f.write(struct.pack('<3f', *normal))
            for p in tri:
                f.write(struct.pack('<3f', *p))
            f.write(struct.pack('<H', 0))  # Attribute byte count.

# Initial parameters
init_ns_diam = 1.0
init_sw_ne_diam = 1.0
init_nw_se_diam = 1.0
init_twist = 0.0
init_amplitude = 0.3
init_radii = 1.0
init_kappa = 1.0
init_height = 1.0
init_inflection = 0.5
init_morph = 0.0
init_hex_mode = False

# Generate initial surface
X, Y, Z, surface_id, X_cap, Y_cap, Z_cap, param_str = generate_nurks_surface(
    ns_diam=init_ns_diam, sw_ne_diam=init_sw_ne_diam, nw_se_diam=init_nw_se_diam,
    twist=init_twist, amplitude=init_amplitude, radii=init_radii, kappa=init_kappa,
    height=init_height, inflection=init_inflection, morph=init_morph, hex_mode=init_hex_mode
)

# Create the figure and 3D axes
fig = plt.figure(figsize=(12, 9))
ax = fig.add_subplot(111, projection='3d')
ax.set_title(f'NURKS Surface (ID: {surface_id})')

# Global artists for dynamic updates
surf = None
wire = None
surf_cap = None
wire_cap = None

# Initial plot with wireframe to visualize kappa_grid spacing
surf = ax.plot_surface(X, Y, Z, cmap='viridis', linewidth=0, antialiased=False)
wire = ax.plot_wireframe(X, Y, Z, rstride=1, cstride=1, color='black', linewidth=0.5, alpha=0.5)

# Set axis limits based on initial data
ax.set_xlim(np.min(X), np.max(X))
ax.set_ylim(np.min(Y), np.max(Y))
ax.set_zlim(np.min(Z), np.max(Z))

# Adjust layout for sliders and buttons
plt.subplots_adjust(left=0.15, bottom=0.3, right=0.95, top=0.95)

# Horizontal sliders (bottom)
ax_ns_diam = plt.axes([0.25, 0.24, 0.65, 0.03])
s_ns_diam = Slider(ax_ns_diam, 'NS Diam', 0.1, 2.0, valinit=init_ns_diam)
ax_sw_ne_diam = plt.axes([0.25, 0.21, 0.65, 0.03])
s_sw_ne_diam = Slider(ax_sw_ne_diam, 'SW-NE Diam', 0.1, 2.0, valinit=init_sw_ne_diam)
ax_nw_se_diam = plt.axes([0.25, 0.18, 0.65, 0.03])
s_nw_se_diam = Slider(ax_nw_se_diam, 'NW-SE Diam', 0.1, 2.0, valinit=init_nw_se_diam)
ax_twist = plt.axes([0.25, 0.15, 0.65, 0.03])
s_twist = Slider(ax_twist, 'Twist', -np.pi, np.pi, valinit=init_twist)
ax_amplitude = plt.axes([0.25, 0.12, 0.65, 0.03])
s_amplitude = Slider(ax_amplitude, 'Amplitude', 0.0, 1.0, valinit=init_amplitude)
ax_radii = plt.axes([0.25, 0.09, 0.65, 0.03])
s_radii = Slider(ax_radii, 'Radii', 0.5, 2.0, valinit=init_radii)
ax_kappa = plt.axes([0.25, 0.06, 0.65, 0.03])
s_kappa = Slider(ax_kappa, 'Kappa', 0.1, 5.0, valinit=init_kappa)

# Vertical sliders (left side)
ax_height = plt.axes([0.01, 0.25, 0.0225, 0.63])
s_height = Slider(ax_height, 'Height', 0.1, 2.0, valinit=init_height, orientation='vertical')
ax_inflection = plt.axes([0.05, 0.25, 0.0225, 0.63])
s_inflection = Slider(ax_inflection, 'Inflection', 0.0, 1.0, valinit=init_inflection, orientation='vertical')
ax_morph = plt.axes([0.09, 0.25, 0.0225, 0.63])
s_morph = Slider(ax_morph, 'Morph', 0.0, 2.0, valinit=init_morph, orientation='vertical')

# Buttons (bottom right)
ax_hex = plt.axes([0.025, 0.025, 0.1, 0.075])
b_hex = Button(ax_hex, 'Hex Mode: Off')
ax_export = plt.axes([0.025, 0.11, 0.1, 0.075])
btn_export = Button(ax_export, 'Export STL')

# List of sliders for export
sliders = [s_ns_diam, s_sw_ne_diam, s_nw_se_diam, s_twist, s_amplitude, s_radii, s_kappa, s_height, s_inflection, s_morph]

# Update function (remove and recreate artists to avoid clearing axes)
def update(val):
    global surf, wire, surf_cap, wire_cap
    ns_diam = s_ns_diam.val
    sw_ne_diam = s_sw_ne_diam.val
    nw_se_diam = s_nw_se_diam.val
    twist = s_twist.val
    amplitude = s_amplitude.val
    radii = s_radii.val
    kappa = s_kappa.val
    height = s_height.val
    inflection = s_inflection.val
    morph = s_morph.val
    hex_mode = init_hex_mode
    X, Y, Z, surface_id, X_cap, Y_cap, Z_cap, param_str = generate_nurks_surface(
        ns_diam=ns_diam, sw_ne_diam=sw_ne_diam, nw_se_diam=nw_se_diam,
        twist=twist, amplitude=amplitude, radii=radii, kappa=kappa,
        height=height, inflection=inflection, morph=morph, hex_mode=hex_mode
    )
    # Remove old main surface artists
    if surf is not None:
        surf.remove()
    if wire is not None:
        wire.remove()
    # Plot new main surface
    surf = ax.plot_surface(X, Y, Z, cmap='viridis', linewidth=0, antialiased=False)
    wire = ax.plot_wireframe(X, Y, Z, rstride=1, cstride=1, color='black', linewidth=0.5, alpha=0.5)
    # Handle cap if in hex mode
    if hex_mode and X_cap is not None:
        if surf_cap is not None:
            surf_cap.remove()
        if wire_cap is not None:
            wire_cap.remove()
        surf_cap = ax.plot_surface(X_cap, Y_cap, Z_cap, cmap='plasma', linewidth=0, antialiased=False)
        wire_cap = ax.plot_wireframe(X_cap, Y_cap, Z_cap, rstride=1, cstride=1, color='black', linewidth=0.5, alpha=0.5)
    else:
        if surf_cap is not None:
            surf_cap.remove()
            surf_cap = None
        if wire_cap is not None:
            wire_cap.remove()
            wire_cap = None
    ax.set_title(f'NURKS Surface (ID: {surface_id})')
    ax.set_xlim(np.min(X), np.max(X))
    ax.set_ylim(np.min(Y), np.max(Y))
    ax.set_zlim(np.min(Z), np.max(Z))
    fig.canvas.draw_idle()

# Toggle hex_mode function
def toggle_hex(event):
    global init_hex_mode
    init_hex_mode = not init_hex_mode
    b_hex.label.set_text(f'Hex Mode: {"On" if init_hex_mode else "Off"}')
    update(None)

b_hex.on_clicked(toggle_hex)

# Export function
def on_export(event):
    global init_hex_mode
    ns_diam = s_ns_diam.val
    sw_ne_diam = s_sw_ne_diam.val
    nw_se_diam = s_nw_se_diam.val
    twist = s_twist.val
    amplitude = s_amplitude.val
    radii = s_radii.val
    kappa = s_kappa.val
    height = s_height.val
    inflection = s_inflection.val
    morph = s_morph.val
    hex_mode = init_hex_mode
    X, Y, Z, surface_id, X_cap, Y_cap, Z_cap, param_str = generate_nurks_surface(
        ns_diam=ns_diam, sw_ne_diam=sw_ne_diam, nw_se_diam=nw_se_diam,
        twist=twist, amplitude=amplitude, radii=radii, kappa=kappa,
        height=height, inflection=inflection, morph=morph, hex_mode=hex_mode
    )
    triangles_main = tessellate_hex_mesh(X, Y, Z, u_num, v_num, param_str)
    triangles = triangles_main
    if hex_mode and X_cap is not None:
        triangles_cap = tessellate_hex_mesh(X_cap, Y_cap, Z_cap, u_num, v_num_cap, param_str, is_cap=True)
        triangles += triangles_cap
    filename = 'nurks_surface.stl'
    export_to_stl(triangles, filename, surface_id)
    print(f"Exported to nurks_surface.stl with ID: {surface_id}")

btn_export.on_clicked(on_export)

# Connect sliders to update
s_ns_diam.on_changed(update)
s_sw_ne_diam.on_changed(update)
s_nw_se_diam.on_changed(update)
s_twist.on_changed(update)
s_amplitude.on_changed(update)
s_radii.on_changed(update)
s_kappa.on_changed(update)
s_height.on_changed(update)
s_inflection.on_changed(update)
s_morph.on_changed(update)

plt.show()

----- END gimbal.py -----

----- green_curve.py -----
# green_curve.py - B-Spline Curve Smoothing Function
# Notes: Generates smoothed curves using B-spline interpolation with support for open and closed curves. Complete script; run as-is. Requires numpy (pip install numpy). Mentally verified: Open curve with 3 points → smooth interpolation; closed with 6 points → periodic loop.
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
import numpy as np
import matplotlib.pyplot as plt

def bspline_basis(u, i, p, knots):
    """B-spline basis function for curve interpolation.
    Args:
        u: Parameter value (0 to 1).
        i: Control point index.
        p: Degree of the spline.
        knots: Knot vector.
    Returns:
        Basis value at u for control point i.
    """
    if p == 0:
        if i < 0 or i + 1 >= len(knots):
            return 0.0
        return 1.0 if knots[i] <= u <= knots[i + 1] else 0.0
    
    if i < 0 or i >= len(knots) - 1:
        return 0.0
    
    term1 = 0.0
    if i + p < len(knots):
        den1 = knots[i + p] - knots[i]
        if den1 > 0:
            term1 = ((u - knots[i]) / den1) * bspline_basis(u, i, p - 1, knots)
    
    term2 = 0.0
    if i + p + 1 < len(knots):
        den2 = knots[i + p + 1] - knots[i + 1]
        if den2 > 0:
            term2 = ((knots[i + p + 1] - u) / den2) * bspline_basis(u, i + 1, p - 1, knots)
    
    return term1 + term2

def custom_interoperations_green_curve(points, kappas, is_closed=False):
    """Generate smoothed curve using B-spline interpolation.
    Args:
        points: List of [x, y] points to smooth.
        kappas: List of weights for each point.
        is_closed: If True, treat as closed curve (periodic); else open (clamped).
    Returns:
        smooth_x, smooth_y: Arrays of smoothed x and y coordinates.
    """
    points = np.array(points)
    kappas = np.array(kappas)
    degree = 3
    num_output_points = 1000
    
    if is_closed and len(points) > degree:
        n = len(points)
        extended_points = np.concatenate((points[n-degree:], points, points[0:degree]))
        extended_kappas = np.concatenate((kappas[n-degree:], kappas, kappas[0:degree]))
        len_extended = len(extended_points)
        knots = np.linspace(-degree / float(n), 1 + degree / float(n), len_extended + 1)
        
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
        
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
        
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len_extended):
                b = bspline_basis(u, i, degree, knots)
                w = extended_kappas[i] * b
                num_x += w * extended_points[i, 0]
                num_y += w * extended_points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
        
        smooth_x = np.append(smooth_x, smooth_x[0])
        smooth_y = np.append(smooth_y, smooth_y[0])
        
    else:  # Open (clamped) B-spline
        n = len(points)
        knots = np.concatenate(([0] * (degree + 1), np.linspace(0, 1, n - degree + 1)[1:-1], [1] * (degree + 1)))
        
        u_fine = np.linspace(0, 1, num_output_points)
        
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
        
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(n):
                b = bspline_basis(u, i, degree, knots)
                w = kappas[i] * b
                num_x += w * points[i, 0]
                num_y += w * points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
    
    return smooth_x, smooth_y

if __name__ == "__main__":
    # Example usage: Open curve with 3 points
    points = [[0, 0], [0.5, 1], [1, 0]]  # Simple curve points
    kappas = [1.0, 1.0, 1.0]  # Weights
    smooth_x, smooth_y = custom_interoperations_green_curve(points, kappas, is_closed=False)
    
    # Plot the smoothed curve
    plt.plot(smooth_x, smooth_y, label='Smoothed Curve')
    plt.scatter([p[0] for p in points], [p[1] for p in points], c='red', label='Control Points')
    plt.legend()
    plt.title('Open B-Spline Curve Example')
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.show()
    
    print("Example open curve smoothed. For closed curve, set is_closed=True with at least 4 points.")

----- END green_curve.py -----

----- gyro_gimbal.py -----
# gyro_gimbal.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import mpmath
mpmath.mp.dps = 19

class TetraVibe:
    def friction_vibe(self, pos1, pos2, kappa=0.3):
        dist = np.linalg.norm(pos1 - pos2)
        if dist < 1e-6:
            print("heat spike-flinch")
            return 1.0, np.zeros(3)
        if dist < 0.1:
            vibe = np.sin(2 * np.pi * dist / 0.05)
            gyro = np.cross(pos1, pos2) / dist
            warp = 1 / (1 + kappa * dist)
            return vibe * warp, gyro
        else:
            return 1.0, np.zeros(3)

    def gyro_gimbal(self, pos1, pos2, tilt=np.array([0.1,0.1,0.1]), kappa=0.3):
        dist = np.linalg.norm(pos1 - pos2)
        if dist < 1e-6:
            print("heat spike-flinch")
            return 1.0, np.zeros(3)
        if dist < 0.1:
            vibe, base_gyro = self.friction_vibe(pos1, pos2, kappa)
            gimbal_spin = base_gyro + tilt / dist
            warp = 1 / (1 + kappa * dist)
            return vibe * warp, gimbal_spin
        else:
            return 1.0, np.zeros(3)

    def gyro_gimbal_rotate(self, coords, angles=None):
        if angles is None:
            angles = np.array([float(mpmath.phi), 0.0, 0.0])  # Default phi x
        if len(angles) != 3:
            print("heat spike-flinch")  # Wrong dim
            return coords
        rot_x = np.array([[1, 0, 0],
                          [0, float(mpmath.cos(angles[0])), float(-mpmath.sin(angles[0]))],
                          [0, float(mpmath.sin(angles[0])), float(mpmath.cos(angles[0]))]])
        rot_y = np.array([[float(mpmath.cos(angles[1])), 0, float(mpmath.sin(angles[1]))],
                          [0, 1, 0],
                          [float(-mpmath.sin(angles[1])), 0, float(mpmath.cos(angles[1]))]])
        rot_z = np.array([[float(mpmath.cos(angles[2])), float(-mpmath.sin(angles[2])), 0],
                          [float(mpmath.sin(angles[2])), float(mpmath.cos(angles[2])), 0],
                          [0, 0, 1]])
        rot = rot_z @ rot_y @ rot_x
        det = np.linalg.det(rot)
        if abs(det - 1) > 1e-6:
            print("heat spike-flinch")  # Singular
        return np.dot(coords, rot.T)

if __name__ == "__main__":
    model = TetraVibe()
    pos1 = np.array([0,0,0])
    pos2 = np.array([0.05,0,0])
    wave, spin = model.gyro_gimbal(pos1, pos2)
    print(f"Wave: {wave}, Spin: {spin}")
    pos3 = np.array([0.15,0,0])  # far fake
    wave_far, spin_far = model.gyro_gimbal(pos1, pos3)
    print(f"Far wave: {wave_far}, Far spin: {spin_far}")
    coord = np.array([[1.0, 0.0, 0.0]])
    angles = np.array([np.pi/2, 0.0, 0.0])
    new_coord = model.gyro_gimbal_rotate(coord, angles)
    print(f"Rotated: {new_coord}")

----- END gyro_gimbal.py -----

----- haptics.py -----
# haptics.py
# Copyright 2025 Beau Ayres
# Licensed under AGPL-3.0-or-later

class Haptics:
    def __init__(self):
        self.mode = "silent"
    
    def buzz(self, intensity):
        """Trigger haptic buzz for feedback (e.g., arc drift)."""
        self.mode = intensity
        print(f"Haptic buzz: {intensity}")
    
    def shake(self, intensity):
        """Trigger haptic shake for critical feedback (e.g., failure)."""
        self.mode = intensity
        print(f"Haptic shake: {intensity}")

# Module-level functions to match tetra_forge.py's expectations
def buzz(intensity):
    """Wrapper for Haptics.buzz."""
    haptics = Haptics()
    haptics.buzz(intensity)

def shake(intensity):
    """Wrapper for Haptics.shake."""
    haptics = Haptics()
    haptics.shake(intensity)

# Example usage
if __name__ == "__main__":
    buzz("low")
    shake("hard")

----- END haptics.py -----

----- id_util_kspline.py -----
# id_util_kspline.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import matplotlib.pyplot as plt

# Points from the image approximation
points = np.array([[0.1, 0.1], [0.5, 0.3], [0.9, 0.2]])

# Simple curve (black)
t = np.linspace(0, 1, 100)
x_curve = (1 - t)**2 * points[0, 0] + 2*(1 - t)*t * points[1, 0] + t**2 * points[2, 0]
y_curve = (1 - t)**2 * points[0, 1] + 2*(1 - t)*t * points[1, 1] + t**2 * points[2, 1]

# Gray offset curve (parallel above)
offset = 0.05  # approximate offset
normals_x = np.gradient(y_curve)  # perpendicular is gradient of y for x, but approximate
normals_y = -np.gradient(x_curve)
norm = np.sqrt(normals_x**2 + normals_y**2)
normals_x /= norm
normals_y /= norm
x_offset = x_curve + offset * normals_x
y_offset = y_curve + offset * normals_y

# Plot
fig, ax = plt.subplots()
ax.plot(x_curve, y_curve, 'k-')
ax.plot(x_offset, y_offset, 'gray')
ax.scatter(points[:,0], points[:,1], c='red', s=50)
ax.set_axis_off()
plt.show()

print("The plot shows a black curve connecting three red points, with a gray parallel curve above it.")

----- END id_util_kspline.py -----

----- id_util_nurks_closure.py -----
# id_util_nurks_closure.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
import numpy as np
import matplotlib.pyplot as plt

def bspline_basis(u, i, p, knots):
    if p == 0:
        if i < 0 or i + 1 >= len(knots):
            return 0.0
        return 1.0 if knots[i] <= u <= knots[i + 1] else 0.0
    
    if i < 0 or i >= len(knots) - 1:
        return 0.0
    
    term1 = 0.0
    if i + p < len(knots):
        den1 = knots[i + p] - knots[i]
        if den1 > 0:
            term1 = ((u - knots[i]) / den1) * bspline_basis(u, i, p - 1, knots)
    
    term2 = 0.0
    if i + p + 1 < len(knots):
        den2 = knots[i + p + 1] - knots[i + 1]
        if den2 > 0:
            term2 = ((knots[i + p + 1] - u) / den2) * bspline_basis(u, i + 1, p - 1, knots)
    
    return term1 + term2

def custom_interoperations_green_curve(points, kappas, is_closed=False):
    """Generate smoothed curve using B-spline interpolation.
    Args:
        points: List of [x, y] points to smooth.
        kappas: List of weights for each point.
        is_closed: If True, treat as closed curve (periodic); else open (clamped).
    Returns:
        smooth_x, smooth_y: Arrays of smoothed x and y coordinates.
    """
    points = np.array(points)
    kappas = np.array(kappas)
    degree = 3
    num_output_points = 1000
    
    if is_closed and len(points) > degree:
        n = len(points)
        extended_points = np.concatenate((points[n-degree:], points, points[0:degree]))
        extended_kappas = np.concatenate((kappas[n-degree:], kappas, kappas[0:degree]))
        len_extended = len(extended_points)
        knots = np.linspace(-degree / float(n), 1 + degree / float(n), len_extended + 1)
        
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
        
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
        
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len_extended):
                b = bspline_basis(u, i, degree, knots)
                w = extended_kappas[i] * b
                num_x += w * extended_points[i, 0]
                num_y += w * extended_points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
        
        smooth_x = np.append(smooth_x, smooth_x[0])
        smooth_y = np.append(smooth_y, smooth_y[0])
        
    else:  # Open (clamped) B-spline
        n = len(points)
        knots = np.concatenate(([0] * (degree + 1), np.linspace(0, 1, n - degree + 1)[1:-1], [1] * (degree + 1)))
        
        u_fine = np.linspace(0, 1, num_output_points)
        
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
        
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(n):
                b = bspline_basis(u, i, degree, knots)
                w = kappas[i] * b
                num_x += w * points[i, 0]
                num_y += w * points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
    
    return smooth_x, smooth_y

# Test with flower shape
num_petals = 6
num_u = num_petals * 2  # 12
theta = np.linspace(0, 2 * np.pi, num_u, endpoint=False)
radii = 1.0
amplitude = 0.3
r_base = radii + amplitude * np.sin(num_petals * theta)
x_base_coarse = r_base * np.cos(theta)
y_base_coarse = r_base * np.sin(theta)

boundary_points = list(zip(x_base_coarse, y_base_coarse))
boundary_kappas = [1.0] * len(boundary_points)
smooth_x, smooth_y = custom_interoperations_green_curve(boundary_points, boundary_kappas, is_closed=True)

# Check if closed
print('First and last points match:', np.allclose(smooth_x[0], smooth_x[-1]), np.allclose(smooth_y[0], smooth_y[-1]))

# Plot to visualize
plt.figure()
plt.plot(smooth_x, smooth_y, 'b-')
plt.plot(x_base_coarse, y_base_coarse, 'r--')
plt.scatter(x_base_coarse, y_base_coarse, color='red')
plt.axis('equal')
plt.title('Smoothed Closed Curve with degree 2')
plt.show()

# Output some points to check
print('Smooth X first 5:', smooth_x[:5])
print('Smooth Y first 5:', smooth_y[:5])
print('Smooth X last 5:', smooth_x[-5:])
print('Smooth Y last 5:', smooth_y[-5:])

----- END id_util_nurks_closure.py -----

----- id_util_nurks_closure_hex.py -----
# id_util_nurks_closure_hex.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
import numpy as np
import matplotlib.pyplot as plt

def bspline_basis(u, i, p, knots):
    if p == 0:
        if i < 0 or i + 1 >= len(knots):
            return 0.0
        return 1.0 if knots[i] <= u <= knots[i + 1] else 0.0
    
    if i < 0 or i >= len(knots) - 1:
        return 0.0
    
    term1 = 0.0
    if i + p < len(knots):
        den1 = knots[i + p] - knots[i]
        if den1 > 0:
            term1 = ((u - knots[i]) / den1) * bspline_basis(u, i, p - 1, knots)
    
    term2 = 0.0
    if i + p + 1 < len(knots):
        den2 = knots[i + p + 1] - knots[i + 1]
        if den2 > 0:
            term2 = ((knots[i + p + 1] - u) / den2) * bspline_basis(u, i + 1, p - 1, knots)
    
    return term1 + term2

def custom_interoperations_green_curve(points, kappas, is_closed=False):
    """Generate smoothed curve using B-spline interpolation.
    Args:
        points: List of [x, y] points to smooth.
        kappas: List of weights for each point.
        is_closed: If True, treat as closed curve (periodic); else open (clamped).
    Returns:
        smooth_x, smooth_y: Arrays of smoothed x and y coordinates.
    """
    points = np.array(points)
    kappas = np.array(kappas)
    degree = 3
    num_output_points = 1000
    
    if is_closed and len(points) > degree:
        n = len(points)
        extended_points = np.concatenate((points[n-degree:], points, points[0:degree]))
        extended_kappas = np.concatenate((kappas[n-degree:], kappas, kappas[0:degree]))
        len_extended = len(extended_points)
        knots = np.linspace(-degree / float(n), 1 + degree / float(n), len_extended + 1)
        
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
        
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
        
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len_extended):
                b = bspline_basis(u, i, degree, knots)
                w = extended_kappas[i] * b
                num_x += w * extended_points[i, 0]
                num_y += w * extended_points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
        
        smooth_x = np.append(smooth_x, smooth_x[0])
        smooth_y = np.append(smooth_y, smooth_y[0])
        
    else:  # Open (clamped) B-spline
        n = len(points)
        knots = np.concatenate(([0] * (degree + 1), np.linspace(0, 1, n - degree + 1)[1:-1], [1] * (degree + 1)))
        
        u_fine = np.linspace(0, 1, num_output_points)
        
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
        
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(n):
                b = bspline_basis(u, i, degree, knots)
                w = kappas[i] * b
                num_x += w * points[i, 0]
                num_y += w * points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
    
    return smooth_x, smooth_y

# Test with flower shape - increase num_u
num_petals = 6
num_u = num_petals * 6  # 36 points for better approximation
theta = np.linspace(0, 2 * np.pi, num_u, endpoint=False)
radii = 1.0
amplitude = 0.3
r_base = radii + amplitude * np.sin(num_petals * theta)
x_base_coarse = r_base * np.cos(theta)
y_base_coarse = r_base * np.sin(theta)

boundary_points = list(zip(x_base_coarse, y_base_coarse))
boundary_kappas = [1.0] * len(boundary_points)
smooth_x, smooth_y = custom_interoperations_green_curve(boundary_points, boundary_kappas, is_closed=True)

# Check if closed
print('First and last points match:', np.allclose(smooth_x[0], smooth_x[-1]), np.allclose(smooth_y[0], smooth_y[-1]))

# Plot to visualize
plt.figure()
plt.plot(smooth_x, smooth_y, 'b-')
plt.plot(x_base_coarse, y_base_coarse, 'r--')
plt.scatter(x_base_coarse, y_base_coarse, color='red')
plt.axis('equal')
plt.title('Smoothed Closed Curve with more points')
plt.show()

# Output some points to check
print('Smooth X first 5:', smooth_x[:5])
print('Smooth Y first 5:', smooth_y[:5])
print('Smooth X last 5:', smooth_x[-5:])
print('Smooth Y last 5:', smooth_y[-5:])

----- END id_util_nurks_closure_hex.py -----

----- id_util_nurks_surface.py -----
# id_util_nurks_surface.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import cm
from matplotlib.widgets import Slider
import hashlib
from decimal import Decimal, getcontext
import warnings
from matplotlib import MatplotlibDeprecationWarning
import struct
import base64
# Import mpld3 if available for HTML export
try:
    import mpld3
    MPLD3_AVAILABLE = True
except ImportError:
    print("mpld3 not installed. HTML export will be skipped. Install mpld3 with 'pip install mpld3' to enable.")
    MPLD3_AVAILABLE = False
from temperature_salt import secure_hash_two
from kappawise import kappa_coord
from nurks_surface import bspline_basis, bspline_basis_periodic, custom_interoperations_green_curve
# Set precision for Decimal
getcontext().prec = 28
# Suppress warnings
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)
# A3 landscape dimensions (normalized: width long side, height short side)
WIDTH = 420 / 297 # A3 landscape: 420mm width, 297mm height, normalized height=1.0
HEIGHT = 1.0
PURPLE_LINES = [1/3, 2/3] # Dividers on the width
unit_per_mm = 1.0 / 297 # Normalize to A3 short side
scale_label = f"Scale: 1mm = {unit_per_mm:.5f} units (A3 short side = 297mm)"
# Dreyfuss human factors: Optimal eye distance ~20 inches (508mm)
EYE_DISTANCE = 500 * unit_per_mm # Normalized eye distance to viewport
HORIZON_HEIGHT = HEIGHT * 0.5 # Default horizon line at half height
EYE_LINE = HORIZON_HEIGHT # Eye line coincides with horizon
# Golden spiral parameters
PHI = (1 + np.sqrt(5)) / 2
kappa = 1 / PHI
A_SPIRAL = 0.001 # Scaled down slightly from 0.01 to fit better
B_SPIRAL = np.log(PHI) / (np.pi / 2)
# Define κθπ for the green segment
theta_max = kappa * np.pi**2 / PHI
# Compute the full spiral
theta_full = np.linspace(0, 10 * np.pi, 1000)
r_full = A_SPIRAL * np.exp(B_SPIRAL * theta_full)
x_full = r_full * np.cos(theta_full)
y_full = r_full * np.sin(theta_full)
# Compute the green segment (θ from π to 2π)
theta_green = np.linspace(np.pi, 2 * np.pi, 200)
r_green = A_SPIRAL * np.exp(B_SPIRAL * theta_green)
x_green = r_green * np.cos(theta_green)
y_green = r_green * np.sin(theta_green)
# Compute the chord and shift
x1, y1 = x_green[0], y_green[0]
x2, y2 = x_green[-1], y_green[-1]
chord_length = np.abs(x2 - x1)
# Shift so the segment starts at x=0
x_green_shifted = x_green - x1
x_green_final = x_green_shifted
# Scale to match the target chord length (between purple lines)
target_chord = PURPLE_LINES[1] - PURPLE_LINES[0]
scale_factor = target_chord / chord_length if chord_length != 0 else 1.0
x_green_scaled = x_green_final * scale_factor
y_green_scaled = y_green * scale_factor
# Shift to start at the first purple line
x_green_final = x_green_scaled + PURPLE_LINES[0]
# Compute κ at 2πR for the green segment
r_max = A_SPIRAL * np.exp(B_SPIRAL * theta_max)
two_pi_r = 2 * np.pi * r_max
kappa_at_2piR = two_pi_r / PHI
# Define the 52 Mersenne prime exponents (updated with the latest known as of 2025)
mersenne_exponents = [
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
    3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
    110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
    6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
    37156667, 42643801, 43112609, 57885161, 74207281, 77232917, 82589933,
    136279841 # Latest known Mersenne prime exponent as of 2025 (52nd)
]
# Map exponents to x-positions (0 to width)
min_exponent = 2
max_exponent_at_x1 = 1_100_000_000
exponent_range_per_x = (max_exponent_at_x1 - min_exponent) / 1.0
x_positions = [(exponent - min_exponent) / exponent_range_per_x * WIDTH for exponent in mersenne_exponents] # Scale to full WIDTH
# Create the 52 curves data
curves = []
curve_lines = []
colors = plt.cm.viridis(np.linspace(0, 1, len(mersenne_exponents)))
for i, (exponent, x_pos) in enumerate(zip(mersenne_exponents, x_positions)):
    scale = x_pos / chord_length if chord_length != 0 else 1.0
    x_new = x_green * scale
    y_new = y_green * scale
    x_new_shifted = x_new - x_new[0]
    curves.append((x_new_shifted, y_new, f"M{exponent}"))
    curve_lines.append(None)
# A4 short edge divisions (110 parts, scaled to first part of WIDTH)
division_step = WIDTH / 2 / 110 # Assume first half is A4-like
division_positions = np.arange(0, WIDTH / 2 + division_step, division_step)
# Scale key for the title
scale_key_positions = division_positions[::10] / (WIDTH / 2) # Normalize to 0-1 for first half
scale_key_exponents = [int(2 + (1_100_000_000 - 2) * x) for x in scale_key_positions]
scale_key_text = "Scale (x=0 to WIDTH/2): " + ", ".join([f"{x:.2f}: {exp:,}" for x, exp in zip(scale_key_positions, scale_key_exponents)])
# Flags for Mersenne primes
flag_length = 0.5
start_y = -0.1
wedge_angles = np.linspace(90, 360, len(curves))
flag_positions = []
annotation_objects = []
harmonic_frequencies = []
circle_markers = []
min_exp = min(mersenne_exponents)
max_exp = max(mersenne_exponents)
log_min = np.log(min_exp)
log_max = np.log(max_exp)
min_freq_exp = -4.459
max_freq_exp = 5.506
exponent_range = max_freq_exp - min_freq_exp
log_range = log_max - log_min
for i, (x_new, y_new, label) in enumerate(curves):
    x_end = x_new[-1]
    y_end = y_new[-1]
    x_start = x_end
    y_start = start_y
    angle = np.deg2rad(wedge_angles[i])
    x_flag = x_start + flag_length * np.cos(angle)
    y_flag = y_start + flag_length * np.sin(angle)
    exponent = mersenne_exponents[i]
    scaled_exponent = min_freq_exp + (np.log(exponent) - log_min) / log_range * exponent_range
    freq = 440 * 2**scaled_exponent
    harmonic_frequencies.append(freq)
    flag_positions.append((x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq))
    angle_deg = wedge_angles[i]
    if (angle_deg - 90) % 5 == 0:
        angle_rad = np.deg2rad(angle_deg)
        x_marker = x_start + (flag_length * 0.5) * np.cos(angle_rad)
        y_marker = y_start + (flag_length * 0.5) * np.sin(angle_rad)
        circle_markers.append((x_marker, y_marker))
# Global variables for interactive modes
protractor_active = False
ruler_active = False
draw_mode = False
dimension_active = False
pro_mode = False
is_closed = False
selected_curve = None
hidden_elements = []
protractor_points = []
protractor_line = None
protractor_text = None
ruler_points = []
ruler_line = None
ruler_text = None
dimension_labels = []
drawing_points = [] # Kappa nodes (first endpoint of each greenchord)
kappas = [] # Kappa values at each node
node_scatter = [] # List of scatter objects for kappa nodes
original_colors = [] # List to store original colors of nodes
selected_node_index = -1
dragging = False
ghost_handles = [] # List for theta ghost handles
green_curve_line = None # Single plot object for the interoperated greencurve
CLOSE_THRESHOLD = 0.05 # Distance to first point to consider closing
SNAP_THRESHOLD = 0.05 # Threshold for snapping to dividers (UX improvement)
vanishing_points = [] # Vanishing points for each triangulation
previous_kappa = 1.0 # Initial kappa for decay
curvature = 1.0 # Initial curvature (kappa)
height = 0.5 # Initial height for 3D model
num_rings = 20 # Number of loft rings
fractal_level = 3 # Fractal level for flowers
radial_chord = 0.5 # Radial chord for flower
tangential_chord = 0.2 # Tangential chord for flower
height_chord = 0.1 # Height chord for flower
current_vertices = None
current_faces = None
last_angle = 0.0 # Last measured angle from protractor
show_harmonics = False
harmonic_texts = []
annotation_objects = []
# Pre-compute kappa grid
kappa_grid = compute_kappa_grid(grid_size=100)
# Fractal Flower Mesh with guide curves using diameter logic
def fractal_flower(center, scale, level, all_polygons, all_guide_curves, rotation_angle=0.0):
    """
    Recursively generates flower-shaped polygons for the surface.
    Collects all base-level flower polygons in all_polygons (list of list of [x,y,z]).
    Uses 36 points for better flower resolution with curved petals.
    Applies rotation to the points.
    Adds guide curves from petal to petal control points using diameter logic (connecting opposite petals).
    Args:
        center: [x, y, z] center of the flower.
        scale: Scale factor for the flower size.
        level: Current recursion depth.
        all_polygons: List to collect all base flower polygons.
        all_guide_curves: List to collect guide curves (list of [p1, p2] pairs for lines).
        rotation_angle: Rotation angle in radians for the flower.
    """
    rot_cos = np.cos(rotation_angle)
    rot_sin = np.sin(rotation_angle)
    num_points = 37 # 36 points for higher resolution
    t = np.linspace(0, 2 * np.pi, num_points)[:-1]
    r = scale * (radial_chord + tangential_chord * np.sin(6 * t)) # 6 petals, use sin for symmetry if needed
    dx = r * np.cos(t)
    dy = r * np.sin(t)
    dz = scale * height_chord * np.cos(6 * t) # Curved z for surface
    # Apply rotation to dx, dy (around z)
    x_rot = center[0] + dx * rot_cos - dy * rot_sin
    y_rot = center[1] + dx * rot_sin + dy * rot_cos
    z_rot = center[2] + dz
    polygon = [[x_rot[j], y_rot[j], z_rot[j]] for j in range(len(t))]
    all_polygons.append(polygon)
    # Add guide curves using diameter logic (connect opposite points for each petal pair)
    num_petals = 6
    points_per_petal = len(t) // num_petals
    for p in range(num_petals // 2): # Pair opposite petals (0-3, 1-4, 2-5)
        petal1_start = p * points_per_petal
        petal2_start = (p + num_petals // 2) * points_per_petal
        # Take midpoint control points of each petal
        petal1_mid = petal1_start + points_per_petal // 2
        petal2_mid = petal2_start + points_per_petal // 2
        p1 = polygon[petal1_mid]
        p2 = polygon[petal2_mid]
        all_guide_curves.append([p1, p2]) # Add line between control points
    if level == 0:
        return
    # Add smaller flowers at petal tips
    small_scale = scale / PHI # Golden ratio scale
    for i in range(6):
        theta = i * (2 * np.pi / 6)
        tip_r = scale * (radial_chord + tangential_chord) # Max r for tip
        tip_dx = tip_r * np.cos(theta)
        tip_dy = tip_r * np.sin(theta)
        tip_dz = scale * height_chord
        # Rotate tip offset
        tip_x = center[0] + tip_dx * rot_cos - tip_dy * rot_sin
        tip_y = center[1] + tip_dx * rot_sin + tip_dy * rot_cos
        tip_z = center[2] + tip_dz
        tip_center = [tip_x, tip_y, tip_z]
        fractal_flower(tip_center, small_scale, level - 1, all_polygons, all_guide_curves, rotation_angle + np.pi)
# Triangulate polygon for rendering (fan triangulation)
def triangulate_poly(poly):
    tris = []
    for i in range(1, len(poly) - 1):
        tris.append([poly[0], poly[i], poly[i+1]])
    return tris
# Hash entropy for lower surface
def hash_entropy(p):
    h_str = f"{p[0]:.6f}{p[1]:.6f}{p[2]:.6f}"
    h = int(hashlib.sha256(h_str.encode()).hexdigest(), 16) % 1000 / 1000.0 * 0.05 - 0.025
    return h
# Build mesh using fractal flower (ties to curve by scaling to curve length)
def build_mesh(x_curve, y_curve, z_curve=None, height=0.5, num_rings=20, num_points=None, fractal_level=3):
    """
    Builds two surfaces meeting at the 3D curve with vertical tangent, inheriting each other's curvature in transition.
    Integrates fractal flower for complex surface detail on caps, scaled by curve length.
    Uses flower modulation in loft rings for interlacing petals.
    Now collects guide curves from petal to petal and adds them as edges in the mesh.
    Args:
        x_curve, y_curve, z_curve: Curve coordinates.
        height: Height for lofting.
        num_rings: Number of rings for loft.
        num_points: Number of points to sample curve.
        fractal_level: Recursion level for fractal flower.
    Returns:
        vertices (np.array): Array of [x, y, z].
        faces (list): List of [idx1, idx2, idx3].
    """
    if num_points is not None:
        indices = np.linspace(0, len(x_curve) - 1, num_points, dtype=int)
        x_curve = x_curve[indices]
        y_curve = y_curve[indices]
        if z_curve is not None:
            z_curve = z_curve[indices]
    n = len(x_curve)
    if z_curve is None:
        z_curve = np.zeros(n) # Default to flat if no z provided
    # Use node 2 as datum when closed
    center_x = drawing_points[1][0] if is_closed and len(drawing_points) > 1 else drawing_points[0][0] if drawing_points else np.mean(x_curve)
    center_y = drawing_points[1][1] if is_closed and len(drawing_points) > 1 else drawing_points[0][1] if drawing_points else np.mean(y_curve)
    vertices = []
    faces = []
    # Parting line on 3D curve
    parting_base = len(vertices)
    for i in range(n):
        vertices.append([x_curve[i], y_curve[i], z_curve[i]])
    # Upper surface: rings inward with vertical tangent at edge and flower modulation
    upper_bases = [parting_base]
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2 # Vertical tangent at s=0 (dr/ds=0)
        g_val = (height / 2) * s**2 # Quadratic for constant curvature
        base = len(vertices)
        upper_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = 0.0 # Upper phase
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s # Modulation increases inward
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) + g_val + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_upper_idx = len(vertices)
    vertices.append([center_x, center_y, height / 2])
    # Lower surface: mirrored with phase offset for interlacing and entropy
    lower_bases = [parting_base] # Shared edge
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2
        g_val = (height / 2) * s**2 # Quadratic for constant curvature (sign same for inheritance magnitude)
        base = len(vertices)
        lower_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = np.pi / 6 # Lower phase offset for interlacing
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) - g_val + hash_entropy([x, y, z]) + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_lower_idx = len(vertices)
    vertices.append([center_x, center_y, -height / 2])
    # Faces for upper surface
    for ll in range(len(upper_bases) - 1):
        base = upper_bases[ll]
        next_base = upper_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, base + next_i, next_base + next_i])
            faces.append([base + i, next_base + next_i, next_base + i])
    # Faces for lower surface
    for ll in range(len(lower_bases) - 1):
        base = lower_bases[ll]
        next_base = lower_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, next_base + i, next_base + next_i])
            faces.append([base + i, next_base + next_i, base + next_i])
    # Integrate fractal flower for caps (no fan, use flower fractals)
    # Compute curve length for scale
    curve_length = np.sum(np.sqrt(np.diff(x_curve)**2 + np.diff(y_curve)**2))
    flower_scale = curve_length * 0.1 if curve_length > 0 else 0.5 # Scale to curve
    all_polygons = [] # List of list of [x,y,z] for each polygon
    all_guide_curves = [] # New: Collect guide curve pairs
    # Upper cap flower
    fractal_flower(vertices[center_upper_idx], flower_scale, fractal_level, all_polygons, all_guide_curves, rotation_angle=np.pi)
    # Lower cap flower
    fractal_flower(vertices[center_lower_idx], flower_scale, fractal_level, all_polygons, all_guide_curves, rotation_angle=np.pi)
    # Add polygons to mesh (triangulate for rendering)
    for poly in all_polygons:
        base_idx = len(vertices)
        vertices.extend(poly)
        for tri in triangulate_poly(range(len(poly))):
            faces.append([base_idx + tri[0], base_idx + tri[1], base_idx + tri[2]])
    # Add guide curves as edges (simple lines, add as degenerate faces or separate for visualization)
    for guide in all_guide_curves:
        base_idx = len(vertices)
        vertices.append(guide[0])
        vertices.append(guide[1])
        faces.append([base_idx, base_idx + 1, base_idx + 1]) # Degenerate tri for line (visual only)
    # Convert to numpy array
    vertices = np.array(vertices)
    # Snap to integers if hash ends with 0
    for i in range(len(vertices)):
        v = vertices[i]
        h_str = f"{v[0]:.6f}{v[1]:.6f}{v[2]:.4f}"
        h = hashlib.sha256(h_str.encode()).hexdigest()[-1]
        if h == '0':
            vertices[i] = np.round(vertices[i])
    # Add compound curvature modulation with angle and 3D kappa grid for smooth orthographic projections
    grid_size, _, num_angles = kappa_grid.shape
    angle_idx = int((last_angle / 360) * num_angles) % num_angles
    kappa_slice = kappa_grid[:, :, angle_idx]
    # Normalize vertices to -1 to 1 for grid mapping (assuming curve bounds approx [0, WIDTH] x [0, HEIGHT])
    max_dim = max(np.max(np.abs(vertices[:, 0])), np.max(np.abs(vertices[:, 1])))
    norm_x = np.clip(((vertices[:, 0] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    norm_y = np.clip(((vertices[:, 1] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    kappa_mod = kappa_slice[norm_y, norm_x]
    vertices[:, 2] += kappa_mod * 0.1 # Scale z modulation
    vertices[:, 0] += kappa_mod * 0.05 * np.sin(2 * np.pi * vertices[:, 2] / height) # Compound in x
    vertices[:, 1] += kappa_mod * 0.05 * np.cos(2 * np.pi * vertices[:, 2] / height) # Compound in y
    # Make flowers sacrificial: remove flower faces after modulation (assume last added are flowers)
    flower_face_start = len(faces) - len(all_polygons) * 35 # Adjusted for 36 points per flower (approx 35 triangles)
    faces = faces[:flower_face_start]
    return vertices, faces
# NURBS basis function
def nurbs_basis(u, i, p, knots):
    if p == 0:
        return 1.0 if knots[i] <= u <= knots[i+1] else 0.0 # Include = for end
    if knots[i+p] == knots[i]:
        c1 = 0.0
    else:
        c1 = (u - knots[i]) / (knots[i+p] - knots[i]) * nurbs_basis(u, i, p-1, knots)
    if knots[i+p+1] == knots[i+1]:
        c2 = 0.0
    else:
        c2 = (knots[i+p+1] - u) / (knots[i+p+1] - knots[i+1]) * nurbs_basis(u, i+1, p-1, knots)
    return c1 + c2
# Compute NURBS curve point
def nurbs_curve_point(u, control_points, weights, p, knots):
    n = len(control_points) - 1
    x = 0.0
    y = 0.0
    denom = 0.0
    for i in range(n + 1):
        b = nurbs_basis(u, i, p, knots)
        denom += b * weights[i]
        x += b * weights[i] * control_points[i][0]
        y += b * weights[i] * control_points[i][1]
    if denom == 0:
        return 0, 0
    return x / denom, y / denom
# Generate NURBS curve
def generate_nurbs_curve(points, weights, p, knots, num_points=1000):
    u_min, u_max = knots[p], knots[-p-1]
    u_values = np.linspace(u_min, u_max, num_points, endpoint=False)
    curve = [nurbs_curve_point(u, points, weights, p, knots) for u in u_values]
    curve.append(curve[0]) # Append first point for exact closure
    return np.array([list(pt) for pt in curve]) # Convert to np.array of shape (num_points+1, 2)
# Compute golden spiral
def compute_golden_spiral():
    theta = np.linspace(0, 10 * np.pi, 1000)
    r = A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Scale down to fit within page bounds
    scale_factor = min(WIDTH, HEIGHT) / (2 * np.max(np.abs([x, y]))) * 0.8 # 80% of max to fit comfortably
    x *= scale_factor
    y *= scale_factor
    return x, y
def bspline_basis(u, i, p, knots):
    if p == 0:
        if i < 0 or i + 1 >= len(knots):
            return 0.0
        return 1.0 if knots[i] <= u <= knots[i + 1] else 0.0
  
    if i < 0 or i >= len(knots) - 1:
        return 0.0
  
    term1 = 0.0
    if i + p < len(knots):
        den1 = knots[i + p] - knots[i]
        if den1 > 0:
            term1 = ((u - knots[i]) / den1) * bspline_basis(u, i, p - 1, knots)
  
    term2 = 0.0
    if i + p + 1 < len(knots):
        den2 = knots[i + p + 1] - knots[i + 1]
        if den2 > 0:
            term2 = ((knots[i + p + 1] - u) / den2) * bspline_basis(u, i + 1, p - 1, knots)
  
    return term1 + term2
def bspline_basis_periodic(u, i, p, knots, n):
    i = i % n
    if p == 0:
        k0 = knots[i % len(knots)]
        k1 = knots[(i + 1) % len(knots)]
        if k0 > k1:  # Wrap-around interval
            return 1.0 if u >= k0 or u < k1 else 0.0
        else:
            return 1.0 if k0 <= u < k1 else 0.0
    k_i = knots[i % len(knots)]
    k_ip = knots[(i + p) % len(knots)]
    den1 = k_ip - k_i
    if den1 < 0:
        den1 += 1.0  # Adjust for wrap-around
    term1 = 0.0
    if den1 > 0:
        term1 = ((u - k_i) / den1) * bspline_basis_periodic(u, i, p - 1, knots, n)
    k_i1 = knots[(i + 1) % len(knots)]
    k_ip1 = knots[(i + p + 1) % len(knots)]
    den2 = k_ip1 - k_i1
    if den2 < 0:
        den2 += 1.0  # Adjust for wrap-around
    term2 = 0.0
    if den2 > 0:
        term2 = ((k_ip1 - u) / den2) * bspline_basis_periodic(u, i + 1, p - 1, knots, n)
    return term1 + term2
# Custom interoperations for greencurve using NURBS with local kappa adjustment for closure
def custom_interoperations_green_curve(points, kappas, is_closed=False):
    """
    Custom Non-Uniform Rational Kappa Spline (NURKS) approximation for green curve with closure adjustments.
    For closed curves, extends control points on both sides and shifts knot vector for smooth periodicity.
    """
    points = np.array(points)
    kappas = np.array(kappas)
    degree = 3 # Fixed degree for continuity
    num_output_points = 1000
  
    if is_closed and len(points) > degree:
        n = len(points)
        extended_points = np.concatenate((points[n-degree:], points, points[0:degree]))
        extended_kappas = np.concatenate((kappas[n-degree:], kappas, kappas[0:degree]))
        len_extended = len(extended_points)
        knots = np.linspace(-degree / float(n), 1 + degree / float(n), len_extended + 1)
  
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
  
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
  
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len_extended):
                b = bspline_basis(u, i, degree, knots)
                w = extended_kappas[i] * b
                num_x += w * extended_points[i, 0]
                num_y += w * extended_points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
  
        smooth_x = np.append(smooth_x, smooth_x[0])
        smooth_y = np.append(smooth_y, smooth_y[0])
  
    else:
        # Cumsum of distances for open
        t = np.cumsum([0] + [np.linalg.norm(points[i+1] - points[i]) for i in range(len(points)-1)])
        knots = np.concatenate(([0] * (degree + 1), t / t[-1] if t[-1] > 0 else np.linspace(0, 1, len(t)), [1] * (degree)))
  
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
  
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
  
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len(points)):
                b = bspline_basis(u, i, degree, knots)
                w = kappas[i] * b if i < len(kappas) else kappas[-1] * b
                num_x += w * points[i, 0]
                num_y += w * points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
  
    return smooth_x, smooth_y
# Compute kappa for a segment, second endpoint influences next kappa
def compute_segment_kappa(p1, p2, base_kappa=1.0, prev_kappa=1.0):
    x1, y1 = p1
    x2, y2 = p2
    theta = np.sqrt((x2 - x1)**2 + (y2 - y1)**2) # Theta is distance
    if theta < 1e-10:
        return prev_kappa
    decay_factor = np.exp(-theta / WIDTH / 20.0) # Further reduced decay rate
    return prev_kappa * decay_factor * base_kappa
# Recalculate kappas after changes (e.g., closure or node move) for consistency
def recalculate_kappas():
    global previous_kappa
    previous_kappa = kappas[0] # Start with first kappa
    for i in range(1, len(drawing_points)):
        kappas[i] = compute_segment_kappa(drawing_points[i-1], drawing_points[i], curvature, previous_kappa)
        previous_kappa = kappas[i]
# Update 3D model on changes (e.g., height slider or curve update)
def update_3d_model():
    global current_vertices, current_faces
    if green_curve_line:
        x_curve, y_curve = green_curve_line.get_data()
        if is_closed and np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)), height=height)
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
# Golden window calculation
def compute_golden_window(x_spiral, y_spiral):
    idx_crossings = np.where(np.diff(np.sign(x_spiral - PURPLE_LINES[0] * WIDTH)))[0]
    if len(idx_crossings) >= 2:
        y1 = y_spiral[idx_crossings[0]]
        y2 = y_spiral[idx_crossings[1]]
        return np.abs(y2 - y1), min(y1, y2), max(y1, y2)
    return 0, 0, 0
# Compute vanishing point for a triangulation
def compute_vanishing_point(tri_points, eye_distance=EYE_DISTANCE):
    mid_x = np.mean([p[0] for p in tri_points])
    mid_y = np.mean([p[1] for p in tri_points])
    vx = mid_x
    vy = HORIZON_HEIGHT + eye_distance * (mid_y - EYE_LINE) / WIDTH
    return vx, vy
# Redraw green curve
def redraw_green_curve(is_closed=False):
    global green_curve_line
    if green_curve_line:
        green_curve_line.remove()
        green_curve_line = None
    if len(drawing_points) >= 2:
        adjusted_kappas = kappas.copy()
        if is_closed and len(adjusted_kappas) > 1:
            adjusted_kappas[1] = 1.5 * adjusted_kappas[1] # Local kappa adjustment for ellipse conditions
        x_green, y_green = custom_interoperations_green_curve(drawing_points, adjusted_kappas, is_closed=is_closed)
        green_curve_line, = ax_2d.plot(x_green, y_green, 'g-', label='Green Curve' if green_curve_line is None else None)
    fig_2d.canvas.draw()
# Setup figures
fig_2d = plt.figure(figsize=(14, 8))
ax_2d = fig_2d.add_subplot(111)
fig_3d = plt.figure(figsize=(10, 6))
ax_3d = fig_3d.add_subplot(111, projection='3d')
fig_controls = plt.figure(figsize=(4, 8))
ax_curvature = fig_controls.add_axes([0.2, 0.8, 0.6, 0.03])
curvature_slider = Slider(ax_curvature, 'Curvature (kappa)', 0.1, 2.0, valinit=curvature)
ax_height = fig_controls.add_axes([0.2, 0.7, 0.6, 0.03])
height_slider = Slider(ax_height, 'Height', 0.1, 2.0, valinit=height)
ax_rings = fig_controls.add_axes([0.2, 0.6, 0.6, 0.03])
rings_slider = Slider(ax_rings, 'Rings', 5, 50, valinit=num_rings, valstep=1)
ax_level = fig_controls.add_axes([0.2, 0.5, 0.6, 0.03])
level_slider = Slider(ax_level, 'Fractal Level', 0, 5, valinit=fractal_level, valstep=1)
ax_radial = fig_controls.add_axes([0.2, 0.4, 0.6, 0.03])
radial_slider = Slider(ax_radial, 'Radial Chord', 0.1, 1.0, valinit=radial_chord)
ax_tangential = fig_controls.add_axes([0.2, 0.3, 0.6, 0.03])
tangential_slider = Slider(ax_tangential, 'Tangential Chord', 0.0, 0.5, valinit=tangential_chord)
ax_height_chord = fig_controls.add_axes([0.2, 0.2, 0.6, 0.03])
height_chord_slider = Slider(ax_height_chord, 'Height Chord', 0.0, 0.5, valinit=height_chord)
# Plot A3 page
ax_2d.plot([0, WIDTH, WIDTH, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k-', label='A3 Landscape Page')
for x in PURPLE_LINES:
    ax_2d.plot([x * WIDTH, x * WIDTH], [0, HEIGHT], 'm-', label='Purple Dividers' if x == PURPLE_LINES[0] else None)
# Horizon line
horizon_line, = ax_2d.plot([0, WIDTH], [HORIZON_HEIGHT, HORIZON_HEIGHT], 'b:', label='Horizon/Eye Line')
# Golden spiral
x_spiral, y_spiral = compute_golden_spiral()
golden_spiral, = ax_2d.plot(x_spiral + WIDTH/2, y_spiral + HEIGHT/2, 'gold', label='Golden Spiral')
# Golden window
golden_window, y_min, y_max = compute_golden_window(x_spiral + WIDTH/2, y_spiral + HEIGHT/2)
ax_2d.fill_between([PURPLE_LINES[0] * WIDTH - 0.05, PURPLE_LINES[0] * WIDTH + 0.05], y_min, y_max, color='yellow', alpha=0.5, label='Golden Window')
# Ghost curve init
ghost_curve, = ax_2d.plot([], [], 'g--', label='Ghost Curve Preview')
# Control indicators in legend
ax_2d.plot([], [], ' ', label='R: Toggle draw mode')
ax_2d.plot([], [], 'b--', label='A: Toggle protractor')
ax_2d.plot([], [], 'c-', label='M: Toggle measure (ruler)')
ax_2d.plot([], [], ' ', label='D: Toggle dimension')
ax_2d.plot([], [], 'r-', label='C: Close polyhedron (manual)')
ax_2d.plot([], [], ' ', label='Click near first point to close')
ax_2d.plot([], [], ' ', label='Click to select curve')
ax_2d.plot([], [], ' ', label='G: To construction geom')
ax_2d.plot([], [], ' ', label='H: Hide/show')
ax_2d.plot([], [], ' ', label='E: Reset canvas')
ax_2d.plot([], [], ' ', label='S: Export STL')
ax_2d.plot([], [], 'k-', label='Curvature Slider (Controls window)')
# Update curvature
def update_curvature(val):
    global curvature
    curvature = val
    if len(drawing_points) >= 1:
        kappas[-1] = curvature
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
    fig_2d.canvas.draw()
curvature_slider.on_changed(update_curvature)
# Update height
def update_height(val):
    global height
    height = val
    if is_closed:
        update_3d_model()
height_slider.on_changed(update_height)
# Update rings
def update_rings(val):
    global num_rings
    num_rings = int(val)
    if is_closed:
        update_3d_model()
rings_slider.on_changed(update_rings)
# Update fractal level
def update_level(val):
    global fractal_level
    fractal_level = int(val)
    if is_closed:
        update_3d_model()
level_slider.on_changed(update_level)
# Update radial chord
def update_radial(val):
    global radial_chord
    radial_chord = val
    if is_closed:
        update_3d_model()
radial_slider.on_changed(update_radial)
# Update tangential chord
def update_tangential(val):
    global tangential_chord
    tangential_chord = val
    if is_closed:
        update_3d_model()
tangential_slider.on_changed(update_tangential)
# Update height chord
def update_height_chord(val):
    global height_chord
    height_chord = val
    if is_closed:
        update_3d_model()
height_chord_slider.on_changed(update_height_chord)
# Toggle draw mode
def toggle_draw(event):
    global draw_mode
    if event.key == 'r':
        draw_mode = not draw_mode
        print(f"Draw mode {'enabled' if draw_mode else 'disabled'}")
        fig_2d.canvas.draw()
# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        if not protractor_active:
            if protractor_line:
                protractor_line.remove()
                protractor_line = None
            if protractor_text:
                protractor_text.remove()
                protractor_text = None
            protractor_points.clear()
        fig_2d.canvas.draw()
# On click for protractor
def on_click_protractor(event):
    global protractor_line, protractor_text, last_angle
    if protractor_active and event.inaxes == ax_2d and event.button == 1:
        protractor_points.append((event.xdata, event.ydata))
        if len(protractor_points) == 2:
            x1, y1 = protractor_points[0]
            x2, y2 = protractor_points[1]
            if protractor_line:
                protractor_line.remove()
            protractor_line, = ax_2d.plot([x1, x2], [y1, y2], 'b--')
            dx = x2 - x1
            dy = y2 - y1
            angle = np.arctan2(dy, dx) * 180 / np.pi
            last_angle = angle
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if protractor_text:
                protractor_text.remove()
            protractor_text = ax_2d.text(mid_x, mid_y, f'Angle: {angle:.2f}°', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            protractor_points.clear()
            fig_2d.canvas.draw()
# Toggle ruler (measure)
def toggle_ruler(event):
    global ruler_active
    if event.key == 'm':
        ruler_active = not ruler_active
        print(f"Measure (ruler) tool {'enabled' if ruler_active else 'disabled'}")
        if not ruler_active:
            if ruler_line:
                ruler_line.remove()
                ruler_line = None
            if ruler_text:
                ruler_text.remove()
                ruler_text = None
            ruler_points.clear()
        fig_2d.canvas.draw()
# On click for ruler
def on_click_ruler(event):
    global ruler_line, ruler_text
    if ruler_active and event.inaxes == ax_2d and event.button == 1:
        ruler_points.append((event.xdata, event.ydata))
        if len(ruler_points) == 2:
            x1, y1 = ruler_points[0]
            x2, y2 = ruler_points[1]
            if ruler_line:
                ruler_line.remove()
            ruler_line, = ax_2d.plot([x1, x2], [y1, y2], 'c-')
            dx = x2 - x1
            dy = y2 - y1
            dist = np.sqrt(dx**2 + dy**2)
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if ruler_text:
                ruler_text.remove()
            ruler_text = ax_2d.text(mid_x, mid_y, f'Dist: {dist:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            ruler_points.clear()
            fig_2d.canvas.draw()
# Toggle dimension
def toggle_dimension(event):
    global dimension_active
    if event.key == 'd':
        dimension_active = not dimension_active
        print(f"Dimension tool {'enabled' if dimension_active else 'disabled'}")
        fig_2d.canvas.draw()
# On click for dimension
def on_click_dimension(event):
    if dimension_active and event.inaxes == ax_2d and event.button == 1:
        if ruler_active and ruler_text:
            dimension_labels.append(ruler_text)
        elif selected_curve:
            x, y = selected_curve.get_data()
            length = np.sum(np.sqrt(np.diff(x)**2 + np.diff(y)**2))
            mid_x = np.mean(x)
            mid_y = np.mean(y)
            dim_text = ax_2d.text(mid_x, mid_y + 0.05, f'Len: {length:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            dimension_labels.append(dim_text)
        fig_2d.canvas.draw()
# Toggle pro mode (lock/unlock)
def toggle_pro_mode(event):
    global pro_mode
    if event.key == 'x':
        pro_mode = not pro_mode
        print(f"Pro mode {'locked' if pro_mode else 'unlocked'}")
        fig_2d.canvas.draw()
# On pick event for nodes
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow') # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()
# Show ghost handles (theta points, midpoints between nodes)
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow') # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()
# Show ghost handles (theta points, midpoints between nodes)
def show_ghost_handles():
    global ghost_handles
    for handle in ghost_handles:
        handle.remove()
    ghost_handles = []
    num_points = len(drawing_points) if not is_closed else len(drawing_points) - 1 # Avoid double midpoint on close
    for i in range(num_points):
        next_i = (i + 1) % len(drawing_points) if is_closed else i + 1
        if next_i >= len(drawing_points):
            continue
        mid_x = (drawing_points[i][0] + drawing_points[next_i][0]) / 2
        mid_y = (drawing_points[i][1] + drawing_points[next_i][1]) / 2
        handle = ax_2d.scatter(mid_x, mid_y, color='yellow', s=30, marker='o')
        ghost_handles.append(handle)
    fig_2d.canvas.draw()
# On button press for dragging
def on_button_press(event):
    global dragging
    if pro_mode and selected_node_index != -1 and event.inaxes == ax_2d and event.button == 1:
        dragging = True
# On button release for dragging
def on_button_release(event):
    global dragging
    dragging = False
# On motion for dragging and preview
def on_motion(event):
    global previous_kappa, dragging, selected_node_index
    if dragging and pro_mode and selected_node_index != -1 and event.inaxes == ax_2d:
        drawing_points[selected_node_index] = (event.xdata, event.ydata)
        node_scatter[selected_node_index].set_offsets([[event.xdata, event.ydata]])
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
        fig_2d.canvas.draw()
        return
    if draw_mode and len(drawing_points) > 0 and event.inaxes == ax_2d and not (protractor_active or ruler_active or dimension_active):
        x, y = event.xdata, event.ydata
        preview_points = drawing_points + [(x, y)]
        preview_kappas = kappas + [curvature]
        close_preview = False
        if len(preview_points) > 2:
            dx_first = x - drawing_points[0][0]
            dy_first = y - drawing_points[0][1]
            dist_first = np.sqrt(dx_first**2 + dy_first**2)
            if dist_first < CLOSE_THRESHOLD:
                preview_points[-1] = drawing_points[0]
                preview_kappas[-1] = curvature
                # Preview kappa1 adjustment for closure
                last_theta = np.sqrt((drawing_points[-1][0] - preview_points[-1][0])**2 + (drawing_points[-1][1] - preview_points[-1][1])**2)
                if last_theta < 1e-10: # Manage '0' snap error in preview
                    last_theta = 1e-10
                decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                preview_kappas[0] = preview_kappas[-1] * decay_factor * curvature
                close_preview = True
        # Compute kappa for preview segment (cursor at theta)
        if len(preview_points) > 1:
            preview_kappa = compute_segment_kappa(preview_points[-2], preview_points[-1], curvature, previous_kappa)
            preview_kappas[-1] = preview_kappa
        x_ghost, y_ghost = custom_interoperations_green_curve(preview_points, preview_kappas, is_closed=close_preview)
        ghost_curve.set_data(x_ghost, y_ghost)
        fig_2d.canvas.draw()
# Generate G-code for the curve with variable speeds (for 2D plotting/CNC, scaled to mm)
def generate_gcode(x, y, speeds, scale=297):
    """
    Generates simple G-code for linear moves along the curve with variable feedrates.
    Args:
        x (array): X coordinates (normalized).
        y (array): Y coordinates (normalized).
        speeds (list): Normalized speeds (0-1) for each point.
        scale (float): Scale factor to convert normalized units to mm (based on A3 height=297mm).
    Returns:
        str: G-code string.
    """
    gcode = "G21 ; Set units to millimeters\n"
    gcode += "G90 ; Absolute positioning\n"
    # Move to start position (rapid)
    gcode += f"G0 X{x[0] * scale:.2f} Y{y[0] * scale:.2f}\n"
    # Linear moves with varying feedrate
    for i in range(1, len(x)):
        feedrate = speeds[i] * 900 + 100 # Scale speed to 100-1000 mm/min
        gcode += f"G1 X{x[i] * scale:.2f} Y{y[i] * scale:.2f} F{feedrate:.0f}\n"
    return gcode
# Drawing mode: Add kappa nodes and update continuous greencurve
def on_click_draw(event):
    global green_curve_line, selected_curve, previous_kappa, vanishing_points, current_vertices, current_faces, is_closed
    if event.inaxes == ax_2d and event.button == 1:
        x, y = event.xdata, event.ydata
        # Snap to dividers if close (UX improvement for precise alignment)
        for div in PURPLE_LINES:
            div_x = div * WIDTH
            if abs(x - div_x) < SNAP_THRESHOLD:
                x = div_x
                break
        if draw_mode and not (protractor_active or ruler_active or dimension_active):
            # Check if near first point to close
            if len(drawing_points) > 2:
                dx_first = x - drawing_points[0][0]
                dy_first = y - drawing_points[0][1]
                dist_first = np.sqrt(dx_first**2 + dy_first**2)
                if dist_first < CLOSE_THRESHOLD:
                    # Adjust kappa1 based on last theta and kappa
                    last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
                    if last_theta < 1e-10: # Manage '0' snap error
                        last_theta = 1e-10
                    decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                    kappas[0] = kappas[-1] * decay_factor * curvature # Affect kappa1 with last kappa and decay
                    drawing_points.append(drawing_points[0])
                    kappas.append(kappas[0]) # Last kappa inherits first kappa's theta (via same value)
                    recalculate_kappas() # Recalculate for closure consistency
                    is_closed = True
                    redraw_green_curve(is_closed=True) # Use closed NURKS for ellipse conditions
                    # Get closed curve
                    x_curve, y_curve = green_curve_line.get_data()
                    if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
                        x_curve = np.append(x_curve, x_curve[0])
                        y_curve = np.append(y_curve, y_curve[0])
                    ax_3d.cla()
                    current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
                    verts = [[current_vertices[i] for i in f] for f in current_faces]
                    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
                    ax_3d.set_xlabel('X')
                    ax_3d.set_ylabel('Y')
                    ax_3d.set_zlabel('Z')
                    ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
                    fig_3d.canvas.draw()
                    print("Polyhedron closed and 3D model generated")
                    # Compute and print speeds for user generated curve
                    print("User Generated Curve Speeds:")
                    speeds = []
                    for i in range(len(x_curve)):
                        speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
                        print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
                        speeds.append(speed)
                    # Generate G-Code
                    gcode = generate_gcode(x_curve, y_curve, speeds)
                    with open('model.gcode', 'w') as f:
                        f.write(gcode)
                    print("G-Code saved to model.gcode")
                    print(gcode)
                    fig_2d.canvas.draw()
                    return
            # Add new kappa node (first endpoint)
            roygbiv = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
            color = roygbiv[len(drawing_points) % 7]
            node = ax_2d.scatter(x, y, color=color, s=50, picker=True, label='Kappa Node' if len(drawing_points) == 0 else None)
            node_scatter.append(node)
            original_colors.append(color)
            drawing_points.append((x, y))
            kappas.append(curvature)
            if len(drawing_points) > 1:
                previous_kappa = compute_segment_kappa(drawing_points[-2], drawing_points[-1], curvature, previous_kappa)
                redraw_green_curve(is_closed=is_closed)
                if len(drawing_points) >= 2:
                    t = np.linspace(0, 1, 100)
                    x_green, y_green = green_curve_line.get_data()
                    curv = compute_curvature(x_green, y_green, t)
                    print(f"Green curve curvature: Max={curv.max():.4f}, Min={curv.min():.4f}")
            if len(drawing_points) >= 3:
                print("Third point added: Introducing depth and triangulation")
                tri_points = drawing_points[-3:]
                vp = compute_vanishing_point(tri_points)
                vanishing_points.append(vp)
                ax_2d.scatter(vp[0], vp[1], color='purple', s=30, label='Vanishing Point' if len(vanishing_points) == 1 else None)
            fig_2d.canvas.draw()
        elif not draw_mode and not (protractor_active or ruler_active or dimension_active):
            min_dist = float('inf')
            selected_curve = None
            if green_curve_line:
                x_curve, y_curve = green_curve_line.get_data()
                dist = np.min(np.sqrt((x_curve - x)**2 + (y_curve - y)**2))
                if dist < min_dist and dist < 0.05:
                    min_dist = dist
                    selected_curve = green_curve_line
            if selected_curve:
                selected_curve.set_linewidth(3.0)
                print("Green curve selected")
                fig_2d.canvas.draw()
# Close polyhedron (manual trigger)
def close_polyhedron(event):
    if event.key == 'c':
        print("Close via clicking near first point when ghosted")
# Auto close on 'c'
def auto_close(event):
    global is_closed, drawing_points, kappas, previous_kappa
    if event.key == 'c' and len(drawing_points) > 2:
        # Adjust kappa1 based on last theta and kappa
        last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
        if last_theta < 1e-10: # Manage '0' snap error
            last_theta = 1e-10
        decay_factor = np.exp(-last_theta / WIDTH / 20.0)
        kappas[0] = kappas[-1] * decay_factor * curvature # Affect kappa1 with last kappa and decay
        drawing_points.append(drawing_points[0])
        kappas.append(kappas[0]) # Last kappa inherits first kappa's theta (via same value)
        recalculate_kappas() # Recalculate for closure consistency
        is_closed = True
        redraw_green_curve(is_closed=True) # Use closed NURKS for ellipse conditions
        # Get closed curve
        x_curve, y_curve = green_curve_line.get_data()
        if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
        print("Polyhedron closed and 3D model generated")
        # Compute and print speeds for user generated curve
        print("User Generated Curve Speeds:")
        speeds = []
        for i in range(len(x_curve)):
            speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
            print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
            speeds.append(speed)
        # Generate G-Code
        gcode = generate_gcode(x_curve, y_curve, speeds)
        with open('model.gcode', 'w') as f:
            f.write(gcode)
        print("G-Code saved to model.gcode")
        print(gcode)
        fig_2d.canvas.draw()
# Change to construction geometry
def to_construction(event):
    global selected_curve
    if event.key == 'g' and selected_curve:
        selected_curve.set_linestyle('--')
        selected_curve.set_color('gray')
        print("Green curve changed to construction geometry")
        selected_curve = None
        fig_2d.canvas.draw()
# Hide/show
def hide_show(event):
    global hidden_elements, selected_curve
    if event.key == 'h':
        if selected_curve:
            if selected_curve.get_visible():
                selected_curve.set_visible(False)
                hidden_elements.append(selected_curve)
                print("Green curve hidden")
            else:
                selected_curve.set_visible(True)
                if selected_curve in hidden_elements:
                    hidden_elements.remove(selected_curve)
                print("Green curve shown")
            selected_curve = None
        else:
            for elem in hidden_elements:
                elem.set_visible(True)
            hidden_elements.clear()
            print("All hidden elements shown")
        fig_2d.canvas.draw()
# Reset canvas
def reset_canvas(event):
    global drawing_points, kappas, previous_kappa, green_curve_line, vanishing_points, selected_curve, current_vertices, current_faces, last_angle, node_scatter, ghost_handles, is_closed, original_colors
    if event.key == 'e':
        drawing_points = []
        kappas = []
        previous_kappa = 1.0
        if green_curve_line:
            green_curve_line.remove()
            green_curve_line = None
        for node in node_scatter:
            node.remove()
        node_scatter = []
        original_colors = []
        for handle in ghost_handles:
            handle.remove()
        ghost_handles = []
        vanishing_points = []
        selected_curve = None
        ax_3d.cla()
        current_vertices = None
        current_faces = None
        last_angle = 0.0
        is_closed = False
        display_pod_surface()
        print("Canvas reset")
        fig_2d.canvas.draw()
# Compute curvature for continuity check
def compute_curvature(x, y, t):
    dt = t[1] - t[0]
    dx_dt = np.gradient(x, dt)
    dy_dt = np.gradient(y, dt)
    d2x_dt2 = np.gradient(dx_dt, dt)
    d2y_dt2 = np.gradient(dy_dt, dt)
    numerator = np.abs(dx_dt * d2y_dt2 - dy_dt * d2x_dt2)
    denominator = (dx_dt**2 + dy_dt**2)**1.5
    denominator = np.where(denominator == 0, 1e-10, denominator)
    return numerator / denominator
# Generate base pod curve (closed for boundary surface, now 3D curve)
def generate_pod_curve_closed(num_points=200, phase=0.0): # Increased num_points for better resolution
    t = np.linspace(0, 2 * np.pi, num_points) # Full closed loop
    r = radial_chord + tangential_chord * np.cos(6 * t + phase) # Flower-like top profile
    x = r * np.cos(t)
    y = r * np.sin(t)
    z = height_chord * np.sin(6 * t + phase) # Add z variation for 3D curve
    return x, y, z
# Function to compute normals
def compute_normal(v1, v2, v3):
    vec1 = v2 - v1
    vec2 = v3 - v1
    normal = np.cross(vec1, vec2)
    norm = np.linalg.norm(normal)
    return normal / norm if norm != 0 else normal
# Export current model to STL
def export_stl():
    global current_vertices, current_faces
    if current_vertices is None or current_faces is None:
        print("No model to export")
        return
    stl_data = b'\x00' * 80 # Header
    stl_data += struct.pack('<I', len(current_faces)) # Number of triangles
    for face in current_faces:
        v1 = current_vertices[face[0]]
        v2 = current_vertices[face[1]]
        v3 = current_vertices[face[2]]
        normal = compute_normal(v1, v2, v3)
        stl_data += struct.pack('<3f', *normal)
        stl_data += struct.pack('<3f', *v1)
        stl_data += struct.pack('<3f', *v2)
        stl_data += struct.pack('<3f', *v3)
        stl_data += b'\x00\x00' # Attribute byte count
    filename = 'model.stl'
    with open(filename, 'wb') as f:
        f.write(stl_data)
    print(f"Saved to {filename}")
    stl_base64 = base64.b64encode(stl_data).decode('utf-8')
    print("Base64 STL:")
    print(stl_base64)
# Save STL on key press
def save_stl(event):
    if event.key == 's':
        export_stl()
# Display pod surface by default in 3D with curvature continuous end caps
def display_pod_surface():
    global current_vertices, current_faces
    x_curve, y_curve, z_curve = generate_pod_curve_closed(200) # Increased for resolution
    current_vertices, current_faces = build_mesh(x_curve, y_curve, z_curve)
    verts = [[current_vertices[i] for i in f] for f in current_faces]
    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
    ax_3d.set_xlabel('X')
    ax_3d.set_ylabel('Y')
    ax_3d.set_zlabel('Z')
    ax_3d.set_title('3D pod Projected Surface (Compound Curvature with End Caps)')
    fig_3d.canvas.draw()
# Draw default pod ellipse as green curve on 2D canvas
def draw_default_pod(ax, color='g'):
    x, y, _ = generate_pod_curve_closed(num_points=36) # Increased to 36 for better flower
    x_control = x[:-1]
    y_control = y[:-1]
    scale = 0.6 # Scale for large curve
    x_control *= scale
    y_control *= scale
    x_control += WIDTH / 2
    y_control += HEIGHT / 2
    points = list(zip(x_control, y_control))
    kappas_pod = [1.0] * len(points)
    x_interp, y_interp = custom_interoperations_green_curve(points, kappas_pod, is_closed=True)
    ax.plot(x_interp, y_interp, color=color, linewidth=3, linestyle='-')
    # Compute and print speeds for default curve
    print("Default Curve Speeds:")
    for i in range(len(x_interp)):
        speed = int(hashlib.sha256(f"{x_interp[i]}{y_interp[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
        print(f"Point {i}: ({x_interp[i]:.4f}, {y_interp[i]:.4f}), Speed: {speed:.4f}")
# Add Mersenne elements to the plot
# First A4 page (adjusted)
ax_2d.plot([0, WIDTH/2, WIDTH/2, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 1')
# Second A4 page
ax_2d.plot([WIDTH/2, WIDTH, WIDTH, WIDTH/2, WIDTH/2], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 2')
# Purple lines (in first A4)
for x in PURPLE_LINES:
    ax_2d.plot([x * (WIDTH/2), x * (WIDTH/2)], [0, HEIGHT], 'm-')
# Red datum line
ax_2d.plot([0, WIDTH], [0, 0], 'r-')
# A4 short edge divisions (first A4 only)
for x in division_positions:
    ax_2d.plot([x, x], [0, 0.02], 'k-', alpha=0.3)
# Plot circle division markers
for x_marker, y_marker in circle_markers:
    ax_2d.plot(x_marker, y_marker, 'k.', markersize=3)
# Full spiral
ax_2d.plot(x_full, y_full, 'k-')
# Green segment
ax_2d.plot(x_green_final, y_green_scaled, 'g-')
# 52 Mersenne prime curves
for i, (x_new, y_new, label) in enumerate(curves):
    line, = ax_2d.plot(x_new, y_new, color=colors[i])
    curve_lines[i] = line
# Flags and staggered labels
label_y_offset = 0.05
for i, (x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq) in enumerate(flag_positions):
    ax_2d.plot([x_end, x_start], [y_end, y_start], 'k--', alpha=0.3)
    ax_2d.plot([x_start, x_flag], [y_start, y_flag], 'k-', alpha=0.5)
    y_label = y_flag - (i % 5) * label_y_offset
    text = ax_2d.text(x_flag, y_label, label, ha='left', va='top', fontsize=6, rotation=45, picker=5)
    harmonic_text = ax_2d.text(x_flag, y_label - 0.1, f"{freq:.1f} Hz", ha='left', va='top', fontsize=6, rotation=45, visible=False)
    annotation_objects.append((text, i))
    harmonic_texts.append(harmonic_text)
# Golden window 1 (vertical at x = 1/3)
idx_crossings_x = np.where(np.diff(np.sign(x_full - PURPLE_LINES[0])))[0]
if len(idx_crossings_x) >= 2:
    y1 = y_full[idx_crossings_x[0]]
    y2 = y_full[idx_crossings_x[1]]
    golden_window_1 = np.abs(y2 - y1)
    print(f"Golden Window 1 at x={PURPLE_LINES[0]}: {golden_window_1:.4f}")
    ax_2d.fill_between([PURPLE_LINES[0] - 0.05, PURPLE_LINES[0] + 0.05], min(y1, y2), max(y1, y2), color='yellow', alpha=0.5)
# Golden window 2 (horizontal at y = 1/3)
idx_crossings_y = np.where(np.diff(np.sign(y_full - 1/3)))[0]
if len(idx_crossings_y) >= 2:
    x1 = x_full[idx_crossings_y[0]]
    x2 = x_full[idx_crossings_y[1]]
    golden_window_2 = np.abs(x2 - x1)
    print(f"Golden Window 2 at y=1/3: {golden_window_2:.4f}")
    ax_2d.fill_betweenx([1/3 - 0.05, 1/3 + 0.05], min(x1, x2), max(x1, x2), color='orange', alpha=0.5)
# Scale label
ax_2d.text(WIDTH, 1.10337, scale_label, ha='right', va='bottom', fontsize=8)
# Update title with scale key
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
# Highlighting functionality for Mersenne labels
highlighted = [None, None]
def on_pick_mersenne(event):
    global highlighted
    artist = event.artist
    for text, idx in annotation_objects:
        if artist == text:
            if highlighted[0] is not None:
                highlighted[0].set_color('black')
                highlighted[0].set_weight('normal')
                curve_lines[highlighted[1]].set_linewidth(1.0)
                curve_lines[highlighted[1]].set_color(colors[highlighted[1]])
            text.set_color('red')
            text.set_weight('bold')
            curve_lines[idx].set_linewidth(2.0)
            curve_lines[idx].set_color('red')
            highlighted = [text, idx]
            fig_2d.canvas.draw()
            break
def on_click_deselect(event):
    global highlighted
    if event.inaxes != ax_2d:
        return
    clicked_on_annotation = False
    for text, idx in annotation_objects:
        if text.contains(event)[0]:
            clicked_on_annotation = True
            break
    if not clicked_on_annotation and highlighted[0] is not None:
        highlighted[0].set_color('black')
        highlighted[0].set_weight('normal')
        curve_lines[highlighted[1]].set_linewidth(1.0)
        curve_lines[highlighted[1]].set_color(colors[highlighted[1]])
        highlighted = [None, None]
        fig_2d.canvas.draw()
# Curve cache for hashing
curve_cache = {}
def compute_curve_points(theta_start, theta_end, num_points, scale_factor, rotation_angle=0):
    # Create a hash key based on parameters
    key = f"{theta_start:.2f}:{theta_end:.2f}:{num_points}:{scale_factor:.4f}:{rotation_angle:.2f}"
    key_hash = hashlib.md5(key.encode()).hexdigest()
    if key_hash in curve_cache:
        return curve_cache[key_hash]
    theta = np.linspace(theta_start, theta_end, num_points)
    r = scale_factor * A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Apply rotation
    if rotation_angle != 0:
        angle_rad = np.deg2rad(rotation_angle)
        x_rot = x * np.cos(angle_rad) - y * np.sin(angle_rad)
        y_rot = x * np.sin(angle_rad) + y * np.cos(angle_rad)
        x, y = x_rot, y_rot
    curve_cache[key_hash] = (x, y)
    return x, y
# Dynamic LOD
def get_num_points_for_curve():
    xlim = ax_2d.get_xlim()
    ylim = ax_2d.get_ylim()
    view_width = xlim[1] - xlim[0]
    view_height = ylim[1] - ylim[0]
    # Base number of points when fully zoomed out
    base_points = 20
    max_points = 200
    # Zoom factor: smaller view range means more zoom
    full_range = WIDTH # Full x-range when zoomed out
    zoom_factor = full_range / view_width
    num_points = int(base_points + (max_points - base_points) * min(zoom_factor / 10, 1))
    return max(base_points, min(max_points, num_points))
# Cursor, spiral, and circumference setup
cursor, = ax_2d.plot([], [], 'ro', markersize=8, label='κ Spiral Cursor', visible=False)
cursor_spiral, = ax_2d.plot([], [], 'g-', alpha=0.5, visible=False)
cursor_circumference = plt.Circle((0, 0), 0, color='b', fill=False, linestyle='--', alpha=0.5, visible=False)
ax_2d.add_patch(cursor_circumference)
cursor_text = ax_2d.text(WIDTH / 2, 1.15, '', ha='center', va='bottom', fontsize=8, visible=False)
baseline_spiral, = ax_2d.plot([], [], 'g-', alpha=0.5, label='Baseline Spiral', visible=False)
baseline_spiral_2, = ax_2d.plot([], [], 'g-', alpha=0.5, label='Baseline Spiral 2', visible=False)
# Crosslines
vertical_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
horizontal_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
vertical_label = ax_2d.text(target_chord, HEIGHT + 0.05, f'Chord: {target_chord:.4f}', ha='center', va='bottom', fontsize=8, visible=False)
# Protractor elements
protractor_line, = ax_2d.plot([], [], 'b-', alpha=0.8, visible=False)
protractor_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8), visible=False)
protractor_arc, = ax_2d.plot([], [], 'b-', alpha=0.5, visible=False)
protractor_spiral_2, = ax_2d.plot([], [], 'g-', alpha=0.5, visible=False)
# Baseline angle (grey ghost line)
baseline_angle_line, = ax_2d.plot([0, WIDTH], [0, 0], 'grey', alpha=0.3, linestyle='--', visible=False)
# Swinging ghost curves
ghost_curves = []
for _ in range(4): # ±5°, ±10° (4 curves total)
    line, = ax_2d.plot([], [], 'grey', alpha=0.2, visible=False)
    ghost_curves.append(line)
# Ruler elements
ruler_divisions = []
for _ in range(10): # Up to 10 division markers
    marker, = ax_2d.plot([], [], 'k|', markersize=10, markeredgewidth=2, visible=False)
    ruler_divisions.append(marker)
ruler_vanishing_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        cursor.set_visible(protractor_active)
        cursor_spiral.set_visible(protractor_active)
        cursor_circumference.set_visible(protractor_active)
        cursor_text.set_visible(protractor_active)
        baseline_spiral.set_visible(protractor_active)
        baseline_spiral_2.set_visible(protractor_active)
        vertical_line.set_visible(protractor_active)
        horizontal_line.set_visible(protractor_active)
        vertical_label.set_visible(protractor_active)
        protractor_line.set_visible(protractor_active)
        protractor_text.set_visible(protractor_active)
        protractor_arc.set_visible(protractor_active)
        protractor_spiral_2.set_visible(protractor_active)
        baseline_angle_line.set_visible(protractor_active)
        for curve in ghost_curves:
            curve.set_visible(protractor_active)
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        fig_2d.canvas.draw()
# On motion for protractor
def on_motion_protractor(event):
    if not protractor_active or event.inaxes != ax_2d:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    # Update cursor position
    cursor.set_data([x], [y])
    # Update circumference
    radius = np.sqrt(x**2 + y**2)
    cursor_circumference.set_center((x, y))
    cursor_circumference.set_radius(radius)
    # Dynamic LOD: Adjust number of points based on zoom
    num_points = get_num_points_for_curve()
    # Update cursor spiral
    x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
    cursor_spiral.set_data(x + x_spiral, y + y_spiral)
    # Update baseline spiral (indexed at (0,0))
    x_base = 0.0
    scale_factor = (event.xdata / WIDTH) if event.xdata > 0 else 0.01
    scaled_a = A_SPIRAL * scale_factor
    height_factor = (event.ydata / HEIGHT) if event.ydata > 0 else 0.01
    x_base_spiral, y_base_spiral = compute_curve_points(2 * np.pi, np.pi, num_points, scale_factor)
    x_base_spiral = x_base + x_base_spiral * np.abs(np.cos(np.linspace(2 * np.pi, np.pi, num_points)))
    y_base_spiral = y_base_spiral * height_factor
    baseline_spiral.set_data(x_base_spiral, y_base_spiral)
    # Compute the chord length of the baseline spiral
    x_start = x_base_spiral[0]
    y_start = y_base_spiral[0]
    x_end = x_base_spiral[-1]
    y_end = y_base_spiral[-1]
    baseline_chord = np.sqrt((x_end - x_start)**2 + (y_end - y_start)**2)
    # Update second baseline spiral (indexed at (1.0, 0))
    x_base_2 = 1.0
    x_base_spiral_2, y_base_spiral_2 = compute_curve_points(2 * np.pi, np.pi, num_points, scale_factor)
    x_base_spiral_2 = x_base_2 + x_base_spiral_2 * np.abs(np.cos(np.linspace(2 * np.pi, np.pi, num_points)))
    y_base_spiral_2 = y_base_spiral_2 * height_factor
    baseline_spiral_2.set_data(x_base_spiral_2, y_base_spiral_2)
    # Compute the chord length of the second baseline spiral
    x_start_2 = x_base_spiral_2[0]
    y_start_2 = y_base_spiral_2[0]
    x_end_2 = x_base_spiral_2[-1]
    y_end_2 = y_base_spiral_2[-1]
    baseline_chord_2 = np.sqrt((x_end_2 - x_start_2)**2 + (y_end_2 - y_start_2)**2)
    # Update crosslines
    vertical_line.set_data([target_chord, target_chord], [0, HEIGHT])
    vertical_label.set_position((target_chord, HEIGHT + 0.05))
    if y > 0:
        horizontal_line.set_data([0, WIDTH], [y, y])
    else:
        horizontal_line.set_data([], [])
    # Update protractor line (from (0,0) to mouse position)
    anchor_x, anchor_y = 0.0, 0.0
    protractor_line.set_data([anchor_x, x], [anchor_y, y])
    # Compute the angle relative to the baseline (y=0)
    dx = x - anchor_x
    dy = y - anchor_y
    angle = np.arctan2(dy, dx) * 180 / np.pi
    # Update protractor arc
    mid_x = (anchor_x + x) / 2
    mid_y = (anchor_y + y) / 2
    radius_arc = np.sqrt(dx**2 + dy**2) / 4
    start_angle = 0
    end_angle = angle
    theta_arc = np.linspace(np.deg2rad(start_angle), np.deg2rad(end_angle), num_points)
    x_arc = mid_x + radius_arc * np.cos(theta_arc)
    y_arc = mid_y + radius_arc * np.sin(theta_arc)
    protractor_arc.set_data(x_arc, y_arc)
    # Update swinging ghost curves
    offsets = [-10, -5, 5, 10] # Degrees
    for i, offset in enumerate(offsets):
        angle_offset = angle + offset
        x_ghost, y_ghost = compute_curve_points(np.pi, 2 * np.pi, num_points // 2, 1.0, angle_offset)
        ghost_curves[i].set_data(anchor_x + x_ghost, anchor_y + y_ghost)
    # Update protractor spiral at the mouse position
    line_vec = np.array([x - anchor_x, y - anchor_y])
    line_len = np.sqrt(dx**2 + dy**2)
    if line_len == 0:
        line_len = 1e-10
    normal_vec = np.array([-(y - anchor_y), x - anchor_x]) / line_len
    x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
    x_mirrored = []
    y_mirrored = []
    for xs, ys in zip(x_spiral, y_spiral):
        point = np.array([xs, ys])
        v = point - np.array([anchor_x, anchor_y])
        projection = np.dot(v, normal_vec) * normal_vec
        mirrored_point = point - 2 * projection
        x_mirrored.append(mirrored_point[0])
        y_mirrored.append(mirrored_point[1])
    protractor_spiral_2.set_data(x + x_mirrored, y + y_mirrored)
    # Update protractor text
    protractor_text.set_position((mid_x, mid_y))
    protractor_text.set_text(f'Angle: {angle:.2f}°\nκ at 2πR: {kappa_at_2piR:.4f}')
    # Calculate chord length from cursor to the start of the green segment
    x_start_green, y_start_green = x_green_final[0], y_green_scaled[0]
    chord_to_green = np.sqrt((x - x_start_green)**2 + (y - y_start_green)**2)
    # Update cursor text
    text_str = (f'κ: {scale_factor:.4f}\n'
                f'Height Factor: {height_factor:.4f}\n'
                f'Cursor: ({x:.4f}, {y:.4f})\n'
                f'Chord to Green: {chord_to_green:.4f}\n'
                f'Baseline Chord (x=0): {baseline_chord:.4f}\n'
                f'Baseline Chord (x=1): {baseline_chord_2:.4f}')
    cursor_text.set_text(text_str)
    fig_2d.canvas.draw()
# Toggle harmonics
def toggle_harmonics(event):
    global show_harmonics
    if event.key == 'h':
        show_harmonics = not show_harmonics
        for text in harmonic_texts:
            text.set_visible(show_harmonics)
        print(f"Harmonic frequencies {'shown' if show_harmonics else 'hidden'}")
        fig_2d.canvas.draw()
# Save plot
def save_plot(event):
    if event.key == 'w':
        plt.savefig("nu_curve.png", dpi=300, bbox_inches='tight')
        print("Plot saved as nu_curve.png")
        if MPLD3_AVAILABLE:
            mpld3.save_html(fig_2d, "nu_curve.html")
            print("Interactive plot saved as nu_curve.html")
        else:
            print("Skipping HTML export because mpld3 is not installed.")
# Connect events
fig_2d.canvas.mpl_connect('pick_event', on_pick_mersenne)
fig_2d.canvas.mpl_connect('button_press_event', on_click_deselect)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_harmonics)
fig_2d.canvas.mpl_connect('key_press_event', save_plot)
fig_2d.canvas.mpl_connect('key_press_event', toggle_draw)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('key_press_event', toggle_dimension)
fig_2d.canvas.mpl_connect('key_press_event', to_construction)
fig_2d.canvas.mpl_connect('key_press_event', hide_show)
fig_2d.canvas.mpl_connect('key_press_event', reset_canvas)
fig_2d.canvas.mpl_connect('key_press_event', save_stl)
fig_2d.canvas.mpl_connect('button_press_event', on_click_protractor)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_dimension)
fig_2d.canvas.mpl_connect('button_press_event', on_click_draw)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion)
fig_2d.canvas.mpl_connect('key_press_event', auto_close)
fig_2d.canvas.mpl_connect('key_press_event', toggle_pro_mode)
fig_2d.canvas.mpl_connect('pick_event', on_pick)
fig_2d.canvas.mpl_connect('button_press_event', on_button_press)
fig_2d.canvas.mpl_connect('button_release_event', on_button_release)
# Plot properties
ax_2d.set_xlim(-0.1, WIDTH + 0.1)
ax_2d.set_ylim(-1.5, HEIGHT + 0.1)
ax_2d.set_xlabel('x (Exponents: 2 to 11B)')
ax_2d.set_ylabel('y')
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
ax_2d.grid(True)
ax_2d.set_aspect('equal')
# Display default pod surface and draw default pod
display_pod_surface()
draw_default_pod(ax_2d)
plt.show()

----- END id_util_nurks_surface.py -----

----- id_util_tetra_profile.py -----
# id_util_tetra_profile.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection

def generate_flower_profile(ns_diameter=1.0, nw_se_diameter=0.8, ne_sw_diameter=0.9, twist=0.0, amplitude=0.2, radii=0.5, num_petals=7, num_points=1000):
    """
    Generate a flower-shaped top profile using parametric equations.
    
    Parameters:
    - ns_diameter: North-South diameter (vertical axis).
    - nw_se_diameter: Northwest-Southeast diameter (one diagonal).
    - ne_sw_diameter: Northeast-Southwest diameter (other diagonal).
    - twist: Twist angle in radians for petal rotation.
    - amplitude: Amplitude of petal undulations.
    - radii: Base radius scaling for petals.
    - num_petals: Number of petals in the flower shape.
    - num_points: Number of points to generate for the curve.
    
    Returns:
    - x, y: Arrays of x and y coordinates for the 2D flower profile.
    """
    theta = np.linspace(0, 2 * np.pi, num_points)
    
    # Base elliptical shape using the diameters
    a = ns_diameter / 2  # Semi-major axis (NS)
    b = ne_sw_diameter / 2  # Semi-minor axis approximation
    c = nw_se_diameter / 2  # Another diagonal for variation
    
    # Parametric radius with petal undulations and twist
    r = radii + amplitude * np.sin(num_petals * (theta + twist))
    
    # Incorporate elliptical deformation
    x = r * np.cos(theta) * (a + c) / 2
    y = r * np.sin(theta) * (b + a) / 2
    
    # Apply twist to the entire shape
    twist_mat = np.array([[np.cos(twist), -np.sin(twist)],
                          [np.sin(twist), np.cos(twist)]])
    points = np.vstack([x, y])
    twisted_points = twist_mat @ points
    
    return twisted_points[0], twisted_points[1]

def bspline_basis(u, i, p, knots):
    """
    Recursive B-spline basis function.
    
    Parameters:
    - u: Parameter value.
    - i: Basis index.
    - p: Degree.
    - knots: Knot vector.
    
    Returns:
    - Basis value.
    """
    if p == 0:
        return 1.0 if knots[i] <= u < knots[i + 1] else 0.0
    den1 = knots[i + p] - knots[i]
    den2 = knots[i + p + 1] - knots[i + 1]
    term1 = ((u - knots[i]) / den1 * bspline_basis(u, i, p - 1, knots)) if den1 > 0 else 0.0
    term2 = ((knots[i + p + 1] - u) / den2 * bspline_basis(u, i + 1, p - 1, knots)) if den2 > 0 else 0.0
    return term1 + term2

def apply_kspline_smoothing(x, y, kappa=1.0, degree=5, num_output_points=1000, num_controls=28):
    """
    Apply a kappa-modulated spline smoothing (KSpline) to the profile points using pure NumPy.
    This is a Non-Uniform Rational Kappa Spline (NURKS) implementation without SciPy dependencies.
    Subsamples input points to control points, uses constant weights based on kappa for rational spline.
    
    Parameters:
    - x, y: Input coordinates.
    - kappa: Curvature modulation factor (used as uniform weight).
    - degree: Spline degree.
    - num_output_points: Number of points in the output curve.
    - num_controls: Number of control points to subsample.
    
    Returns:
    - smooth_x, smooth_y: Smoothed coordinates.
    """
    # Subsample to control points
    idx = np.linspace(0, len(x) - 1, num_controls, dtype=int)
    control_points = np.array([[x[i], y[i]] for i in idx])
    
    # Weights uniform based on kappa
    weights = np.full(len(control_points), kappa)
    
    # For closed curve, append points for periodicity
    control_points = np.concatenate((control_points, control_points[1:degree + 1]))
    weights = np.concatenate((weights, weights[1:degree + 1]))
    
    n = len(control_points) - 1
    # Clamped uniform knot vector
    knots = np.concatenate(([0] * (degree + 1), np.linspace(0, 1, n - degree + 2), [1] * (degree)))
    
    u_fine = np.linspace(0, 1, num_output_points)
    
    smooth_x = np.zeros(num_output_points)
    smooth_y = np.zeros(num_output_points)
    
    for j, u in enumerate(u_fine):
        num_x, num_y, den = 0.0, 0.0, 0.0
        for i in range(len(control_points)):
            b = bspline_basis(u, i, degree, knots)
            w = weights[i] * b
            num_x += w * control_points[i, 0]
            num_y += w * control_points[i, 1]
            den += w
        if den > 0:
            smooth_x[j] = num_x / den
            smooth_y[j] = num_y / den
    
    return smooth_x, smooth_y

def generate_tetra_surface(x_profile, y_profile, height=1.0, num_layers=10, twist_per_layer=0.1):
    """
    Generate a 3D tetrahedral-like surface by extruding the 2D profile.
    This creates a stacked mesh with twisting layers for a petal-shaped volume.
    
    Parameters:
    - x_profile, y_profile: 2D profile coordinates.
    - height: Total height of the 3D mesh.
    - num_layers: Number of layers for extrusion.
    - twist_per_layer: Twist increment per layer.
    
    Returns:
    - vertices: 3D vertices (Nx3 array).
    - faces: Triangular faces (Mx3 array).
    """
    num_points = len(x_profile)
    vertices = []
    faces = []
    
    dz = height / num_layers
    for layer in range(num_layers + 1):
        z = layer * dz
        twist = layer * twist_per_layer
        rot_mat = np.array([[np.cos(twist), -np.sin(twist)],
                            [np.sin(twist), np.cos(twist)]])
        rotated = rot_mat @ np.vstack([x_profile, y_profile])
        for i in range(num_points):
            vertices.append([rotated[0, i], rotated[1, i], z])
    
    # Create triangular faces (simple extrusion triangulation)
    for layer in range(num_layers):
        base_idx = layer * num_points
        next_idx = (layer + 1) * num_points
        for i in range(num_points):
            j = (i + 1) % num_points
            # Two triangles per quad
            faces.append([base_idx + i, base_idx + j, next_idx + i])
            faces.append([base_idx + j, next_idx + j, next_idx + i])
    
    return np.array(vertices), np.array(faces)

def visualize_mesh(vertices, faces):
    """
    Visualize the 3D mesh using matplotlib.
    
    Parameters:
    - vertices: 3D vertices.
    - faces: Triangular faces.
    """
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.add_collection3d(Poly3DCollection(vertices[faces], alpha=0.5, edgecolor='k'))
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    limits = np.ptp(vertices, axis=0) / 2
    ax.set_xlim(-limits[0], limits[0])
    ax.set_ylim(-limits[1], limits[1])
    ax.set_zlim(0, limits[2] * 2)
    plt.show()

# Example usage
if __name__ == "__main__":
    # Generate flower profile
    x, y = generate_flower_profile(ns_diameter=2.0, nw_se_diameter=1.5, ne_sw_diameter=1.8, twist=0.2, amplitude=0.3, radii=1.0, num_petals=7)
    
    # Smooth with KSpline (pure NumPy implementation)
    smooth_x, smooth_y = apply_kspline_smoothing(x, y, kappa=0.9)
    
    # Generate tetra surface
    vertices, faces = generate_tetra_surface(smooth_x, smooth_y, height=2.0, num_layers=20, twist_per_layer=0.05)
    
    # Visualize
    visualize_mesh(vertices, faces)

----- END id_util_tetra_profile.py -----

----- id_util_tetra_surface.py -----
# id_util_tetra_surface.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Define control points for a simple NURKS surface (e.g., a curved dome)
control_points = np.array([
    [[0, 0, 0], [1, 0, 0], [2, 0, 0]],
    [[0, 1, 0], [1, 1, 2], [2, 1, 0]],
    [[0, 2, 0], [1, 2, 0], [2, 2, 0]]
])

# Weights for rational aspect - expand to match shape
weights = np.array([
    [1, 1, 1],
    [1, 1.5, 1],
    [1, 1, 1]
])

# Kappa parameter for curvature adjustment
kappa = 1.0  # Adjust this for more/less curvature

# Simple NURBS surface evaluation (bilinear for demo)
u = np.linspace(0, 1, 50)
v = np.linspace(0, 1, 50)
U, V = np.meshgrid(u, v)

X = np.zeros_like(U)
Y = np.zeros_like(U)
Z = np.zeros_like(U)

for i in range(len(u)):
    for j in range(len(v)):
        denom = 0
        numer_x, numer_y, numer_z = 0, 0, 0
        for a in range(3):
            for b in range(3):
                basis = (1 - u[i])**(2-a) * u[i]**a * (1 - v[j])**(2-b) * v[j]**b  # Bilinear basis (degree 2 approx)
                w = weights[a, b] * basis
                denom += w
                numer_x += w * control_points[a, b, 0]
                numer_y += w * control_points[a, b, 1]
                numer_z += w * control_points[a, b, 2] * kappa  # Kappa modulates Z
        X[i, j] = numer_x / denom
        Y[i, j] = numer_y / denom
        Z[i, j] = numer_z / denom

# Plot the surface
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_wireframe(X, Y, Z, color='black')
ax.plot_surface(X, Y, Z, cmap='viridis')

# Show control points
for a in range(3):
    for b in range(3):
        point = control_points[a, b]
        ax.scatter(point[0], point[1], point[2], color='red', s=50)

ax.set_title('NURKS Surface with Control Points')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')

plt.show()

----- END id_util_tetra_surface.py -----

----- kappa_grid.py -----
# kappa_grid.py - Spiral-based grid generation for curvature modulation
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np

def kappa_grid(grid_size=100):
    """
    Generate a 3D grid of kappa values for curvature modulation.
    
    Args:
        grid_size (int): Size of the grid for x and y dimensions.
    
    Returns:
        np.ndarray: 3D array of shape (grid_size, grid_size, num_angles) containing kappa values.
    """
    # Golden spiral parameters from tetra.py
    PHI = (1 + np.sqrt(5)) / 2
    kappa = 1 / PHI
    A_SPIRAL = 0.001
    B_SPIRAL = np.log(PHI) / (np.pi / 2)
    
    # Define angle steps for rotation (e.g., 360 degrees in 10 steps)
    num_angles = 10
    angles = np.linspace(0, 2 * np.pi, num_angles)
    
    # Create grid
    x = np.linspace(-1, 1, grid_size)
    y = np.linspace(-1, 1, grid_size)
    X, Y = np.meshgrid(x, y)
    
    # Initialize kappa grid
    kappa_grid = np.zeros((grid_size, grid_size, num_angles))
    
    # Compute kappa values based on spiral curvature
    for k in range(num_angles):
        theta = angles[k]
        # Compute radius based on spiral
        r = np.sqrt(X**2 + Y**2)
        r[r == 0] = 1e-10  # Avoid division by zero
        # Scale kappa based on spiral equation
        kappa_values = kappa * A_SPIRAL * np.exp(B_SPIRAL * r)
        kappa_grid[:, :, k] = kappa_values
    
    return kappa_grid

----- END kappa_grid.py -----

----- maptics.py -----
# maptics.py
# Copyright 2025 Beau Ayres
# Licensed under AGPL-3.0-or-later

class Maptics:
    def __init__(self):
        self.path = []
    
    def record_path(self, x, y, z, angle):
        """Record welder's hand or torch path."""
        self.path.append((x, y, z, angle))
        print(f"Path recorded: {(x, y, z, angle)}")
    
    def replay_path(self):
        """Replay ghosted hand path for training or automation."""
        print("Replaying path:", self.path)

# Example usage
if __name__ == "__main__":
    maptics = Maptics()
    maptics.record_path(0, 0, 0, 15)
    maptics.replay_path()

----- END maptics.py -----

----- nurks_surface.py -----
# nurks_surface.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import hashlib
import struct
import math
import mpmath
mpmath.mp.dps = 19  # Precision for φ, π.
from KappaSHA256 import kappasha256
from ribit import ribit_generate
from kappawise import kappa_coord
from green_curve import bspline_basis, custom_interoperations_green_curve

u_num = 36
v_num = 20
v_num_cap = 10

# Define userid (placeholder; replace with actual user ID, e.g., from auth system)
userid = 1234  # Example; must be defined to avoid NameError

kappa_grid = kappa_coord(userid, theta=100)

u_num = 36
v_num = 20
v_num_cap = 10

# Optional: Compute kappa_coord if needed for other features (e.g., seeding elsewhere); skipped here per note
# userid = 1234  # Placeholder if needed
# kappa_coords = kappa_coord(userid, theta=100)  # Returns e.g., (814, 330, 818); unused for grid

def generate_nurks_surface(ns_diam=1.0, sw_ne_diam=1.0, nw_se_diam=1.0, twist=0.0, amplitude=0.3, radii=1.0, kappa=1.0, height=1.0, inflection=0.5, morph=0.0, hex_mode=False):
    """Generate parametric NURKS surface points (X, Y, Z) and copyright hash ID using kappasha256."""
    # 36 nodes for angular control.
    u_num = 36
    v_num = 20
    inner_radius = 0.01  # Small to avoid artefacts.
    u = np.linspace(0, 2 * np.pi, u_num)
    # Inline kappa-based grid for v (power-law spacing; bunches near inner if kappa < 1, near outer if kappa > 1)
    if kappa <= 0:
        raise ValueError("Kappa must be positive for power-law grid.")
    lin = np.linspace(0, 1, v_num)
    powered = lin ** kappa
    v = inner_radius + (1 - inner_radius) * powered  # Use kappa-based grid for v
    U, V = np.meshgrid(u, v)
    if hex_mode:
        # Hexagulation: Stagger alternate rows for hexagonal approximation.
        for i in range(1, v_num, 2):
            U[i, :] += np.pi / u_num / 2  # Stagger by half step.
    # Flower profile with 6 petals.
    petal_amp = amplitude * (1 - V)  # Taper for smaller petals at outer ends (V=1).
    # Compute the base sin variation.
    sin_variation = np.sin(6 * U + twist)
    num_coarse = 36
    if hex_mode:
        # Use morph to morph profile: 0 flower, 1 hex, 2 circular.
        morph_mode = int(morph)
        num_coarse = 36
        if morph_mode == 0:
            num_coarse = 36
        elif morph_mode == 1:
            num_coarse = 6
        else:
            num_coarse = 100  # High for circular approximation
        theta_coarse = np.linspace(0, 2 * np.pi, num_coarse, endpoint=False)
        if morph_mode == 1:
            sin_coarse = np.sin(3 * theta_coarse + twist)  # For hex-like (3 petals doubled)
        elif morph_mode == 2:
            sin_coarse = np.zeros(num_coarse)  # No sin for circular
        else:
            sin_coarse = np.sin(6 * theta_coarse + twist)  # Flower
        points = list(zip(theta_coarse, sin_coarse))
        kappas = [1.0] * num_coarse
        smooth_theta, smooth_sin = custom_interoperations_green_curve(points, kappas, is_closed=True)
        smooth_sin = smooth_sin[:-1]
        theta_fine = smooth_theta[:-1]
        sin_variation = np.interp(U % (2 * np.pi), theta_fine, smooth_sin)
    R = radii + petal_amp * sin_variation
    # Deform with diameters (elliptical/radial influence).
    # NS scales y, SW/NE and NW/SE scale diagonals.
    scale_x = (sw_ne_diam + nw_se_diam) / 2
    scale_y = ns_diam
    X = R * V * np.cos(U) * scale_x
    Y = R * V * np.sin(U) * scale_y
    # V-curve: Power-based angulation with inflection.
    dist = np.abs(V - inflection)
    Z = height * (1 - dist ** kappa)  # Inverted V, sharper with higher kappa.
    # Curve radial lines (green curves in diagram) by adding twist modulation.
    curve_factor = 0.1 * amplitude  # Curvature based on amplitude.
    X += curve_factor * np.sin(np.pi * V) * np.cos(U + np.pi/4)  # Curve in SW/NE.
    Y += curve_factor * np.sin(np.pi * V) * np.sin(U + np.pi/4)  # Curve in NW/SE.
    # Hash parameters for copyright ID using kappasha256 (key modulated by kappa).
    param_str = f"{ns_diam},{sw_ne_diam},{nw_se_diam},{twist},{amplitude},{radii},{kappa},{height},{inflection},{morph},{hex_mode}"
    if hex_mode:
        param_str += ',bspline_degree=3,bspline_coarse=36'
    key = hashlib.sha256(struct.pack('f', kappa)).digest() * 2  # 64-byte key from kappa.
    surface_id = kappasha256(param_str.encode('utf-8'), key)[0]  # hash_hex as ID.
    print(f"Surface Copyright ID: {surface_id}")
    # Integrate ribit for center modulation if hex_mode.
    if hex_mode:
        ribit_int, state, color = ribit_generate(param_str)
        print(f"Ribit State: {state}, Color: {color}, Int: {ribit_int}")
        # Use ribit state to modulate cap parameters.
        kappa_cap = 3 + state  # >7th for higher states
        twist_cap = twist + 2 * np.pi * state / 7  # Azimuth change
        mini_factor = 0.1 * (state + 1) / 7  # Scaled mini for ribit variation
        # Generate cap with ribit-modulated params.
        mini_radii = radii * mini_factor
        mini_amplitude = amplitude * mini_factor
        v_num_cap = 10
        # Inline kappa-based grid for cap v (from 0 to inner_radius)
        if kappa_cap <= 0:
            raise ValueError("Kappa_cap must be positive for power-law grid.")
        lin_cap = np.linspace(0, 1, v_num_cap)
        powered_cap = lin_cap ** kappa_cap
        v_cap = 0 + inner_radius * powered_cap  # Use kappa-based grid for cap v
        U_cap, V_cap = np.meshgrid(u, v_cap)
        if hex_mode:
            for i in range(1, v_num_cap, 2):
                U_cap[i, :] += np.pi / u_num / 2  # Stagger cap too for honeycomb.
        # For cap profile, use 7 points K-spline.
        num_coarse_cap = 7
        theta_coarse_cap = np.linspace(0, 2 * np.pi, num_coarse_cap, endpoint=False)
        sin_coarse_cap = np.sin(6 * theta_coarse_cap + twist_cap)
        points_cap = list(zip(theta_coarse_cap, sin_coarse_cap))
        kappas_cap = [1.0] * num_coarse_cap
        smooth_theta_cap, smooth_sin_cap = custom_interoperations_green_curve(points_cap, kappas_cap, is_closed=True)
        smooth_sin_cap = smooth_sin_cap[:-1]
        theta_fine_cap = smooth_theta_cap[:-1]
        sin_variation_cap = np.interp(U_cap % (2 * np.pi), theta_fine_cap, smooth_sin_cap)
        R_cap_base = mini_radii + mini_amplitude * sin_variation_cap
        petal_amp_main_inner = amplitude * (1 - inner_radius)
        sin_variation_main = sin_variation[0, :]  # Angular at boundary
        R_main_inner = radii + petal_amp_main_inner * sin_variation_main
        R_cap = R_cap_base + (R_main_inner[None, :] - R_cap_base) * (V_cap / inner_radius)
        # Deform cap with same scales.
        X_cap = R_cap * V_cap * np.cos(U_cap) * scale_x
        Y_cap = R_cap * V_cap * np.sin(U_cap) * scale_y
        # Curve radial for cap.
        X_cap += curve_factor * np.sin(np.pi * V_cap) * np.cos(U_cap + np.pi/4)
        Y_cap += curve_factor * np.sin(np.pi * V_cap) * np.sin(U_cap + np.pi/4)
        # Z for cap with high power for continuity.
        Z_main_inner = height * (1 - (inner_radius - inflection) ** kappa)  # Approximate, assuming inner small.
        dist_cap = V_cap / inner_radius
        Z_cap = height - (height - Z_main_inner) * dist_cap ** kappa_cap
        # Update param_str for cap
        param_str += f',bspline_degree=3,bspline_coarse=36,ribit_state={state},kappa_cap={kappa_cap},mini_factor={mini_factor}'
        key = hashlib.sha256(struct.pack('f', kappa)).digest() * 2  # 64-byte key from kappa.
        surface_id = kappasha256(param_str.encode('utf-8'), key)[0]  # hash_hex as ID.
        print(f"Surface Copyright ID: {surface_id}")
    else:
        X_cap = None
        Y_cap = None
        Z_cap = None
    return X, Y, Z, surface_id, X_cap, Y_cap, Z_cap

# Example usage (for testing completeness)
if __name__ == "__main__":
    # Call the function with defaults
    X, Y, Z, surface_id, X_cap, Y_cap, Z_cap = generate_nurks_surface()
    print(f"Generated surface with ID: {surface_id}")
    # Test sample v-grid (e.g., for kappa=1, linear; for kappa=2, bunched near 1)
    test_v = 0.01 + (1 - 0.01) * (np.linspace(0, 1, 5) ** 2.0)
    print(f"Sample v-grid (kappa=2): {test_v}")  # e.g., [0.01, 0.2575, 0.505, 0.7525, 1.0]

----- END nurks_surface.py -----

----- particles.py -----
# particles.py
# Copyright 2025 Beau Ayres
# Proprietary Software - All Rights Reserved
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
from frictionvibe import track_kappa_vector  # Import from frictionvibe.py
from telemetry import log  # Assume telemetry.py has log function

def track_particle_vector(stages, drag=0.05):
    """
    Tracks particle vectors from forge to weld in the supply chain.
    - stages: List of (x, y, z, stage_name) tuples (e.g., 'forge', 'ship', 'weld').
    - drag: Drag coefficient (default 0.05).
    Returns: List of particle vectors.
    """
    vectors = track_kappa_vector(stages, drag)  # Reuse kappa vector logic
    for i, (vector, stage) in enumerate(zip(vectors, [s[3] for s in stages])):
        log(f"Particle {i}: Vector {vector}, Stage {stage}")
    
    return vectors

# Example usage
if __name__ == "__main__":
    stages = [(0, 0, 0, 'forge'), (10, 5, 0, 'ship'), (15, 5, 2, 'weld')]
    particle_vectors = track_particle_vector(stages)
    print(f"Particle vectors: {particle_vectors}")

----- END particles.py -----

----- porosity.py -----
# porosity.py
# Copyright 2025 Beau Ayres
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import hashlib
import numpy as np

def porosity_hashing(grid, void_threshold=0.3):
    """
    Discretizes pores into hashed grids for porosity simulation.
    - grid: 3D numpy array representing the tetrahedral mesh.
    - void_threshold: Porosity threshold for hashing voids (default 0.3 for 30% void growth).
    Returns: Dict of hashed voids with keys as hash(node) and values as void volumes.
    """
    hashed_voids = {}
    for i in range(grid.shape[0]):
        for j in range(grid.shape[1]):
            for k in range(grid.shape[2]):
                if grid[i, j, k] > void_threshold:
                    node_str = f"{i}_{j}_{k}"
                    node_hash = hashlib.sha256(node_str.encode()).hexdigest()
                    void_volume = grid[i, j, k] * (1 - void_threshold)  # Simplified volume calculation
                    hashed_voids[node_hash] = void_volume
    return hashed_voids

# Example usage
if __name__ == "__main__":
    # Mock grid for testing (3D array simulating porosity)
    mock_grid = np.random.rand(10, 10, 10)  # Random porosity values between 0 and 1
    voids = porosity_hashing(mock_grid)
    print(f"Hashed voids: {len(voids)}")

----- END porosity.py -----

----- post_process.py -----
# post_process.py
# Copyright 2025 Beau Ayres
# Licensed under AGPL-3.0-or-later

def anodize(acid=None, temp=None, volts=None, dye=None, seal=False):
    """Anodize surface with optional dye and seal."""
    print(f"Anodizing: acid={acid}, temp={temp}C, volts={volts}, dye={dye}, seal={seal}")

def viscosity_check(cps):
    """Check viscosity for dyes or oils."""
    print(f"Viscosity checked: {cps} cps")

def pack(compound, temp, hours):
    """Case hardening packing process."""
    print(f"Packing: compound={compound}, temp={temp}C, duration={hours}h")

def quench(medium, temp):
    """Quench in specified medium."""
    print(f"Quenching: medium={medium}, temp={temp}C")

def paint(primer, topcoat, flakes):
    """Apply paint with primer and topcoat."""
    print(f"Painting: primer={primer}, topcoat={topcoat}, flakes={flakes}")

# Example usage
if __name__ == "__main__":
    anodize("sulfuric", 20, 20, "pearl_gold", True)
    viscosity_check(20)
    pack("urea", 850, 4)
    quench("mineral_oil", 200)
    paint("epoxy_primer", "polyurethene", "mica_gold")

----- END post_process.py -----

----- prep_tools.py -----
# prep_tools.py
# Copyright 2025 Beau Ayres
# Licensed under AGPL-3.0-or-later

def angle_grinder(angle, rpm, coolant):
    """Simulate angle grinding for surface prep."""
    print(f"Grinding: angle={angle} deg, rpm={rpm}, coolant={coolant}")

def swarf_vacuum():
    """Remove swarf and sparks from milling/grinding."""
    print("Swarf vacuumed")

def acetylene_mark(low_oxy, duration):
    """Apply carbon marking with acetylene torch."""
    print(f"Marking: low_oxy={low_oxy}, duration={duration}s")

def auto_markup(angle1, angle2, root_gap):
    """Automatic markup for V bevel."""
    print(f"Markup: angles=({angle1}, {angle2}) deg, root_gap={root_gap} mm")

# Example usage
if __name__ == "__main__":
    angle_grinder(30, 20000, "water")
    swarf_vacuum()
    acetylene_mark(True, 0.8)
    auto_markup(30, 45, 2.0)

----- END prep_tools.py -----

----- quench.py -----
# quench.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

# Adaptation: Add oil quench logging
def log_quench(temp_profile, porosity_threshold=0.2):
    """
    Logs temperature-drop profile during oil quenching and estimates porosity.
    - temp_profile: List of temperatures over time.
    - porosity_threshold: Threshold for void bloating (default 0.2 for 20% voids).
    """
    for t, temp in enumerate(temp_profile):
        log(f"Time {t}: Temp {temp}C")
        if temp < 200:
            voids = (200 - temp) / 200 * porosity_threshold  # Simplified void estimation
            log(f"Void growth: {voids * 100:.1f}%")
    print("Quench log complete")

# Example usage
if __name__ == "__main__":
    mock_temp = [900, 700, 500, 300, 100, 20]  # Simulated temp drop
    log_quench(mock_temp)

----- END quench.py -----

----- regulate_hexagons_on_curve.py -----
# regulate_hexagons_on_curve.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.


import numpy as np
import mpmath
import hashlib
import math
from math_utils import kappa_calc
mpmath.mp.dps = 19
from ribit import ribit_generate
from kappasha import mersenne_fluctuation
PHI_FLOAT = (1 + math.sqrt(5)) / 2  # φ ≈1.618
MODULO = 369  # Cyclic diffusion

def regulate_hexagons_on_curve(X_cap, Y_cap, Z_cap, inner_radius, param_str, speed_threshold=0.5, sub_div=4):
    """Algorithm to regulate hexagon size/position based on curve speed on kappa grid."""
    # Step 1: Ribit gyroscope for azimuth and state
    _, state, _ = ribit_generate(param_str)
    azimuth_base = 2 * np.pi * state / 7  # Gyroscope rotation to reach divisions

    # Step 2: Define kappa grid (7x7 for 7-bit ribit)
    grid_size = 7
    cell_size = inner_radius / grid_size
    grid_x, grid_y = np.meshgrid(np.linspace(-inner_radius/2, inner_radius/2, grid_size), 
                                 np.linspace(-inner_radius/2, inner_radius/2, grid_size))
    
    hex_positions = []  # List of (center_x, center_y, size, azimuth)
    for i in range(grid_size):
        for j in range(grid_size):
            cell_center_x = grid_x[i, j]
            cell_center_y = grid_y[i, j]
            
            # Step 3: Calculate local curve speed (gradient norm at cell)
            # Approximate speed as norm of dZ/dV at nearest point
            closest_idx = np.argmin((X_cap.flatten() - cell_center_x)**2 + (Y_cap.flatten() - cell_center_y)**2)
            v_idx = closest_idx // u_num
            speed = np.gradient(Z_cap[v_idx, :])[0].mean()  # Avg gradient along row as speed proxy
            
            # Step 4: Regulate hex size inversely to speed, weighted by kappa_calc
            kappa_val = kappa_calc(i * j, 0)
            hex_size = cell_size / (1 + abs(speed) * kappa_val / MODULO)  # Smaller for higher speed
            
            # Step 5: Position hex at cell center, rotate by azimuth
            azimuth = azimuth_base + twist  # Twist from params for orientation
            
            # Step 6: Multiple hex per cell if speed > threshold
            if abs(speed) > speed_threshold:
                # Subdivide into sub_div hexagons
                sub_cell_size = hex_size / np.sqrt(sub_div)
                for k in range(sub_div):
                    sub_x = cell_center_x + k * sub_cell_size * np.cos(azimuth + k * 2 * np.pi / sub_div)
                    sub_y = cell_center_y + k * sub_cell_size * np.sin(azimuth + k * 2 * np.pi / sub_div)
                    hex_positions.append((sub_x, sub_y, sub_cell_size, azimuth + k * 2 * np.pi / sub_div))
            else:
                hex_positions.append((cell_center_x, cell_center_y, hex_size, azimuth))
    
    return hex_positions

# Example usage (integrate with NURKS cap)
# Assume X_cap, Y_cap, Z_cap, inner_radius, param_str from generate_nurks_surface
# hex_positions = regulate_hexagons_on_curve(X_cap, Y_cap, Z_cap, inner_radius, param_str)
# For visualization, plot hexagons at positions with size and azimuth (rotation).

----- END regulate_hexagons_on_curve.py -----

----- requirements.txt -----
pandas>=2.2.3
pytest>=8.3.3
mpmath>=1.3.0
# Optional dependencies for future enhancements
# numpy>=1.26.4
# scipy>=1.14.1
# opencv-python>=4.10.0
# pyserial>=3.5

----- END requirements.txt -----

----- rib_structure.py -----
# rib_structure.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
from porosity import porosity_hashing  # Import from porosity_hashing.py

def rib_structure(grid_size=50, porosity_threshold=0.25):
    """
    Generates tetrahedral ribbing with porosity stiffening for case-hardened layers.
    - grid_size: Size of the tetrahedral grid (default 50).
    - porosity_threshold: Threshold for void detection (default 0.25 for 25% voids).
    Returns: Ribbed grid and hashed porosity.
    """
    # Generate base grid
    grid = np.random.rand(grid_size, grid_size, grid_size)
    
    # Apply ribbing (simplified as grid reinforcement)
    grid = grid * 1.2  # Increase stiffness by 20%
    
    # Hash porosity for void tracking
    hashed_porosity = porosity_hashing(grid, porosity_threshold)
    
    return grid, hashed_porosity

# Example usage
if __name__ == "__main__":
    ribbed_grid, hashed_voids = rib_structure()
    print(f"Ribbed grid shape: {ribbed_grid.shape}")
    print(f"Hashed voids: {len(hashed_voids)}")

----- END rib_structure.py -----

----- ribit.py -----
# ribit.py - 7 Bit Ribit (Rainbow-Information-Bit) from Wise Transforms
# Notes: Generates a 7-bit ribit from BitWise, HexWise, HashWise braid. Maps to 7 logical states (0-6) with rainbow colors. Complete; run as-is. Mentally verified: Input='test' → Ribit=42 (example), State=0, Color=Red.
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
import hashlib
import numpy as np
import mpmath
from wise_transforms import bitwise_transform, hexwise_transform, hashwise_transform
mpmath.mp.dps = 19

def ribit_generate(data):
    """Generate 7-bit ribit from braid hybrid, map to 7 states and rainbow color."""
    bit_out = bitwise_transform(data, bits=7)
    hex_out = hexwise_transform(data)
    hash_out, ent = hashwise_transform(data)
    # Braid Hybrid: Concatenate and hash for ribit
    braid = f"{bit_out}:{hex_out}:{hash_out}"
    ribit_hash = hashlib.sha256(braid.encode()).digest()
    ribit_int = int.from_bytes(ribit_hash, 'big') % (1 << 7)  # 7-bit value (0-127)
    state = ribit_int % 7  # 7 logical states (0-6)
    rainbow_colors = ['Red', 'Orange', 'Yellow', 'Green', 'Blue', 'Indigo', 'Violet']  # ROY G BIV
    color = rainbow_colors[state]
    return ribit_int, state, color

if __name__ == "__main__":
    input_data = "test"  # Example
    ribit_int, state, color = ribit_generate(input_data)
    print(f"7-Bit Ribit: {ribit_int} (Binary: {bin(ribit_int)[2:].zfill(7)})")
    print(f"Logical State: {state}, Rainbow Color: {color}")
    # Notes: Ribit maps hexwise braid to 7 states for logical, rainbow-mapped bits. For access: Use as color-coded key in TKDF.

----- END ribit.py -----

----- ribit_structure.py -----
# ribit_structure.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import hashlib
import math
import mpmath
mpmath.mp.dps = 19
from wise_transforms import hashwise_transform, hexwise_transform
from kappawise import murmur32, kappa_coord
from wise_transforms import bitwise_transform, hexwise_transform, hashwise_transform
from id_util_nurks_closure_hex import custom_interoperations_green_curve, bspline_basis

# Points from the image approximation (adjusted for symmetry, with one diameter offset for "not in line")
center = [0, 0]
colored_points = [
    [ -0.4, -0.2 ], # Orange
    [ -0.3, -0.3 ], # Yellow
    [ 0.4, -0.3 ], # Green
    [ 0.5, 0.1 ], # Blue
    [ 0.3, 0.3 ], # Indigo
    [ -0.2, 0.2 ] # Violet
]
colors = ['orange', 'yellow', 'green', 'blue', 'indigo', 'violet'] # ROYGBIV minus red (center red)

# 3D extension: Extrude along Z with height
height = 0.5
num_layers = 50 # For smooth 3D surface
z_levels = np.linspace(0, height, num_layers)

# Generate 3D points using green curve for each arm, with intermediate points for curvature
arms_3d = []
for point in colored_points:
    # Add intermediate point for curvature (midway, offset slightly for curved effect)
    mid_point = [ (center[0] + point[0]) / 2 + 0.05 * np.random.randn(), (center[1] + point[1]) / 2 + 0.05 * np.random.randn() ]
    arm_points = [center, mid_point, point]
    kappas = [1.0, 1.0, 1.0]  # Default weights
    smooth_x, smooth_y = custom_interoperations_green_curve(arm_points, kappas, is_closed=False)  # Open curve for arm
    # Extrude along Z
    arm_3d = np.zeros((len(smooth_x), 3))
    arm_3d[:, 0] = smooth_x
    arm_3d[:, 1] = smooth_y
    arms_3d.append(arm_3d)

# Create mesh for 3D ribit structure (simple extrusion for demonstration)
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

for i, arm_3d in enumerate(arms_3d):
    # Extrude arm along Z
    for z in z_levels:
        arm_z = arm_3d.copy()
        arm_z[:, 2] = z
        ax.plot(arm_z[:, 0], arm_z[:, 1], arm_z[:, 2], color=colors[i])
    # Colored point at end
    ax.scatter(arm_3d[-1, 0], arm_3d[-1, 1], height, color=colors[i], s=50)

# Center point
ax.scatter(center[0], center[1], height, color='red', s=100)

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('3D Ribit Structure with Green Curves')

plt.show()

print("The 3D ribit structure is generated with smoothed green curves for each arm, extruded along Z for depth. The center is at (0,0) with colored points at petal ends.")

----- END ribit_structure.py -----

----- ribit_telemetry.py -----
# ribit_telemetry.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import hashlib
from PIL import Image
from wise_transforms import bitwise_transform, hexwise_transform, hashwise_transform
from id_util_nurks_closure_hex import custom_interoperations_green_curve, bspline_basis
# Mock for runnable

# From friction_vibe / gyro_gimbal class TetraVibe
class TetraVibe:
    def friction_vibe(self, pos1, pos2, kappa=0.3):
        dist = np.linalg.norm(pos1 - pos2)
        if dist < 1e-6:
            print("heat spike-flinch")
            return 1.0, np.zeros(3)
        if dist < 0.1:
            vibe = np.sin(2 * np.pi * dist / 0.05)
            gyro = np.cross(pos1, pos2) / dist
            warp = 1 / (1 + kappa * dist)
            return vibe * warp, gyro
        else:
            return 1.0, np.zeros(3)

    def gyro_gimbal_rotate(self, coords, angles):
        rot_x = np.array([[1, 0, 0], [0, np.cos(angles[0]), -np.sin(angles[0])], [0, np.sin(angles[0]), np.cos(angles[0])]])
        rot_y = np.array([[np.cos(angles[1]), 0, np.sin(angles[1])], [0, 1, 0], [-np.sin(angles[1]), 0, np.cos(angles[1])]])
        rot_z = np.array([[np.cos(angles[2]), -np.sin(angles[2]), 0], [np.sin(angles[2]), np.cos(angles[2]), 0], [0, 0, 1]])
        rot = rot_z @ rot_y @ rot_x
        return np.dot(coords, rot.T)

class RibitTelemetry:
    def __init__(self, coords, entropies):
        self.coords = coords  # Accum from kappa
        self.entropies = entropies
        self.center = np.array([0, 0, 0])
        self.colors = ['orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
        self.height = 0.5
        self.num_layers = 50
        self.vibe_model = TetraVibe()

    def generate(self):
        arms_3d = []
        for i, (coord, ent) in enumerate(zip(self.coords, self.entropies)):
            pos = np.array(coord)
            mid_point = (self.center + pos) / 2 + 0.05 * np.random.randn(3)
            arm_points = [self.center, mid_point, pos]
            smooth_x, smooth_y = custom_interoperations_green_curve(arm_points, [1.0]*3, False)
            arm_3d = np.zeros((len(smooth_x), 3))
            arm_3d[:, 0] = smooth_x
            arm_3d[:, 1] = smooth_y
            # Foam if high ent
            if ent > 100:
                arm_3d[:, 2] += np.random.uniform(0, 0.1, len(smooth_x))  # Foam extrude
            arms_3d.append(arm_3d)
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        for i, arm_3d in enumerate(arms_3d):
            prev_pos = self.center
            for z in np.linspace(0, self.height, self.num_layers):
                arm_z = arm_3d.copy()
                arm_z[:, 2] = z
                vibe, _ = self.vibe_model.friction_vibe(prev_pos, arm_z[0])
                z_levels = np.linspace(0, self.height, self.num_layers) * vibe  # Warp
                angles = np.array([0.1, 0.2, 0.3])  # From spin
                arm_z = self.vibe_model.gyro_gimbal_rotate(arm_z, angles)
                ax.plot(arm_z[:, 0], arm_z[:, 1], arm_z[:, 2], color=self.colors[i % len(self.colors)])
                prev_pos = arm_z[-1]
            ax.scatter(arm_3d[-1, 0], arm_3d[-1, 1], self.height, color=self.colors[i % len(self.colors)], s=50)
        ax.scatter(self.center[0], self.center[1], self.height, color='red', s=100)
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.set_title('3D Ribit Structure with Green Curves')
        png_filename = 'ribit_structure.png'
        plt.savefig(png_filename, dpi=300)
        print(f"Saved ribit structure as PNG: {png_filename}")
        self.raster_to_light(png_filename)
        plt.show()
        print("The 3D ribit structure is generated with smoothed green curves for each arm, extruded along Z for depth. The center is at (0,0) with colored points at petal ends.")

    def raster_to_light(self, png_file):
        img = Image.open(png_file)
        pixels = np.array(img)
        salted_bytes = secure_hash_two(pixels.tobytes().hex(), 'she_key', 'foam')  # Secure she salt
        light_hash = hashlib.sha256(salted_bytes.encode()).hexdigest()[:16]
        bit = bitwise_transform(light_hash)
        hex_out = hexwise_transform(light_hash)
        hash_out, ent = hashwise_transform(light_hash)
        hybrid = f"{bit}:{hex_out}:{hash_out}"
        print(f"Rasterized to light hybrid: {hybrid}")
        intensity = int(light_hash, 16) % 256
        print(f"Light intensity: {intensity} (sim GPIO PWM)")
        return hybrid

# Mock coords ents for test
if __name__ == "__main__":
    coords = [ [0.4, 0.2, 0.1], [-0.3, -0.3, 0.2], [0.4, -0.3, 0.3], [0.5, 0.1, 0.4], [0.3, 0.3, 0.5], [-0.2, 0.2, 0.6] ]
    entropies = [50, 150, 80, 200, 90, 120]
    ribit = RibitTelemetry(coords, entropies)
    ribit.generate()

----- END ribit_telemetry.py -----

----- rig.py -----
# Copyright 2025 Beau Ayres
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import os
import csv
import hashlib
import numpy as np
from datetime import datetime

class Rig:
    def __init__(self, log_file="weld_log.csv"):
        self.angle = 0
        self.torque = 0
        self.log_file = os.environ.get("TELEMETRY_LOG_FILE", log_file)
    
    def tilt(self, direction, degrees):
        """Adjust torch or jib angle for weave or cut."""
        self.angle += degrees
        self.log(f"Tilted {direction} by {degrees} degrees", angle=self.angle)
        print(f"Tilted {direction} by {degrees} degrees")
    
    def stabilize(self):
        """Stabilize against crane sway or wind."""
        self.torque = 0  # Reset torque for stabilization
        self.log("Stabilized rig", torque=self.torque)
        print("Stabilized rig")
    
    def log(self, event, **kwargs):
        """Log telemetry data to CSV."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        row = {"timestamp": timestamp, "event": event}
        row.update(kwargs)
        file_exists = os.path.exists(self.log_file)
        with open(self.log_file, mode='a', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=row.keys())
            if not file_exists:
                writer.writeheader()
            writer.writerow(row)
    
    def flag(self, issue):
        """Flag an issue in telemetry."""
        self.log(f"flag_{issue}")
    
    def rust_probe(self):
        """Simulate rust detection probe."""
        return 0  # Placeholder: No rust detected
    
    def depth_error(self):
        """Simulate depth error check."""
        return False  # Placeholder: No depth error
    
    def crack_location(self):
        """Simulate crack location detection."""
        return None  # Placeholder: No crack detected
    
    def log_quench(self, temp_profile, porosity_threshold=0.2):
        """Log temperature-drop profile during oil quenching."""
        for t, temp in enumerate(temp_profile):
            voids = (200 - temp) / 200 * porosity_threshold if temp < 200 else 0
            self.log(f"Quench step {t}", temp=temp, void_growth=voids * 100)
        print("Quench log complete")
    
    def log_ipfs_navigation(self, vector_data, cache_moves=5):
        """Log supply chain vector navigation with IPFS-style hashing."""
        ipfs_hashes = []
        for i, (pos, speed, load) in enumerate(vector_data):
            move_str = f"{pos}_{speed}_{load}"
            move_hash = hashlib.sha256(move_str.encode()).hexdigest()
            ipfs_hashes.append(move_hash)
            self.log(f"Move {i}", pos=pos, speed=speed, load=load, hash=move_hash[:8])
            if i >= cache_moves:
                self.log(f"Evict move", hash=ipfs_hashes[i - cache_moves][:8])
                ipfs_hashes.pop(0)
        return ipfs_hashes

# Example usage
if __name__ == "__main__":
    rig = Rig()
    rig.tilt("left", 20)
    rig.stabilize()
    rig.log("test_event", amps=60, volts=182)
    rig.flag("hydrogen")
    rig.log_quench([900, 700, 500, 300, 100, 20])
    rig.log_ipfs_navigation([(0, 10, 100), (1, 12, 95)], cache_moves=2)

----- END rig.py -----

----- simulate_backstep.py -----
# simulate_backstep.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

from gyrogimbal import tilt  # Assume gyrogimbal.py has tilt function for crane sway
from telemetry import log  # Assume telemetry.py has log function

def simulate_backstep(bead_length=9, steps=10, crane_sway=True):
    """
    Simulates backstep welding with manual handling and overhead crane.
    - bead_length: Length of each bead in inches (default 9).
    - steps: Number of backsteps (default 10).
    - crane_sway: Boolean to model crane sway (default True).
    Returns: List of temp readings per step.
    """
    temp_readings = []
    for step in range(steps):
        # Simulate backstep
        back = bead_length / 5  # Back up 20% of bead length
        log(f"Step {step}: Advance {bead_length} in, back {back} in")
        
        # Manual handling with crane
        if crane_sway:
            tilt("crane", degrees=2)  # Simulate 2-degree sway
            log("Crane sway adjusted")
        
        # Temp reading
        temp = 250 - step * 5  # Simulated interpass temp drop
        temp_readings.append(temp)
        log(f"Interpass temp: {temp}C")
    
    return temp_readings

# Example usage
if __name__ == "__main__":
    readings = simulate_backstep()
    print(f"Temp readings: {readings}")

----- END simulate_backstep.py -----

----- simulate_crane_sway.py -----
# simulate_crane_sway.py
# Copyright 2025 Beau Ayres
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
from gyrogimbal import tilt  # Assume gyrogimbal.py has tilt function
from telemetry import log  # Assume telemetry.py has log function

def simulate_crane_sway(beam_length=384, sway_angle=2, steps=10):
    """
    Simulates overhead crane sway during welding.
    - beam_length: Length of the beam in inches (default 384 for 32 feet).
    - sway_angle: Maximum sway angle in degrees (default 2).
    - steps: Number of welding steps (default 10).
    Returns: List of sway displacements.
    """
    sway_displacements = []
    for step in range(steps):
        # Simulate crane sway as sinusoidal oscillation
        sway = np.sin(step * np.pi / steps) * sway_angle
        tilt("crane", degrees=sway)  # Apply sway to crane
        displacement = sway * beam_length / 360  # Simplified displacement in inches
        sway_displacements.append(displacement)
        log(f"Step {step}: Sway {sway:.2f} degrees, Displacement {displacement:.2f} inches")
    
    return sway_displacements

# Example usage
if __name__ == "__main__":
    displacements = simulate_crane_sway()
    print(f"Sway displacements: {displacements}")

----- END simulate_crane_sway.py -----

----- simulate_electrode.py -----
# simulate_electrode.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
from ribit import mesh  # Assume ribit.py has mesh function
from telemetry import log  # Assume telemetry.py has log function

def simulate_electrode(voltage=180, amperage=50, gas_mixture=(0.9, 0.1, 0.03), arc_length=3, electrode_gap=2):
    """
    Simulates electrode and flux behavior during welding.
    - voltage: Welding voltage in volts (default 180).
    - amperage: Welding current in amps (default 50).
    - gas_mixture: Tuple of (argon, CO2, oxygen) fractions (default 90% Ar, 10% CO2, 3% O2).
    - arc_length: Arc length in mm (default 3).
    - electrode_gap: Gap between electrode and workpiece in mm (default 2).
    Returns: Dict with arc stability and hydrogen content metrics.
    """
    # Initialize beam mesh
    beam_mesh = mesh("I-beam", dimensions=(8, 32 * 12))  # 8-inch web, 32-foot length in inches
    
    # Simulate ionization and arc stability
    ionization_threshold = 15000 * arc_length  # Volts per meter for argon ionization
    arc_stability = 1.0 if voltage < ionization_threshold else 0.8 - (arc_length - 3) * 0.1
    if arc_length > 5 or electrode_gap > 3:
        arc_stability *= 0.5  # Penalty for long arc or wide gap
        log(f"Unstable arc: length {arc_length} mm, gap {electrode_gap} mm")
    
    # Simulate hydrogen content from flux
    hydrogen_content = 5 * (1 - gas_mixture[0])  # Higher CO2 increases hydrogen
    if hydrogen_content > 3:
        log(f"High hydrogen risk: {hydrogen_content:.1f} ml/100g")
    
    # Update mesh with weld properties
    beam_mesh['weld_strength'] = amperage * arc_stability
    log(f"Arc stability: {arc_stability:.2f}, Weld strength: {beam_mesh['weld_strength']:.1f}")
    
    return {
        'arc_stability': arc_stability,
        'hydrogen_content': hydrogen_content,
        'weld_strength': beam_mesh['weld_strength']
    }

# Example usage
if __name__ == "__main__":
    result = simulate_electrode(voltage=180, amperage=50, arc_length=3, electrode_gap=2)
    print(f"Electrode simulation results: {result}")

----- END simulate_electrode.py -----

----- simulate_fleet_vector.py -----
# simulate_fleet_vector.py
# Copyright 2025 Beau Ayres
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
from telemetry import log_ipfs_navigation  # Assume telemetry.py has IPFS navigation

def simulate_fleet_vector(casters, cache_moves=5):
    """
    Simulates fleet vectors for a group of casters with predictive navigation.
    - casters: List of (id, pos, speed, load) tuples for each caster.
    - cache_moves: Number of moves to cache for IPFS navigation (default 5).
    Returns: Meta-vector (average speed, load, failure rate).
    """
    speeds = [caster[2] for caster in casters]
    loads = [caster[3] for caster in casters]
    failure_rates = [np.random.rand() * 0.1 for _ in casters]  # Simulated failure rates
    
    meta_vector = {
        'avg_speed': np.mean(speeds),
        'avg_load': np.mean(loads),
        'avg_failure_rate': np.mean(failure_rates)
    }
    
    # Log individual caster vectors to IPFS
    vector_data = [(caster[1], caster[2], caster[3]) for caster in casters]
    ipfs_hashes = log_ipfs_navigation(vector_data, cache_moves)
    
    log(f"Meta-vector: {meta_vector}")
    return meta_vector, ipfs_hashes

# Example usage
if __name__ == "__main__":
    casters = [(1, 0, 10, 100), (2, 1, 12, 95), (3, 2, 11, 98)]
    meta_vec, hashes = simulate_fleet_vector(casters)
    print(f"Meta-vector: {meta_vec}, IPFS hashes: {hashes}")

----- END simulate_fleet_vector.py -----

----- simulate_welding.py -----
# simulate_welding.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
from ribit import mesh  # Assume ribit.py has mesh function
from telemetry import log  # Assume telemetry.py has log function

def simulate_welding(bead_length=9, preheat=False, num_passes=3):
    """
    Simulates welding sequence with bead length, preheating, and logging.
    - bead_length: Length of each bead in inches (default 9).
    - preheat: Boolean to toggle preheating (default False).
    - num_passes: Number of welding passes (default 3).
    Returns: Deformation map (numpy array).
    """
    # Generate beam mesh
    beam_mesh = mesh("I-beam", dimensions=(8, 32 * 12))  # 8-inch web, 32-foot length in inches
    
    # Preheating simulation
    if preheat:
        log("Preheating to 150C")
        beam_mesh['temp'] = np.full(beam_mesh.shape, 150)  # Uniform preheat
    
    # Welding passes
    deformation = np.zeros(num_passes)
    for pass_num in range(num_passes):
        # Simulate bead application
        heat_input = 90000 * (bead_length / 39.37)  # Joules per meter to per bead
        beam_mesh['temp'] += heat_input / beam_mesh.size  # Simplified heat addition
        # Simulate warping
        warping = np.random.rand() * (bead_length / 10)  # Random warping based on bead length
        deformation[pass_num] = warping
        log(f"Pass {pass_num + 1}: Bead length {bead_length} in, Warping {warping:.2f} mm")
    
    # Cooling simulation
    log("Cooling to room temp")
    beam_mesh['temp'] = np.full(beam_mesh.shape, 20)  # Cool to 20C
    
    return deformation

# Example usage
if __name__ == "__main__":
    def_map_preheat = simulate_welding(bead_length=12, preheat=True)
    def_map_no_preheat = simulate_welding(bead_length=12, preheat=False)
    print(f"Preheat deformation: {def_map_preheat}")
    print(f"No preheat deformation: {def_map_no_preheat}")

----- END simulate_welding.py -----

----- solid.py -----
# solid.py
# Copyright 2025 Beau Ayres
# Licensed under AGPL-3.0-or-later

class Solid:
    def __init__(self):
        self.mesh = None
    
    def mesh(self, beam_type):
        """Generate tetrahedral mesh for solid (e.g., W21x62)."""
        self.mesh = {"type": beam_type, "geometry": "hyperbolic_ellipse"}
        print(f"Mesh generated for {beam_type}")
    
    def add_stiffeners(self):
        """Add structural ribbing to mesh."""
        print("Stiffeners added to mesh")

# Module-level function to match tetra_forge.py's ribit.mesh call
def mesh(beam_type):
    """Generate tetrahedral mesh for solid (e.g., W21x62)."""
    print(f"Mesh generated for {beam_type}")
    return {"type": beam_type, "geometry": "hyperbolic_ellipse"}

# Example usage
if __name__ == "__main__":
    mesh_data = mesh("W21x62")
    print(f"Mesh data: {mesh_data}")
    solid = Solid()
    solid.add_stiffeners()

----- END solid.py -----

----- sync.py -----
# sync.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

from telemetry import log  # Assume telemetry.py has log function

def quantum_sync(rig1_data, rig2_data, tolerance=0.1):
    """
    Simulates quantum-inspired synchronization between two welding rigs.
    - rig1_data: Dict of telemetry data (e.g., {'temp': 850, 'crown': 0.1}).
    - rig2_data: Dict of telemetry data for second rig.
    - tolerance: Max allowable difference in measurements (default 0.1 mm or degree).
    Returns: Boolean indicating sync status.
    """
    synced = True
    for key in rig1_data:
        if key in rig2_data:
            diff = abs(rig1_data[key] - rig2_data[key])
            if diff > tolerance:
                log(f"Sync failed on {key}: {rig1_data[key]} vs {rig2_data[key]} (diff {diff})")
                synced = False
            else:
                log(f"Sync OK on {key}: {rig1_data[key]}")
    
    if synced:
        log("Rigs synchronized within tolerance")
    else:
        log("Synchronization failed")
    
    return synced

# Example usage
if __name__ == "__main__":
    rig1 = {'temp': 850, 'crown': 0.1}
    rig2 = {'temp': 849, 'crown': 0.12}
    sync_status = quantum_sync(rig1, rig2)
    print(f"Sync status: {sync_status}")

----- END sync.py -----

----- telemetry.py -----
# telemetry.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import hashlib
from PIL import Image

def bspline_basis(u, i, p, knots):
    if p == 0:
        return 1.0 if knots[i] <= u < knots[i + 1] else 0.0
    term1 = ((u - knots[i]) / (knots[i + p] - knots[i])) * bspline_basis(u, i, p - 1, knots) if (knots[i + p] - knots[i]) > 0 else 0
    term2 = ((knots[i + p + 1] - u) / (knots[i + p + 1] - knots[i + 1])) * bspline_basis(u, i + 1, p - 1, knots) if (knots[i + p + 1] - knots[i + 1]) > 0 else 0
    return term1 + term2

def custom_interoperations_green_curve(points, kappas, is_closed=False):
    points = np.array(points)
    kappas = np.array(kappas)
    degree = 3
    num_output_points = 1000
    n = len(points)
    if is_closed:
        knots = np.concatenate((np.arange(-degree, 0), np.linspace(0, n, n - degree + 2), np.arange(n, n + degree)))
    else:
        knots = np.concatenate((np.zeros(degree + 1), np.linspace(0, 1, n - degree + 1)[1:-1], np.ones(degree + 1)))
    u_fine = np.linspace(0, 1, num_output_points)
    smooth_x = np.zeros(num_output_points)
    smooth_y = np.zeros(num_output_points)
    for j, u in enumerate(u_fine):
        num_x, num_y, den = 0.0, 0.0, 0.0
        for i in range(n):
            b = bspline_basis(u, i, degree, knots)
            w = kappas[i] * b
            num_x += w * points[i, 0]
            num_y += w * points[i, 1]
            den += w
        if den > 0:
            smooth_x[j] = num_x / den
            smooth_y[j] = num_y / den
    return smooth_x, smooth_y

class TetraTelemetry:
    def __init__(self):
        self.center = [0, 0]
        self.colored_points = [[ -0.4, -0.2 ], [ -0.3, -0.3 ], [ 0.4, -0.3 ], [ 0.5, 0.1 ], [ 0.3, 0.3 ], [ -0.2, 0.2 ]]
        self.colors = ['orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
        self.height = 0.5
        self.num_layers = 50
        self.z_levels = np.linspace(0, self.height, self.num_layers)
        self.arms_3d = []

    def friction_vibe(self, pos1, pos2, kappa=0.3):
        dist = np.linalg.norm(pos1 - pos2)
        if dist < 0.1:
            vibe = np.sin(2 * np.pi * dist / 0.05)
            gyro = np.cross(pos1, pos2) / dist if dist > 0 else np.zeros_like(pos1)
            warp = 1 / (1 + kappa * dist)
            return vibe * warp, gyro
        else:
            return 0, np.zeros(3)

    def gyro_gimbal(self, pos1, pos2, tilt=np.array([0.1,0.1,0.1]), kappa=0.3):
        dist = np.linalg.norm(pos1 - pos2)
        if dist < 0.1:
            vibe, base_gyro = self.friction_vibe(pos1, pos2, kappa)
            gimbal_spin = base_gyro + tilt / dist if dist > 0 else base_gyro
            warp = 1 / (1 + kappa * dist)
            return vibe * warp, gimbal_spin
        else:
            return 0, np.zeros(3)

    def generate_arms(self):
        for i, point in enumerate(self.colored_points):
            mid_point = [(self.center[0] + point[0]) / 2 + 0.05, (self.center[1] + point[1]) / 2 + 0.05]
            arm_points = [self.center, mid_point, point]
            kappas = [1.0, 1.0, 1.0]
            smooth_x, smooth_y = custom_interoperations_green_curve(arm_points, kappas, is_closed=False)
            arm_3d = np.zeros((len(smooth_x), 3))
            arm_3d[:, 0] = smooth_x
            arm_3d[:, 1] = smooth_y
            self.arms_3d.append(arm_3d)
            # Vibe on close points example
            for j in range(1, len(arm_3d)):
                pos1 = arm_3d[j-1]
                pos2 = arm_3d[j]
                wave, spin = self.gyro_gimbal(pos1, pos2)
                print(f"Arm {i} segment {j}: Wave {wave}, Spin {spin}")

    def visualize(self):
        fig = plt.figure()
        ax = fig.add_subplot(111, projection='3d')
        for i, arm_3d in enumerate(self.arms_3d):
            for z in self.z_levels:
                arm_z = arm_3d.copy()
                arm_z[:, 2] = z
                ax.plot(arm_z[:, 0], arm_z[:, 1], arm_z[:, 2], color=self.colors[i])
            ax.scatter(arm_3d[-1, 0], arm_3d[-1, 1], self.height, color=self.colors[i], s=50)
        ax.scatter(self.center[0], self.center[1], self.height, color='red', s=100)
        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        ax.set_title('3D Ribit Structure with Green Curves')
        png_filename = 'ribit_structure.png'
        plt.savefig(png_filename, dpi=300)
        print(f"Saved as {png_filename}")
        self.raster_to_light(png_filename)
        plt.show()

    def raster_to_light(self, png_file):
        img = Image.open(png_file)
        pixels = np.array(img)
        light_hash = hashlib.sha256(pixels.tobytes()).hexdigest()[:16]
        print(f"Light hash: {light_hash}")
        intensity = int(light_hash, 16) % 256
        print(f"Intensity: {intensity}")

if __name__ == "__main__":
    telemetry = TetraTelemetry()
    telemetry.generate_arms()
    telemetry.visualize()

----- END telemetry.py -----

----- telemetry_nav.py -----
# telemetry_nav.py
# Copyright 2025 Beau Ayres
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import hashlib

def log_ipfs_navigation(vector_data, cache_moves=5):
    """
    Logs supply chain vector navigation using IPFS-style hashing.
    - vector_data: List of (position, speed, load) tuples for fleet vectors.
    - cache_moves: Number of moves to cache locally (default 5).
    Returns: List of IPFS-style hashes for navigation steps.
    """
    ipfs_hashes = []
    for i, (pos, speed, load) in enumerate(vector_data):
        # Create a content-addressed hash for each move
        move_str = f"{pos}_{speed}_{load}"
        move_hash = hashlib.sha256(move_str.encode()).hexdigest()
        ipfs_hashes.append(move_hash)
        log(f"Move {i}: Pos {pos}, Speed {speed}, Load {load}, Hash {move_hash[:8]}")
        
        # Cache up to cache_moves
        if i >= cache_moves:
            log(f"Evicting oldest move: {ipfs_hashes[i - cache_moves][:8]}")
            ipfs_hashes.pop(0)
    
    return ipfs_hashes

# Example usage
if __name__ == "__main__":
    mock_vectors = [(0, 10, 100), (1, 12, 95), (2, 11, 98), (3, 9, 102), (4, 10, 100)]
    hashes = log_ipfs_navigation(mock_vectors)
    print(f"IPFS navigation hashes: {hashes}")

----- END telemetry_nav.py -----

----- tessellations.py -----
# tessellations.py - Hexagonal and Sierpinski Mesh Tessellation
# Notes: Generates hexagonal mesh and applies Sierpinski tessellation for surface detail. Complete; run as-is. Requires numpy (pip install numpy). Verified: Hex mesh with 6 cells → triangulated to STL; Sierpinski level=2 → detailed facets.
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
import numpy as np
import hashlib
import struct
from scipy.spatial import Voronoi, Delaunay  # For Voronoi diagram
from regulate_hexagons_on_curve import regulate_hexagons_on_curve

def tessellate_hex_mesh(X, Y, Z, u_num, v_num, param_str, is_cap=False):
    """Tessellate surface into hexagonal mesh, triangulated for STL."""
    triangles = []
    # Use regulate_hexagons_on_curve to get hex positions/sizes based on curve speed
    hex_positions = regulate_hexagons_on_curve(X, Y, Z, inner_radius=0.01, param_str=param_str)
    # Generate seeds from hex positions (centers)
    seeds = np.array([(pos[0], pos[1]) for pos in hex_positions])
    # Compute Voronoi on seeds for hex-like cells
    vor = Voronoi(seeds)
    # Use Delaunay for triangulation of Voronoi regions (hex-like cells)
    tri = Delaunay(seeds)
    # For each simplex, map to 3D with Z, add to triangles
    for sim in tri.simplices:
        v1 = np.append(seeds[sim[0]], Z.flatten()[sim[0]] if Z is not None else 0)
        v2 = np.append(seeds[sim[1]], Z.flatten()[sim[1]] if Z is not None else 0)
        v3 = np.append(seeds[sim[2]], Z.flatten()[sim[2]] if Z is not None else 0)
        triangles.append((v1, v2, v3))  # 3D triangle
    if is_cap:
        # Cap with center for closed surface
        center = (0, 0.0, 0.0, Z[0, 0])
        for j in range(u_num):
            p1 = (j, X[0, j], Y[0, j], Z[0, j])
            p2 = ( (j + 1) % u_num, X[0, (j + 1) % u_num], Y[0, (j + 1) % u_num], Z[0, (j + 1) % u_num])
            triangles.append((center, p1, p2))
    return triangles

def build_mail(X, Y, Z, level=3):
    """Build Sierpinski tessellated hex mail mesh for surface detail."""
    # Flatten surface points to 2D for Voronoi (project to XY for simplicity)
    points = np.column_stack((X.flatten(), Y.flatten()))
    vor = Voronoi(points)
    # Use Delaunay for triangulation of Voronoi regions (hex-like cells)
    tri = Delaunay(points)
    all_triangles = []
    # Apply Sierpinski (fractal_tetra) to each tri for detail
    for sim in tri.simplices:
        verts = points[sim]
        scale = np.linalg.norm(verts[1] - verts[0])  # Approximate scale
        orig = np.array([
            verts[0].tolist() + [Z.flatten()[sim[0]]],
            verts[1].tolist() + [Z.flatten()[sim[1]]],
            verts[2].tolist() + [Z.flatten()[sim[2]]],
            [np.mean(verts, axis=0)[0], np.mean(verts, axis=0)[1], np.mean(Z.flatten()[sim]) + scale / 2]  # Apex for tetra
        ])
        fractal_triangles = []
        fractal_tetra(orig.tolist(), level, fractal_triangles)
        all_triangles.extend(fractal_triangles)
    # Flatten to vertices and faces
    vertices = []
    faces = []
    for tri in all_triangles:
        base_idx = len(vertices)
        vertices.extend(tri)
        faces.append([base_idx, base_idx+1, base_idx+2])
    return vertices, faces

def tessellate_mesh(X, Y, Z, u_num, v_num, is_cap=False):
    triangles = []
    if is_cap:
        # Add center point at (0, 0, Z[0,0])
        center = (0, 0.0, 0.0, Z[0, 0])
        # Add fan triangles for the first row (i=0)
        for j in range(u_num):
            p1 = (j, X[0, j], Y[0, j], Z[0, j])
            p2 = (j + 1 % u_num, X[0, (j + 1) % u_num], Y[0, (j + 1) % u_num], Z[0, (j + 1) % u_num])
            triangles.append((center, p1, p2))
        start_i = 0
    else:
        start_i = 0
    # Normal quads for the rest
    for i in range(start_i, v_num - 1):
        for j in range(u_num):
            p1 = (i * u_num + j, X[i, j], Y[i, j], Z[i, j])
            p2 = (i * u_num + (j + 1) % u_num, X[i, (j + 1) % u_num], Y[i, (j + 1) % u_num], Z[i, (j + 1) % u_num])
            p3 = ((i + 1) * u_num + (j + 1) % u_num, X[i + 1, (j + 1) % u_num], Y[i + 1, (j + 1) % u_num], Z[i + 1, (j + 1) % u_num])
            p4 = ((i + 1) * u_num + j, X[i + 1, j], Y[i + 1, j], Z[i + 1, j])
            # Two triangles per quad.
            triangles.append((p1, p2, p3))
            triangles.append((p1, p3, p4))
    return triangles

----- END tessellations.py -----

----- test_tools.py -----
# test_tools.py
# Copyright 2025 Beau Ayres
# Licensed under AGPL-3.0-or-later

def flex_until_break(load, ram):
    """Simulate flex test until failure."""
    print(f"Flex test: load={load}, ram={ram}")
    # Placeholder: Return False for no failure (to resolve failure variable)
    return False

def ink_test(dye, uv):
    """Perform dye penetration test for defects."""
    print(f"Ink test: dye={dye}, uv={uv}")

# Example usage
if __name__ == "__main__":
    flex_until_break("5mm/min", "hydraulic")
    ink_test("red_dye", True)

----- END test_tools.py -----

----- tests/test_simulation.py -----
# test_simulation.py
# Copyright 2025 Beau Ayres
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import pytest
import os
import sys
import numpy as np

# Fallback to add tetra directory to sys.path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from tetra import kappa_grid
from porosity_hashing import porosity_hashing
from electrode import simulate_electrode
from crane_sway import simulate_crane_sway
from particle_vector import track_particle_vector
from quantum_sync import quantum_sync
from fleet_vector import simulate_fleet_vector
from tetra.forge_telemetry import log, flag, rust_probe, depth_error, crack_location
from tetra.solid import mesh
from tetra.haptics import buzz, shake
from tetra.welding import weave, TIG, acetylene
from tetra.rig import Rig
from tetra.friction import Friction
from tetra.maptics import Maptics
from tetra.prep_tools import angle_grinder, swarf_vacuum, acetylene_mark, auto_markup
from tetra.test_tools import flex_until_break, ink_test
from tetra.post_process import anodize, viscosity_check, pack, quench, paint

def test_kappa_grid():
    """Test kappa_grid generation."""
    grid = kappa_grid(grid_size=10)
    assert grid.shape == (10, 10, 360), "Unexpected kappa grid shape"

def test_porosity_hashing():
    """Test porosity hashing for void detection."""
    grid = np.random.rand(10, 10, 10)  # Mock grid
    hashed_voids = porosity_hashing(grid, void_threshold=0.3)
    assert isinstance(hashed_voids, dict), "Hashed voids should be a dictionary"
    assert len(hashed_voids) > 0, "No voids detected"

def test_electrode_stability():
    """Test electrode simulation for arc stability and hydrogen content."""
    result = simulate_electrode(voltage=180, amperage=50, arc_length=3, electrode_gap=2)
    assert result['arc_stability'] > 0.7, f"Arc stability too low: {result['arc_stability']}"
    assert result['hydrogen_content'] < 4, f"Hydrogen content too high: {result['hydrogen_content']}"
    assert result['weld_strength'] > 0, "Weld strength should be positive"

def test_crane_sway():
    """Test crane sway simulation for welding."""
    displacements = simulate_crane_sway(beam_length=384, steps=5)
    assert len(displacements) == 5, f"Unexpected number of sway displacements: {len(displacements)}"
    assert all(abs(d) < 10 for d in displacements), "Sway displacement too large"

def test_particle_vector():
    """Test particle vector tracking for supply chain."""
    stages = [(0, 0, 0, 'forge'), (10, 5, 0, 'ship'), (15, 5, 2, 'weld')]
    vectors = track_particle_vector(stages)
    assert len(vectors) == 3, f"Unexpected number of particle vectors: {len(vectors)}"
    assert all(len(v) == 3 for v in vectors), "Invalid vector dimensions"

def test_quantum_sync():
    """Test quantum-inspired synchronization between rigs."""
    rig1 = {'temp': 850, 'crown': 0.1}
    rig2 = {'temp': 849, 'crown': 0.12}
    sync_status = quantum_sync(rig1, rig2, tolerance=0.1)
    assert sync_status, "Rigs should be synchronized within tolerance"

def test_fleet_vector():
    """Test fleet vector simulation for casters."""
    casters = [(1, 0, 10, 100), (2, 1, 12, 95), (3, 2, 11, 98)]
    meta_vec, hashes = simulate_fleet_vector(casters)
    assert isinstance(meta_vec, dict), "Meta-vector should be a dictionary"
    assert len(hashes) <= 5, f"Too many IPFS hashes: {len(hashes)}"
    assert meta_vec['avg_speed'] > 0, "Average speed should be positive"

def test_forge_telemetry_log(tmp_path):
    """Test logging to CSV for welding telemetry."""
    log_file = tmp_path / "weld_log.csv"
    os.environ["TELEMETRY_LOG_FILE"] = str(log_file)
    log("test_event", amps=60, volts=182)
    assert os.path.exists(log_file), "Log file not created"
    with open(log_file, 'r') as f:
        content = f.read()
        assert "test_event" in content, "Event not logged"
        assert "amps" in content, "Amps not logged"

def test_forge_telemetry_flag(tmp_path):
    """Test flagging an issue in telemetry."""
    log_file = tmp_path / "weld_log.csv"
    os.environ["TELEMETRY_LOG_FILE"] = str(log_file)
    flag("hydrogen")
    assert os.path.exists(log_file), "Log file not created"
    with open(log_file, 'r') as f:
        content = f.read()
        assert "flag_hydrogen" in content, "Hydrogen flag not logged"

def test_forge_telemetry_probes():
    """Test telemetry probe functions."""
    assert rust_probe() == 0, "Rust probe should return 0"
    assert depth_error() is False, "Depth error should be False"
    assert crack_location() is None, "Crack location should be None"

def test_solid_mesh():
    """Test mesh generation for welding simulations."""
    mesh_data = mesh("W21x62")
    assert mesh_data["type"] == "W21x62", f"Unexpected mesh type: {mesh_data['type']}"
    assert mesh_data["geometry"] == "hyperbolic_ellipse", f"Unexpected geometry: {mesh_data['geometry']}"

def test_haptics():
    """Test haptic feedback functions."""
    buzz("low")
    shake("hard")
    # Note: Hardware-dependent, assuming no errors raised

def test_welding():
    """Test welding functions for parameter settings."""
    weave("christmas_tree", speed=18, arc=1.8)
    TIG(tungsten="1%lan", argon=98, volts=25, hz=100)
    acetylene(low_oxy=True, duration=0.8)
    # Note: Hardware-dependent, assuming no errors raised

def test_rig():
    """Test rig stabilization and tilt."""
    rig = Rig()
    rig.tilt("left", 20)
    rig.stabilize()
    # Note: Hardware-dependent, assuming stabilization completes

def test_friction():
    """Test friction damping and oscillation."""
    friction = Friction()
    friction.damp(0.5)
    friction.oscillation()
    assert friction.damping == 0.5, f"Unexpected damping value: {friction.damping}"

def test_maptics():
    """Test path recording and replay."""
    maptics = Maptics()
    maptics.record_path(0, 0, 0, 15)
    maptics.replay_path()
    assert len(maptics.path) == 1, f"Unexpected path length: {len(maptics.path)}"
    assert maptics.path[0] == (0, 0, 0, 15), "Unexpected path coordinates"

def test_prep_tools():
    """Test preparation tools for welding setup."""
    angle_grinder(30, 20000, "water")
    swarf_vacuum()
    acetylene_mark(low_oxy=True, duration=0.8)
    auto_markup(30, 45, 2.0)
    # Note: Hardware-dependent, assuming no errors raised

def test_test_tools():
    """Test tools for weld integrity."""
    assert flex_until_break("5mm/min", "hydraulic") is False, "Flex test should not break"
    ink_test("red_dye", True)
    # Note: Hardware-dependent, assuming no errors raised

def test_post_process():
    """Test post-processing functions for welds."""
    anodize("sulfuric", 20, 20, "pearl_gold", True)
    viscosity_check(20)
    pack("urea", 850, 4)
    quench("mineral_oil", 200)
    paint("epoxy_primer", "polyurethene", "mica_gold")
    # Note: Hardware-dependent, assuming no errors raised

# Example usage
if __name__ == "__main__":
    pytest.main(["-v"])

----- END tests/test_simulation.py -----

----- tetra -----
# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
=== Commit History (Oldest to Newest) ===
2025-09-28T20:12:11Z - tetrasurfaces: Initial commit
2025-09-28T20:33:13Z - tetrasurfaces: Update LICENSE
2025-09-28T20:41:50Z - tetrasurfaces: Create tetra
2025-09-28T20:45:20Z - tetrasurfaces: Create License. Hashlet
2025-09-28T21:24:45Z - tetrasurfaces: Update LICENSE
2025-09-28T21:34:19Z - tetrasurfaces: Update LICENSE
2025-09-28T21:40:36Z - tetrasurfaces: Update LICENSE
2025-09-28T22:04:09Z - tetrasurfaces: Update tetra
2025-09-28T22:18:15Z - tetrasurfaces: Rename tetra to tetras
2025-09-28T22:21:49Z - tetrasurfaces: Rename tetras to tetras.py
2025-09-28T23:44:52Z - tetrasurfaces: Create NOTICE
2025-09-28T23:45:27Z - tetrasurfaces: Update tetras.py
2025-09-28T23:52:43Z - tetrasurfaces: Create LICENSE. LETTER TO LICENSOR
2025-09-29T00:29:45Z - tetrasurfaces: Update LICENSE. LETTER TO LICENSOR
2025-09-29T05:00:40Z - tetrasurfaces: Create tetra
2025-09-30T05:58:11Z - tetrasurfaces: Update tetra

Add G-Code (USE CAUTION)
2025-09-30T07:38:00Z - tetrasurfaces: Create id_util_tetra_surface.py
2025-09-30T07:40:08Z - tetrasurfaces: Create id_util_kspline.py
2025-09-30T08:02:11Z - tetrasurfaces: Create id_util_tetra_profile.py
2025-09-30T08:26:21Z - tetrasurfaces: Create nurks_surface.py
2025-09-30T08:28:04Z - tetrasurfaces: Create id_util_nurks_surface.py
2025-09-30T08:53:36Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T09:14:38Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T09:18:35Z - tetrasurfaces: Update id_util_nurks_surface.py

This repository contains a Python script (id_util_nurks_surface.py) for generating and visualizing a 6-petal flower-shaped 3D surface using Non-Uniform Rational Kappa Spline (NURKS) techniques. The surface is a single body with continuous curvature, avoiding fan triangulation artefacts. It features an interactive Matplotlib interface with sliders for real-time parameter adjustments, allowing users to customize the profile's diameters, twist, amplitude (for u/n shapes), radii, kappa (curvature modulation), height, and inflection point.

The script is designed for educational, design, and manufacturing applications, such as 3D printing or visualization of organic shapes. It leverages pure NumPy and Matplotlib, ensuring no external dependencies beyond these libraries.
Key Features

    Single Surface Body: Parametric NURKS surface with the flower profile as the boundary, rendered as a Delaunay-like triangular mesh for smooth, curved sections.
    Parameter Controls:
        Elliptical deformation via NS, NW/SE, NE/SW diameters (guide curves for radial V-angulations).
        Twist for petal rotation.
        Amplitude (positive/negative for convex/concave inflections).
        Radii for base scaling.
        Kappa for Z-curvature sharpness.
        Height for overall elevation.
        Inflection for V-profile transition point.
    Visualization: 3D plot with colored triangles (viridis cmap based on Z-height), wireframe, red control points, and dashed control net.
    No Fan Triangulation: Uses grid-based quad splitting for even edge distribution; small inner radius prevents central artefacts.
    Continuous Curvature: B-spline evaluation ensures smooth edges and surfaces.

Installation

    Ensure Python 3.x is installed.
    Install required libraries:
    text

pip install numpy matplotlib

Download and run the script:
text

    python id_util_nurks_surface.py

Usage

Run the script to launch the interactive 3D viewer. Use sliders to adjust parameters:

    Diameters (NS, NW/SE, NE/SW): Deform the boundary profile elliptically, influencing radial V-shapes.
    Twist: Rotate the petals.
    Amplitude: Control petal depth; negative values create inflections for concave shapes.
    Radii: Scale the base profile.
    Kappa: Modulate Z-curvature (higher for sharper V-angulations).
    Height: Set maximum Z-elevation.
    Inflection: Shift the V-profile peak point radially.

The surface updates in real-time. Rotate/zoom the 3D view with mouse interactions.
Example Configurations

    Convex Flower: Amplitude = 0.3, Inflection = 0.5, Kappa = 1.0 → Pronounced petals with smooth rise.
    Concave Inflection: Amplitude = -0.3, Inflection = 0.3, Kappa = 2.0 → Inverted petals with sharp V-curves.
    Asymmetric Deformation: Adjust diameters (e.g., NS=2.5, NW/SE=1.0, NE/SW=2.0) for elliptical variations in radial angulations.

Technical Details

    NURKS Implementation: Pure NumPy B-spline basis for rational spline evaluation; periodic in angular (u) direction, clamped in radial (v).
    Mesh Generation: Parametric grid points triangulated into quads split as triangles for Delaunay-like structure; no central fan.
    Z-Profile: Power-based V-angulation (dist ** kappa, inverted), radiating with curved arms as per hand-drawn reference.
    Closure: Last point inherits first's properties via periodicity; kappa modulates as theta-dependent curvature.
    Artefact Mitigation: Small inner_radius (0.01) and even knot distribution ensure continuous edges without overlaps (parametrically resolved).
2025-09-30T09:32:20Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T09:35:30Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T09:44:59Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T09:56:53Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T10:08:31Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T10:16:15Z - tetrasurfaces: Create id_util_nurks_closure.py
2025-09-30T10:27:50Z - tetrasurfaces: Create id_util_nurks_closure_hex.py

Curve smoothing makes it circular (Dodecagonal-Hexagonal-Circular) due to aggressive B-spline smoothing
2025-09-30T10:30:09Z - tetrasurfaces: Update id_util_nurks_closure.py
2025-09-30T10:31:17Z - tetrasurfaces: Update id_util_nurks_closure.py
2025-09-30T10:31:45Z - tetrasurfaces: Update id_util_nurks_closure.py
2025-09-30T10:32:10Z - tetrasurfaces: Update id_util_nurks_closure_hex.py
2025-09-30T10:36:05Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T10:49:39Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T11:17:18Z - tetrasurfaces: Update tetra
2025-09-30T11:31:02Z - tetrasurfaces: Update tetra
2025-09-30T11:52:11Z - tetrasurfaces: Update tetra
2025-09-30T12:47:31Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T12:56:19Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T12:57:52Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T13:30:46Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T13:32:02Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T13:32:57Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T13:35:08Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T13:35:31Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T14:15:21Z - tetrasurfaces: Update tetra
2025-09-30T14:18:27Z - tetrasurfaces: Create tetra.py
2025-09-30T14:45:02Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-09-30T15:12:38Z - tetrasurfaces: Update tetra.py
2025-09-30T15:12:54Z - tetrasurfaces: Update tetra
2025-09-30T16:34:30Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T16:42:04Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T16:42:59Z - tetrasurfaces: Update tetra.py
2025-09-30T16:53:40Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T16:57:02Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T17:09:43Z - tetrasurfaces: Update nurks_surface.py
2025-09-30T17:52:54Z - tetrasurfaces: Update tetra.py
2025-09-30T17:56:19Z - tetrasurfaces: Update tetra.py
2025-09-30T17:58:28Z - tetrasurfaces: Update tetra.py
2025-09-30T18:54:47Z - tetrasurfaces: Update tetra.py
2025-09-30T19:43:55Z - tetrasurfaces: Update tetra.py
2025-09-30T20:10:48Z - tetrasurfaces: Update tetra.py
2025-09-30T20:21:33Z - tetrasurfaces: Update tetra
2025-09-30T20:28:02Z - tetrasurfaces: Update tetra
2025-09-30T20:44:35Z - tetrasurfaces: Update tetra.py
2025-09-30T20:47:36Z - tetrasurfaces: Update tetra
2025-09-30T21:26:02Z - tetrasurfaces: Update tetra.py
2025-09-30T21:42:13Z - tetrasurfaces: Update tetra.py
2025-10-01T00:02:58Z - tetrasurfaces: Update tetra.py
2025-10-01T00:10:44Z - tetrasurfaces: Update tetra.py
2025-10-01T00:25:58Z - tetrasurfaces: Update id_util_nurks_surface.py
2025-10-01T00:45:26Z - tetrasurfaces: Update nurks_surface.py

=== File Contents ===
----- LICENSE -----
Custom License Based on Apache 2.0
(With Educational Institution Restriction)
TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION


Definitions.
"License" shall mean the terms and conditions for use, reproduction,
and distribution as defined by Sections 1 through 9 of this document.
"Licensor" shall mean the copyright owner or entity authorized by
the copyright owner that is granting the License.
"Legal Entity" shall mean the union of the acting entity and all
other entities that control, are controlled by, or are under common
control with that entity. For the purposes of this definition,
"control" means (i) the power, direct or indirect, to cause the
direction or management of such entity, whether by contract or
otherwise, or (ii) ownership of fifty percent (50%) or more of the
outstanding shares, or (iii) beneficial ownership of such entity.
"You" (or "Your") shall mean an individual or Legal Entity
exercising permissions granted by this License.
"Source" form shall mean the preferred form for making modifications,
including but not limited to software source code, documentation
source, and configuration files.
"Object" form shall mean any form resulting from mechanical
transformation or translation of a Source form, including but
not limited to compiled object code, generated documentation,
and conversions to other media types.
"Work" shall mean the work of authorship, whether in Source or
Object form, made available under the License, as indicated by a
copyright notice that is included in or attached to the work
(an example is provided in the Appendix below).
"Derivative Works" shall mean any work, whether in Source or Object
form, that is based on (or derived from) the Work and for which the
editorial revisions, annotations, elaborations, or other modifications
represent, as a whole, an original work of authorship. For the purposes
of this License, Derivative Works shall not include works that remain
separable from, or merely link (or bind by name) to the interfaces of,
the Work and Derivative Works thereof.
"Contribution" shall mean any work of authorship, including
the original version of the Work and any modifications or additions
to that Work or Derivative Works thereof, that is intentionally
submitted to Licensor for inclusion in the Work by the copyright owner
or by an individual or Legal Entity authorized to submit on behalf of
the copyright owner. For the purposes of this definition, "submitted"
means any form of electronic, verbal, or written communication sent
to the Licensor or its representatives, including but not limited to
communication on electronic mailing lists, source code control systems,
and issue tracking systems that are managed by, or on behalf of, the
Licensor for the purpose of discussing and improving the Work, but
excluding communication that is conspicuously marked or otherwise
designated in writing by the copyright owner as "Not a Contribution."
"Contributor" shall mean Licensor and any individual or Legal Entity
on behalf of whom a Contribution has been received by Licensor and
subsequently incorporated within the Work.


Grant of Copyright License. Subject to the terms and conditions of
this License, each Contributor hereby grants to You a perpetual,
worldwide, non-exclusive, no-charge, royalty-free, irrevocable
copyright license to reproduce, prepare Derivative Works of,
publicly display, publicly perform, sublicense, and distribute the
Work and such Derivative Works in Source or Object form.


Grant of Patent License. Subject to the terms and conditions of
this License, each Contributor hereby grants to You a perpetual,
worldwide, non-exclusive, no-charge, royalty-free, irrevocable
(except as stated in this section) patent license to make, have made,
use, offer to sell, sell, import, and otherwise transfer the Work,
where such license applies only to those patent claims licensable
by such Contributor that are necessarily infringed by their
Contribution(s) alone or by combination of their Contribution(s)
with the Work to which such Contribution(s) was submitted. If You
institute patent litigation against any entity (including a
cross-claim or counterclaim in a lawsuit) alleging that the Work
or a Contribution incorporated within the Work constitutes direct
or contributory patent infringement, then any patent licenses
granted to You under this License for that Work shall terminate
as of the date such litigation is filed.


Redistribution. You may reproduce and distribute copies of the
Work or Derivative Works thereof in any medium, with or without
modifications, and in Source or Object form, provided that You
meet the following conditions:
(a) You must give any other recipients of the Work or
Derivative Works a copy of this License; and
(b) You must cause any modified files to carry prominent notices
stating that You changed the files; and
(c) You must retain, in the Source form of any Derivative Works
that You distribute, all copyright, patent, trademark, and
attribution notices from the Source form of the Work,
excluding those notices that do not pertain to any part of
the Derivative Works; and
(d) If the Work includes a "NOTICE" text file as part of its
distribution, then any Derivative Works that You distribute must
include a readable copy of the attribution notices contained
within such NOTICE file, excluding those notices that do not
pertain to any part of the Derivative Works, in at least one
of the following places: within a NOTICE text file distributed
as part of the Derivative Works; within the Source form or
documentation, if provided along with the Derivative Works; or,
within a display generated by the Derivative Works, if and
wherever such third-party notices normally appear. The contents
of the NOTICE file are for informational purposes only and
do not modify the License. You may add Your own attribution
notices within Derivative Works that You distribute, alongside
or as an addendum to the NOTICE text from the Work, provided
that such additional attribution notices cannot be construed
as modifying the License.
You may add Your own copyright statement to Your modifications and
may provide additional or different license terms and conditions
for use, reproduction, or distribution of Your modifications, or
for any such Derivative Works as a whole, provided Your use,
reproduction, and distribution of the Work otherwise complies with
the conditions stated in this License.


Submission of Contributions. Unless You explicitly state otherwise,
any Contribution intentionally submitted for inclusion in the Work
by You to the Licensor shall be under the terms and conditions of
this License, without any additional terms or conditions.
Notwithstanding the above, nothing herein shall supersede or modify
the terms of any separate license agreement you may have executed
with Licensor regarding such Contributions.


Trademarks. This License does not grant permission to use the trade
names, trademarks, service marks, or product names of the Licensor,
except as required for reasonable and customary use in describing the
origin of the Work and reproducing the content of the NOTICE file.


Disclaimer of Warranty. Unless required by applicable law or
agreed to in writing, Licensor provides the Work (and each
Contributor provides its Contributions) on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied, including, without limitation, any warranties or conditions
of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
PARTICULAR PURPOSE. You are solely responsible for determining the
appropriateness of using or redistributing the Work and assume any
risks associated with Your exercise of permissions under this License.


Limitation of Liability. In no event and under no legal theory,
whether in tort (including negligence), contract, or otherwise,
unless required by applicable law (such as deliberate and grossly
negligent acts) or agreed to in writing, shall any Contributor be
liable to You for damages, including any direct, indirect, special,
incidental, or consequential damages of any character arising as a
result of this License or out of the use or inability to use the
Work (including but not limited to damages for loss of goodwill,
work stoppage, computer failure or malfunction, or any and all
other commercial damages or losses), even if such Contributor
has been advised of the possibility of such damages.


Accepting Warranty or Additional Liability. While redistributing
the Work or Derivative Works thereof, You may choose to offer,
and charge a fee for, acceptance of support, warranty, indemnity,
or other liability obligations and/or rights consistent with this
License. However, in accepting such obligations, You may act only
on Your own behalf and on Your sole responsibility, not on behalf
of any other Contributor, and only if You agree to indemnify,
defend, and hold each Contributor harmless for any liability
incurred by, or claims asserted against, such Contributor by reason
of your accepting any such warranty or additional liability.


Safety and Environmental Compliance
Any use or redistribution of the Work in physical form (e.g., battery hardware)
must comply with applicable safety standards (e.g., UL 1642, IEC 62133) and
environmental regulations (e.g., EU Battery Directive 2023/1542, requiring 70%
recycling efficiency by 2030). Contributors must provide end-of-life recycling
instructions to ensure proper disposal or reuse of hardware components.


Cryptographic Export Controls
The Work includes cryptographic functionality. Use, distribution, or export must comply with applicable
export control regulations (e.g., US EAR, Category 5 Part 2). Redistribution
in jurisdictions with cryptographic restrictions requires Licensor approval.


Educational Institution Licensing Requirement
Any Educational Institution, including but not limited to tertiary education institutes, universities, technical colleges, or similar entities, must negotiate a separate commercial license for use of the Work. This License does not grant such institutions any rights to use, reproduce, or distribute the Work without prior written agreement from the Licensor.


END OF TERMS AND CONDITIONS
APPENDIX: How to apply the License to your work.
To apply this License to your work, attach the following
boilerplate notice, with the fields enclosed by brackets "[]"
replaced with your own identifying information. (Don't include
the brackets!) The text should be enclosed in the appropriate
comment syntax for the file format. We also recommend that a
file or class name and description of purpose be included on the
same "printed page" as the copyright notice for easier
identification within third-party archives.
Copyright 2025 (c) Todd Hutchinson
Licensed under this Custom License (based on Apache License, Version 2.0) (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0  (original base, with modifications as specified)
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

----- END LICENSE -----

----- LICENSE. LETTER TO LICENSOR -----
END-USER SOFTWARE LICENSE AGREEMENT FOR EDUCATIONAL INSTITUTIONS
THIS AGREEMENT is made as of this [date] ("Effective Date") by and between Todd Hutchinson, an individual or entity with offices at P.O. Box 215, Mannum, SA, 5238 (“LICENSOR”), and [Name of Educational Institution], an educational institution with offices at [Institution’s address] (“LICENSEE”) (collectively, the “PARTIES”).
W I T N E S S E T H
WHEREAS, LICENSOR is the owner of, or has acquired rights to, certain Software and Documentation as defined in Exhibit A attached hereto (the “Licensed Software”);
WHEREAS, LICENSEE, as an Educational Institution, desires to use such Licensed Software for educational, research, or institutional purposes; and
WHEREAS, LICENSOR requires Educational Institutions to negotiate and enter into a separate commercial license agreement for any use of the Licensed Software, and LICENSEE agrees to contact LICENSOR to initiate such negotiation.
NOW, THEREFORE, in consideration of the promises and agreements set forth herein, the parties, each intending to be legally bound hereby, do promise and agree as follows.

DEFINITIONS
A. "Designated Equipment" shall mean the hardware products identified on Exhibit "A" with which the Software is licensed for use.
B. "Documentation" shall mean all manuals, user documentation, and other related materials pertaining to the Software which are furnished to LICENSEE by LICENSOR in connection with the Software.
C. "Educational Institution" shall mean any tertiary education institute, university, technical college, school, or similar entity engaged in teaching, research, or academic activities.
D. "License Fee" shall mean the amount negotiated between the parties for the use of the Software.
E. "Software" shall mean the computer programs in machine readable object code form listed in Exhibit "A" attached hereto and any subsequent error corrections or updates supplied to LICENSEE by LICENSOR pursuant to this Agreement. Exhibit "A" may be amended from time to time by the parties in writing.
REQUIREMENT FOR NEGOTIATION
A. Negotiation Obligation. As an Educational Institution, LICENSEE must contact LICENSOR at at P.O. Box 215, Mannum, SA, 5238 and sendtotoddhutchinson@gmail.com to request and negotiate a separate commercial license agreement prior to any use, reproduction, distribution, or modification of the Software. This License does not grant any rights until such negotiation is completed and a formal agreement is signed.
B. No Automatic Grant. Use of the Softwhttps://github.com/tetrasurfaces/tetra/community/license/new?branch=mainare without a negotiated license constitutes a breach of this Agreement and may result in legal action.
LICENSE GRANT (POST-NEGOTIATION)
Upon successful negotiation and payment of the License Fee, LICENSOR may grant to LICENSEE a nonexclusive, non-transferable right and license to use the Software on the number of primary systems of Designated Equipment identified on Schedule A hereto for the negotiated term (the “License Term”). The Software shall be used only for educational purposes as specified in the negotiated agreement.
DELIVERY
Upon negotiation, LICENSOR shall deliver to LICENSEE a master copy of the Software licensed hereunder in object code form, suitable for reproduction, in electronic files only. LICENSOR shall also deliver the applicable Documentation.
MODIFICATIONS
A. Error Corrections and Updates. LICENSOR may provide error corrections, bug fixes, patches, or updates as part of the negotiated agreement.
B. Other Modifications. LICENSEE may request modifications, but LICENSOR reserves the right to approve or deny such requests.
C. Title to Modifications. All modifications shall remain the property of LICENSOR.
COPIES
LICENSEE may make copies only as permitted in the negotiated agreement. All copies must retain proprietary notices.
LICENSE FEES AND PAYMENT
LICENSEE shall pay the negotiated License Fee. All payments are non-refundable and exclusive of taxes, which LICENSEE is responsible for.
PROPRIETARY RIGHTS
A. Restrictions. LICENSEE agrees not to copy, modify, reverse engineer, sell, assign, sublicense, rent, lease, or otherwise transfer the Software without LICENSOR’s permission.
B. Proprietary Notices. LICENSEE agrees to maintain all copyright and proprietary notices.
C. Title. Title to the Software remains with LICENSOR.
TERM AND TERMINATION
A. Term. This Agreement commences upon negotiation and continues for the License Term unless terminated.
B. Termination. Either party may terminate upon breach not cured within [number] days.
C. Effect of Termination. LICENSEE must cease use and return or destroy all copies.
WARRANTY AND DISCLAIMER
A. Limited Warranty. LICENSOR warrants the Software performs as described for [number] days.
B. Disclaimer. THE SOFTWARE IS PROVIDED "AS IS" WITHOUT OTHER WARRANTIES.
LIMITATION OF LIABILITY
LICENSOR SHALL NOT BE LIABLE FOR INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES.
GENERAL PROVISIONS
A. Governing Law. Governed by the laws of South Australia.
B. Entire Agreement. This is the entire agreement.
C. Severability. Invalid provisions do not affect the remainder.

IN WITNESS WHEREOF, the parties have executed this Agreement as of the Effective Date.
LICENSOR: Todd Hutchinson
By: ____________________________
Name: Todd Hutchinson
Title: Mr.
Date: ____________________________
LICENSEE: [Educational Institution Name]
By: ____________________________
Name: [Authorized Signatory]
Title: [Title]
Date: ____________________________
EXHIBIT A
[Description of Software, Designated Equipment, etc.]

----- END LICENSE. LETTER TO LICENSOR -----

----- License. Hashlet -----
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007

 Copyright (C) 2025 coneing

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU Affero General Public License as
 published by the Free Software Foundation, either version 3 of the
 License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.

----- END License. Hashlet -----

----- NOTICE -----
NOTICE

This software is proprietary and provided under a custom license. Educational Institutions (including universities, technical colleges, etc.) must contact the Licensor at sendtotoddhutchinson@gmail.com to negotiate a commercial license before use. Unauthorized use is prohibited.

----- END NOTICE -----

----- id_util_kspline.py -----
# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.

import numpy as np
import matplotlib.pyplot as plt

# Points from the image approximation
points = np.array([[0.1, 0.1], [0.5, 0.3], [0.9, 0.2]])

# Simple curve (black)
t = np.linspace(0, 1, 100)
x_curve = (1 - t)**2 * points[0, 0] + 2*(1 - t)*t * points[1, 0] + t**2 * points[2, 0]
y_curve = (1 - t)**2 * points[0, 1] + 2*(1 - t)*t * points[1, 1] + t**2 * points[2, 1]

# Gray offset curve (parallel above)
offset = 0.05  # approximate offset
normals_x = np.gradient(y_curve)  # perpendicular is gradient of y for x, but approximate
normals_y = -np.gradient(x_curve)
norm = np.sqrt(normals_x**2 + normals_y**2)
normals_x /= norm
normals_y /= norm
x_offset = x_curve + offset * normals_x
y_offset = y_curve + offset * normals_y

# Plot
fig, ax = plt.subplots()
ax.plot(x_curve, y_curve, 'k-')
ax.plot(x_offset, y_offset, 'gray')
ax.scatter(points[:,0], points[:,1], c='red', s=50)
ax.set_axis_off()
plt.show()

print("The plot shows a black curve connecting three red points, with a gray parallel curve above it.")

----- END id_util_kspline.py -----

----- id_util_nurks_closure.py -----
# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
import numpy as np
import matplotlib.pyplot as plt

def bspline_basis(u, i, p, knots):
    if p == 0:
        if i < 0 or i + 1 >= len(knots):
            return 0.0
        return 1.0 if knots[i] <= u <= knots[i + 1] else 0.0
    
    if i < 0 or i >= len(knots) - 1:
        return 0.0
    
    term1 = 0.0
    if i + p < len(knots):
        den1 = knots[i + p] - knots[i]
        if den1 > 0:
            term1 = ((u - knots[i]) / den1) * bspline_basis(u, i, p - 1, knots)
    
    term2 = 0.0
    if i + p + 1 < len(knots):
        den2 = knots[i + p + 1] - knots[i + 1]
        if den2 > 0:
            term2 = ((knots[i + p + 1] - u) / den2) * bspline_basis(u, i + 1, p - 1, knots)
    
    return term1 + term2

def custom_interoperations_green_curve(points, kappas, is_closed=False):
    points = np.array(points)
    kappas = np.array(kappas)
    degree = 2  # Change to 2
    num_output_points = 1000
   
    if is_closed and len(points) > degree:
        n = len(points)
        extended_points = np.concatenate((points[n-degree:], points, points[0:degree]))
        extended_kappas = np.concatenate((kappas[n-degree:], kappas, kappas[0:degree]))
        len_extended = len(extended_points)
        knots = np.linspace(-degree / float(n), 1 + degree / float(n), len_extended + 1)
   
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
   
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
   
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len_extended):
                b = bspline_basis(u, i, degree, knots)
                w = extended_kappas[i] * b
                num_x += w * extended_points[i, 0]
                num_y += w * extended_points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
   
        smooth_x = np.append(smooth_x, smooth_x[0])
        smooth_y = np.append(smooth_y, smooth_y[0])
   
    return smooth_x, smooth_y

# Test with flower shape
num_petals = 6
num_u = num_petals * 2  # 12
theta = np.linspace(0, 2 * np.pi, num_u, endpoint=False)
radii = 1.0
amplitude = 0.3
r_base = radii + amplitude * np.sin(num_petals * theta)
x_base_coarse = r_base * np.cos(theta)
y_base_coarse = r_base * np.sin(theta)

boundary_points = list(zip(x_base_coarse, y_base_coarse))
boundary_kappas = [1.0] * len(boundary_points)
smooth_x, smooth_y = custom_interoperations_green_curve(boundary_points, boundary_kappas, is_closed=True)

# Check if closed
print('First and last points match:', np.allclose(smooth_x[0], smooth_x[-1]), np.allclose(smooth_y[0], smooth_y[-1]))

# Plot to visualize
plt.figure()
plt.plot(smooth_x, smooth_y, 'b-')
plt.plot(x_base_coarse, y_base_coarse, 'r--')
plt.scatter(x_base_coarse, y_base_coarse, color='red')
plt.axis('equal')
plt.title('Smoothed Closed Curve with degree 2')
plt.show()

# Output some points to check
print('Smooth X first 5:', smooth_x[:5])
print('Smooth Y first 5:', smooth_y[:5])
print('Smooth X last 5:', smooth_x[-5:])
print('Smooth Y last 5:', smooth_y[-5:])

----- END id_util_nurks_closure.py -----

----- id_util_nurks_closure_hex.py -----
# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
import numpy as np
import matplotlib.pyplot as plt

def bspline_basis(u, i, p, knots):
    if p == 0:
        if i < 0 or i + 1 >= len(knots):
            return 0.0
        return 1.0 if knots[i] <= u <= knots[i + 1] else 0.0
    
    if i < 0 or i >= len(knots) - 1:
        return 0.0
    
    term1 = 0.0
    if i + p < len(knots):
        den1 = knots[i + p] - knots[i]
        if den1 > 0:
            term1 = ((u - knots[i]) / den1) * bspline_basis(u, i, p - 1, knots)
    
    term2 = 0.0
    if i + p + 1 < len(knots):
        den2 = knots[i + p + 1] - knots[i + 1]
        if den2 > 0:
            term2 = ((knots[i + p + 1] - u) / den2) * bspline_basis(u, i + 1, p - 1, knots)
    
    return term1 + term2

def custom_interoperations_green_curve(points, kappas, is_closed=False):
    points = np.array(points)
    kappas = np.array(kappas)
    degree = 3
    num_output_points = 1000
   
    if is_closed and len(points) > degree:
        n = len(points)
        extended_points = np.concatenate((points[n-degree:], points, points[0:degree]))
        extended_kappas = np.concatenate((kappas[n-degree:], kappas, kappas[0:degree]))
        len_extended = len(extended_points)
        knots = np.linspace(-degree / float(n), 1 + degree / float(n), len_extended + 1)
   
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
   
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
   
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len_extended):
                b = bspline_basis(u, i, degree, knots)
                w = extended_kappas[i] * b
                num_x += w * extended_points[i, 0]
                num_y += w * extended_points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
   
        smooth_x = np.append(smooth_x, smooth_x[0])
        smooth_y = np.append(smooth_y, smooth_y[0])
   
    return smooth_x, smooth_y

# Test with flower shape - increase num_u
num_petals = 6
num_u = num_petals * 6  # 36 points for better approximation
theta = np.linspace(0, 2 * np.pi, num_u, endpoint=False)
radii = 1.0
amplitude = 0.3
r_base = radii + amplitude * np.sin(num_petals * theta)
x_base_coarse = r_base * np.cos(theta)
y_base_coarse = r_base * np.sin(theta)

boundary_points = list(zip(x_base_coarse, y_base_coarse))
boundary_kappas = [1.0] * len(boundary_points)
smooth_x, smooth_y = custom_interoperations_green_curve(boundary_points, boundary_kappas, is_closed=True)

# Check if closed
print('First and last points match:', np.allclose(smooth_x[0], smooth_x[-1]), np.allclose(smooth_y[0], smooth_y[-1]))

# Plot to visualize
plt.figure()
plt.plot(smooth_x, smooth_y, 'b-')
plt.plot(x_base_coarse, y_base_coarse, 'r--')
plt.scatter(x_base_coarse, y_base_coarse, color='red')
plt.axis('equal')
plt.title('Smoothed Closed Curve with more points')
plt.show()

# Output some points to check
print('Smooth X first 5:', smooth_x[:5])
print('Smooth Y first 5:', smooth_y[:5])
print('Smooth X last 5:', smooth_x[-5:])
print('Smooth Y last 5:', smooth_y[-5:])

----- END id_util_nurks_closure_hex.py -----

----- id_util_nurks_surface.py -----
# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import cm
from matplotlib.widgets import Slider
import hashlib
from decimal import Decimal, getcontext
import warnings
from matplotlib import MatplotlibDeprecationWarning
import struct
import base64
# Import mpld3 if available for HTML export
try:
    import mpld3
    MPLD3_AVAILABLE = True
except ImportError:
    print("mpld3 not installed. HTML export will be skipped. Install mpld3 with 'pip install mpld3' to enable.")
    MPLD3_AVAILABLE = False
from temperature_salt import secure_hash_two
from kappawise import kappa_coord
from nurks_surface import bspline_basis, bspline_basis_periodic, custom_interoperations_green_curve
# Set precision for Decimal
getcontext().prec = 28
# Suppress warnings
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)
# A3 landscape dimensions (normalized: width long side, height short side)
WIDTH = 420 / 297 # A3 landscape: 420mm width, 297mm height, normalized height=1.0
HEIGHT = 1.0
PURPLE_LINES = [1/3, 2/3] # Dividers on the width
unit_per_mm = 1.0 / 297 # Normalize to A3 short side
scale_label = f"Scale: 1mm = {unit_per_mm:.5f} units (A3 short side = 297mm)"
# Dreyfuss human factors: Optimal eye distance ~20 inches (508mm)
EYE_DISTANCE = 500 * unit_per_mm # Normalized eye distance to viewport
HORIZON_HEIGHT = HEIGHT * 0.5 # Default horizon line at half height
EYE_LINE = HORIZON_HEIGHT # Eye line coincides with horizon
# Golden spiral parameters
PHI = (1 + np.sqrt(5)) / 2
kappa = 1 / PHI
A_SPIRAL = 0.001 # Scaled down slightly from 0.01 to fit better
B_SPIRAL = np.log(PHI) / (np.pi / 2)
# Define κθπ for the green segment
theta_max = kappa * np.pi**2 / PHI
# Compute the full spiral
theta_full = np.linspace(0, 10 * np.pi, 1000)
r_full = A_SPIRAL * np.exp(B_SPIRAL * theta_full)
x_full = r_full * np.cos(theta_full)
y_full = r_full * np.sin(theta_full)
# Compute the green segment (θ from π to 2π)
theta_green = np.linspace(np.pi, 2 * np.pi, 200)
r_green = A_SPIRAL * np.exp(B_SPIRAL * theta_green)
x_green = r_green * np.cos(theta_green)
y_green = r_green * np.sin(theta_green)
# Compute the chord and shift
x1, y1 = x_green[0], y_green[0]
x2, y2 = x_green[-1], y_green[-1]
chord_length = np.abs(x2 - x1)
# Shift so the segment starts at x=0
x_green_shifted = x_green - x1
x_green_final = x_green_shifted
# Scale to match the target chord length (between purple lines)
target_chord = PURPLE_LINES[1] - PURPLE_LINES[0]
scale_factor = target_chord / chord_length if chord_length != 0 else 1.0
x_green_scaled = x_green_final * scale_factor
y_green_scaled = y_green * scale_factor
# Shift to start at the first purple line
x_green_final = x_green_scaled + PURPLE_LINES[0]
# Compute κ at 2πR for the green segment
r_max = A_SPIRAL * np.exp(B_SPIRAL * theta_max)
two_pi_r = 2 * np.pi * r_max
kappa_at_2piR = two_pi_r / PHI
# Define the 52 Mersenne prime exponents (updated with the latest known as of 2025)
mersenne_exponents = [
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
    3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
    110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
    6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
    37156667, 42643801, 43112609, 57885161, 74207281, 77232917, 82589933,
    136279841 # Latest known Mersenne prime exponent as of 2025 (52nd)
]
# Map exponents to x-positions (0 to width)
min_exponent = 2
max_exponent_at_x1 = 1_100_000_000
exponent_range_per_x = (max_exponent_at_x1 - min_exponent) / 1.0
x_positions = [(exponent - min_exponent) / exponent_range_per_x * WIDTH for exponent in mersenne_exponents] # Scale to full WIDTH
# Create the 52 curves data
curves = []
curve_lines = []
colors = plt.cm.viridis(np.linspace(0, 1, len(mersenne_exponents)))
for i, (exponent, x_pos) in enumerate(zip(mersenne_exponents, x_positions)):
    scale = x_pos / chord_length if chord_length != 0 else 1.0
    x_new = x_green * scale
    y_new = y_green * scale
    x_new_shifted = x_new - x_new[0]
    curves.append((x_new_shifted, y_new, f"M{exponent}"))
    curve_lines.append(None)
# A4 short edge divisions (110 parts, scaled to first part of WIDTH)
division_step = WIDTH / 2 / 110 # Assume first half is A4-like
division_positions = np.arange(0, WIDTH / 2 + division_step, division_step)
# Scale key for the title
scale_key_positions = division_positions[::10] / (WIDTH / 2) # Normalize to 0-1 for first half
scale_key_exponents = [int(2 + (1_100_000_000 - 2) * x) for x in scale_key_positions]
scale_key_text = "Scale (x=0 to WIDTH/2): " + ", ".join([f"{x:.2f}: {exp:,}" for x, exp in zip(scale_key_positions, scale_key_exponents)])
# Flags for Mersenne primes
flag_length = 0.5
start_y = -0.1
wedge_angles = np.linspace(90, 360, len(curves))
flag_positions = []
annotation_objects = []
harmonic_frequencies = []
circle_markers = []
min_exp = min(mersenne_exponents)
max_exp = max(mersenne_exponents)
log_min = np.log(min_exp)
log_max = np.log(max_exp)
min_freq_exp = -4.459
max_freq_exp = 5.506
exponent_range = max_freq_exp - min_freq_exp
log_range = log_max - log_min
for i, (x_new, y_new, label) in enumerate(curves):
    x_end = x_new[-1]
    y_end = y_new[-1]
    x_start = x_end
    y_start = start_y
    angle = np.deg2rad(wedge_angles[i])
    x_flag = x_start + flag_length * np.cos(angle)
    y_flag = y_start + flag_length * np.sin(angle)
    exponent = mersenne_exponents[i]
    scaled_exponent = min_freq_exp + (np.log(exponent) - log_min) / log_range * exponent_range
    freq = 440 * 2**scaled_exponent
    harmonic_frequencies.append(freq)
    flag_positions.append((x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq))
    angle_deg = wedge_angles[i]
    if (angle_deg - 90) % 5 == 0:
        angle_rad = np.deg2rad(angle_deg)
        x_marker = x_start + (flag_length * 0.5) * np.cos(angle_rad)
        y_marker = y_start + (flag_length * 0.5) * np.sin(angle_rad)
        circle_markers.append((x_marker, y_marker))
# Global variables for interactive modes
protractor_active = False
ruler_active = False
draw_mode = False
dimension_active = False
pro_mode = False
is_closed = False
selected_curve = None
hidden_elements = []
protractor_points = []
protractor_line = None
protractor_text = None
ruler_points = []
ruler_line = None
ruler_text = None
dimension_labels = []
drawing_points = [] # Kappa nodes (first endpoint of each greenchord)
kappas = [] # Kappa values at each node
node_scatter = [] # List of scatter objects for kappa nodes
original_colors = [] # List to store original colors of nodes
selected_node_index = -1
dragging = False
ghost_handles = [] # List for theta ghost handles
green_curve_line = None # Single plot object for the interoperated greencurve
CLOSE_THRESHOLD = 0.05 # Distance to first point to consider closing
SNAP_THRESHOLD = 0.05 # Threshold for snapping to dividers (UX improvement)
vanishing_points = [] # Vanishing points for each triangulation
previous_kappa = 1.0 # Initial kappa for decay
curvature = 1.0 # Initial curvature (kappa)
height = 0.5 # Initial height for 3D model
num_rings = 20 # Number of loft rings
fractal_level = 3 # Fractal level for flowers
radial_chord = 0.5 # Radial chord for flower
tangential_chord = 0.2 # Tangential chord for flower
height_chord = 0.1 # Height chord for flower
current_vertices = None
current_faces = None
last_angle = 0.0 # Last measured angle from protractor
show_harmonics = False
harmonic_texts = []
annotation_objects = []
# Pre-compute kappa grid
kappa_grid = compute_kappa_grid(grid_size=100)
# Fractal Flower Mesh with guide curves using diameter logic
def fractal_flower(center, scale, level, all_polygons, all_guide_curves, rotation_angle=0.0):
    """
    Recursively generates flower-shaped polygons for the surface.
    Collects all base-level flower polygons in all_polygons (list of list of [x,y,z]).
    Uses 36 points for better flower resolution with curved petals.
    Applies rotation to the points.
    Adds guide curves from petal to petal control points using diameter logic (connecting opposite petals).
    Args:
        center: [x, y, z] center of the flower.
        scale: Scale factor for the flower size.
        level: Current recursion depth.
        all_polygons: List to collect all base flower polygons.
        all_guide_curves: List to collect guide curves (list of [p1, p2] pairs for lines).
        rotation_angle: Rotation angle in radians for the flower.
    """
    rot_cos = np.cos(rotation_angle)
    rot_sin = np.sin(rotation_angle)
    num_points = 37 # 36 points for higher resolution
    t = np.linspace(0, 2 * np.pi, num_points)[:-1]
    r = scale * (radial_chord + tangential_chord * np.sin(6 * t)) # 6 petals, use sin for symmetry if needed
    dx = r * np.cos(t)
    dy = r * np.sin(t)
    dz = scale * height_chord * np.cos(6 * t) # Curved z for surface
    # Apply rotation to dx, dy (around z)
    x_rot = center[0] + dx * rot_cos - dy * rot_sin
    y_rot = center[1] + dx * rot_sin + dy * rot_cos
    z_rot = center[2] + dz
    polygon = [[x_rot[j], y_rot[j], z_rot[j]] for j in range(len(t))]
    all_polygons.append(polygon)
    # Add guide curves using diameter logic (connect opposite points for each petal pair)
    num_petals = 6
    points_per_petal = len(t) // num_petals
    for p in range(num_petals // 2): # Pair opposite petals (0-3, 1-4, 2-5)
        petal1_start = p * points_per_petal
        petal2_start = (p + num_petals // 2) * points_per_petal
        # Take midpoint control points of each petal
        petal1_mid = petal1_start + points_per_petal // 2
        petal2_mid = petal2_start + points_per_petal // 2
        p1 = polygon[petal1_mid]
        p2 = polygon[petal2_mid]
        all_guide_curves.append([p1, p2]) # Add line between control points
    if level == 0:
        return
    # Add smaller flowers at petal tips
    small_scale = scale / PHI # Golden ratio scale
    for i in range(6):
        theta = i * (2 * np.pi / 6)
        tip_r = scale * (radial_chord + tangential_chord) # Max r for tip
        tip_dx = tip_r * np.cos(theta)
        tip_dy = tip_r * np.sin(theta)
        tip_dz = scale * height_chord
        # Rotate tip offset
        tip_x = center[0] + tip_dx * rot_cos - tip_dy * rot_sin
        tip_y = center[1] + tip_dx * rot_sin + tip_dy * rot_cos
        tip_z = center[2] + tip_dz
        tip_center = [tip_x, tip_y, tip_z]
        fractal_flower(tip_center, small_scale, level - 1, all_polygons, all_guide_curves, rotation_angle + np.pi)
# Triangulate polygon for rendering (fan triangulation)
def triangulate_poly(poly):
    tris = []
    for i in range(1, len(poly) - 1):
        tris.append([poly[0], poly[i], poly[i+1]])
    return tris
# Hash entropy for lower surface
def hash_entropy(p):
    h_str = f"{p[0]:.6f}{p[1]:.6f}{p[2]:.6f}"
    h = int(hashlib.sha256(h_str.encode()).hexdigest(), 16) % 1000 / 1000.0 * 0.05 - 0.025
    return h
# Build mesh using fractal flower (ties to curve by scaling to curve length)
def build_mesh(x_curve, y_curve, z_curve=None, height=0.5, num_rings=20, num_points=None, fractal_level=3):
    """
    Builds two surfaces meeting at the 3D curve with vertical tangent, inheriting each other's curvature in transition.
    Integrates fractal flower for complex surface detail on caps, scaled by curve length.
    Uses flower modulation in loft rings for interlacing petals.
    Now collects guide curves from petal to petal and adds them as edges in the mesh.
    Args:
        x_curve, y_curve, z_curve: Curve coordinates.
        height: Height for lofting.
        num_rings: Number of rings for loft.
        num_points: Number of points to sample curve.
        fractal_level: Recursion level for fractal flower.
    Returns:
        vertices (np.array): Array of [x, y, z].
        faces (list): List of [idx1, idx2, idx3].
    """
    if num_points is not None:
        indices = np.linspace(0, len(x_curve) - 1, num_points, dtype=int)
        x_curve = x_curve[indices]
        y_curve = y_curve[indices]
        if z_curve is not None:
            z_curve = z_curve[indices]
    n = len(x_curve)
    if z_curve is None:
        z_curve = np.zeros(n) # Default to flat if no z provided
    # Use node 2 as datum when closed
    center_x = drawing_points[1][0] if is_closed and len(drawing_points) > 1 else drawing_points[0][0] if drawing_points else np.mean(x_curve)
    center_y = drawing_points[1][1] if is_closed and len(drawing_points) > 1 else drawing_points[0][1] if drawing_points else np.mean(y_curve)
    vertices = []
    faces = []
    # Parting line on 3D curve
    parting_base = len(vertices)
    for i in range(n):
        vertices.append([x_curve[i], y_curve[i], z_curve[i]])
    # Upper surface: rings inward with vertical tangent at edge and flower modulation
    upper_bases = [parting_base]
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2 # Vertical tangent at s=0 (dr/ds=0)
        g_val = (height / 2) * s**2 # Quadratic for constant curvature
        base = len(vertices)
        upper_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = 0.0 # Upper phase
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s # Modulation increases inward
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) + g_val + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_upper_idx = len(vertices)
    vertices.append([center_x, center_y, height / 2])
    # Lower surface: mirrored with phase offset for interlacing and entropy
    lower_bases = [parting_base] # Shared edge
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2
        g_val = (height / 2) * s**2 # Quadratic for constant curvature (sign same for inheritance magnitude)
        base = len(vertices)
        lower_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = np.pi / 6 # Lower phase offset for interlacing
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) - g_val + hash_entropy([x, y, z]) + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_lower_idx = len(vertices)
    vertices.append([center_x, center_y, -height / 2])
    # Faces for upper surface
    for ll in range(len(upper_bases) - 1):
        base = upper_bases[ll]
        next_base = upper_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, base + next_i, next_base + next_i])
            faces.append([base + i, next_base + next_i, next_base + i])
    # Faces for lower surface
    for ll in range(len(lower_bases) - 1):
        base = lower_bases[ll]
        next_base = lower_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, next_base + i, next_base + next_i])
            faces.append([base + i, next_base + next_i, base + next_i])
    # Integrate fractal flower for caps (no fan, use flower fractals)
    # Compute curve length for scale
    curve_length = np.sum(np.sqrt(np.diff(x_curve)**2 + np.diff(y_curve)**2))
    flower_scale = curve_length * 0.1 if curve_length > 0 else 0.5 # Scale to curve
    all_polygons = [] # List of list of [x,y,z] for each polygon
    all_guide_curves = [] # New: Collect guide curve pairs
    # Upper cap flower
    fractal_flower(vertices[center_upper_idx], flower_scale, fractal_level, all_polygons, all_guide_curves, rotation_angle=np.pi)
    # Lower cap flower
    fractal_flower(vertices[center_lower_idx], flower_scale, fractal_level, all_polygons, all_guide_curves, rotation_angle=np.pi)
    # Add polygons to mesh (triangulate for rendering)
    for poly in all_polygons:
        base_idx = len(vertices)
        vertices.extend(poly)
        for tri in triangulate_poly(range(len(poly))):
            faces.append([base_idx + tri[0], base_idx + tri[1], base_idx + tri[2]])
    # Add guide curves as edges (simple lines, add as degenerate faces or separate for visualization)
    for guide in all_guide_curves:
        base_idx = len(vertices)
        vertices.append(guide[0])
        vertices.append(guide[1])
        faces.append([base_idx, base_idx + 1, base_idx + 1]) # Degenerate tri for line (visual only)
    # Convert to numpy array
    vertices = np.array(vertices)
    # Snap to integers if hash ends with 0
    for i in range(len(vertices)):
        v = vertices[i]
        h_str = f"{v[0]:.6f}{v[1]:.6f}{v[2]:.4f}"
        h = hashlib.sha256(h_str.encode()).hexdigest()[-1]
        if h == '0':
            vertices[i] = np.round(vertices[i])
    # Add compound curvature modulation with angle and 3D kappa grid for smooth orthographic projections
    grid_size, _, num_angles = kappa_grid.shape
    angle_idx = int((last_angle / 360) * num_angles) % num_angles
    kappa_slice = kappa_grid[:, :, angle_idx]
    # Normalize vertices to -1 to 1 for grid mapping (assuming curve bounds approx [0, WIDTH] x [0, HEIGHT])
    max_dim = max(np.max(np.abs(vertices[:, 0])), np.max(np.abs(vertices[:, 1])))
    norm_x = np.clip(((vertices[:, 0] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    norm_y = np.clip(((vertices[:, 1] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    kappa_mod = kappa_slice[norm_y, norm_x]
    vertices[:, 2] += kappa_mod * 0.1 # Scale z modulation
    vertices[:, 0] += kappa_mod * 0.05 * np.sin(2 * np.pi * vertices[:, 2] / height) # Compound in x
    vertices[:, 1] += kappa_mod * 0.05 * np.cos(2 * np.pi * vertices[:, 2] / height) # Compound in y
    # Make flowers sacrificial: remove flower faces after modulation (assume last added are flowers)
    flower_face_start = len(faces) - len(all_polygons) * 35 # Adjusted for 36 points per flower (approx 35 triangles)
    faces = faces[:flower_face_start]
    return vertices, faces
# NURBS basis function
def nurbs_basis(u, i, p, knots):
    if p == 0:
        return 1.0 if knots[i] <= u <= knots[i+1] else 0.0 # Include = for end
    if knots[i+p] == knots[i]:
        c1 = 0.0
    else:
        c1 = (u - knots[i]) / (knots[i+p] - knots[i]) * nurbs_basis(u, i, p-1, knots)
    if knots[i+p+1] == knots[i+1]:
        c2 = 0.0
    else:
        c2 = (knots[i+p+1] - u) / (knots[i+p+1] - knots[i+1]) * nurbs_basis(u, i+1, p-1, knots)
    return c1 + c2
# Compute NURBS curve point
def nurbs_curve_point(u, control_points, weights, p, knots):
    n = len(control_points) - 1
    x = 0.0
    y = 0.0
    denom = 0.0
    for i in range(n + 1):
        b = nurbs_basis(u, i, p, knots)
        denom += b * weights[i]
        x += b * weights[i] * control_points[i][0]
        y += b * weights[i] * control_points[i][1]
    if denom == 0:
        return 0, 0
    return x / denom, y / denom
# Generate NURBS curve
def generate_nurbs_curve(points, weights, p, knots, num_points=1000):
    u_min, u_max = knots[p], knots[-p-1]
    u_values = np.linspace(u_min, u_max, num_points, endpoint=False)
    curve = [nurbs_curve_point(u, points, weights, p, knots) for u in u_values]
    curve.append(curve[0]) # Append first point for exact closure
    return np.array([list(pt) for pt in curve]) # Convert to np.array of shape (num_points+1, 2)
# Compute golden spiral
def compute_golden_spiral():
    theta = np.linspace(0, 10 * np.pi, 1000)
    r = A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Scale down to fit within page bounds
    scale_factor = min(WIDTH, HEIGHT) / (2 * np.max(np.abs([x, y]))) * 0.8 # 80% of max to fit comfortably
    x *= scale_factor
    y *= scale_factor
    return x, y
def bspline_basis(u, i, p, knots):
    if p == 0:
        if i < 0 or i + 1 >= len(knots):
            return 0.0
        return 1.0 if knots[i] <= u <= knots[i + 1] else 0.0
  
    if i < 0 or i >= len(knots) - 1:
        return 0.0
  
    term1 = 0.0
    if i + p < len(knots):
        den1 = knots[i + p] - knots[i]
        if den1 > 0:
            term1 = ((u - knots[i]) / den1) * bspline_basis(u, i, p - 1, knots)
  
    term2 = 0.0
    if i + p + 1 < len(knots):
        den2 = knots[i + p + 1] - knots[i + 1]
        if den2 > 0:
            term2 = ((knots[i + p + 1] - u) / den2) * bspline_basis(u, i + 1, p - 1, knots)
  
    return term1 + term2
def bspline_basis_periodic(u, i, p, knots, n):
    i = i % n
    if p == 0:
        k0 = knots[i % len(knots)]
        k1 = knots[(i + 1) % len(knots)]
        if k0 > k1:  # Wrap-around interval
            return 1.0 if u >= k0 or u < k1 else 0.0
        else:
            return 1.0 if k0 <= u < k1 else 0.0
    k_i = knots[i % len(knots)]
    k_ip = knots[(i + p) % len(knots)]
    den1 = k_ip - k_i
    if den1 < 0:
        den1 += 1.0  # Adjust for wrap-around
    term1 = 0.0
    if den1 > 0:
        term1 = ((u - k_i) / den1) * bspline_basis_periodic(u, i, p - 1, knots, n)
    k_i1 = knots[(i + 1) % len(knots)]
    k_ip1 = knots[(i + p + 1) % len(knots)]
    den2 = k_ip1 - k_i1
    if den2 < 0:
        den2 += 1.0  # Adjust for wrap-around
    term2 = 0.0
    if den2 > 0:
        term2 = ((k_ip1 - u) / den2) * bspline_basis_periodic(u, i + 1, p - 1, knots, n)
    return term1 + term2
# Custom interoperations for greencurve using NURBS with local kappa adjustment for closure
def custom_interoperations_green_curve(points, kappas, is_closed=False):
    """
    Custom Non-Uniform Rational Kappa Spline (NURKS) approximation for green curve with closure adjustments.
    For closed curves, extends control points on both sides and shifts knot vector for smooth periodicity.
    """
    points = np.array(points)
    kappas = np.array(kappas)
    degree = 3 # Fixed degree for continuity
    num_output_points = 1000
  
    if is_closed and len(points) > degree:
        n = len(points)
        extended_points = np.concatenate((points[n-degree:], points, points[0:degree]))
        extended_kappas = np.concatenate((kappas[n-degree:], kappas, kappas[0:degree]))
        len_extended = len(extended_points)
        knots = np.linspace(-degree / float(n), 1 + degree / float(n), len_extended + 1)
  
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
  
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
  
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len_extended):
                b = bspline_basis(u, i, degree, knots)
                w = extended_kappas[i] * b
                num_x += w * extended_points[i, 0]
                num_y += w * extended_points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
  
        smooth_x = np.append(smooth_x, smooth_x[0])
        smooth_y = np.append(smooth_y, smooth_y[0])
  
    else:
        # Cumsum of distances for open
        t = np.cumsum([0] + [np.linalg.norm(points[i+1] - points[i]) for i in range(len(points)-1)])
        knots = np.concatenate(([0] * (degree + 1), t / t[-1] if t[-1] > 0 else np.linspace(0, 1, len(t)), [1] * (degree)))
  
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
  
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
  
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len(points)):
                b = bspline_basis(u, i, degree, knots)
                w = kappas[i] * b if i < len(kappas) else kappas[-1] * b
                num_x += w * points[i, 0]
                num_y += w * points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
  
    return smooth_x, smooth_y
# Compute kappa for a segment, second endpoint influences next kappa
def compute_segment_kappa(p1, p2, base_kappa=1.0, prev_kappa=1.0):
    x1, y1 = p1
    x2, y2 = p2
    theta = np.sqrt((x2 - x1)**2 + (y2 - y1)**2) # Theta is distance
    if theta < 1e-10:
        return prev_kappa
    decay_factor = np.exp(-theta / WIDTH / 20.0) # Further reduced decay rate
    return prev_kappa * decay_factor * base_kappa
# Recalculate kappas after changes (e.g., closure or node move) for consistency
def recalculate_kappas():
    global previous_kappa
    previous_kappa = kappas[0] # Start with first kappa
    for i in range(1, len(drawing_points)):
        kappas[i] = compute_segment_kappa(drawing_points[i-1], drawing_points[i], curvature, previous_kappa)
        previous_kappa = kappas[i]
# Update 3D model on changes (e.g., height slider or curve update)
def update_3d_model():
    global current_vertices, current_faces
    if green_curve_line:
        x_curve, y_curve = green_curve_line.get_data()
        if is_closed and np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)), height=height)
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
# Golden window calculation
def compute_golden_window(x_spiral, y_spiral):
    idx_crossings = np.where(np.diff(np.sign(x_spiral - PURPLE_LINES[0] * WIDTH)))[0]
    if len(idx_crossings) >= 2:
        y1 = y_spiral[idx_crossings[0]]
        y2 = y_spiral[idx_crossings[1]]
        return np.abs(y2 - y1), min(y1, y2), max(y1, y2)
    return 0, 0, 0
# Compute vanishing point for a triangulation
def compute_vanishing_point(tri_points, eye_distance=EYE_DISTANCE):
    mid_x = np.mean([p[0] for p in tri_points])
    mid_y = np.mean([p[1] for p in tri_points])
    vx = mid_x
    vy = HORIZON_HEIGHT + eye_distance * (mid_y - EYE_LINE) / WIDTH
    return vx, vy
# Redraw green curve
def redraw_green_curve(is_closed=False):
    global green_curve_line
    if green_curve_line:
        green_curve_line.remove()
        green_curve_line = None
    if len(drawing_points) >= 2:
        adjusted_kappas = kappas.copy()
        if is_closed and len(adjusted_kappas) > 1:
            adjusted_kappas[1] = 1.5 * adjusted_kappas[1] # Local kappa adjustment for ellipse conditions
        x_green, y_green = custom_interoperations_green_curve(drawing_points, adjusted_kappas, is_closed=is_closed)
        green_curve_line, = ax_2d.plot(x_green, y_green, 'g-', label='Green Curve' if green_curve_line is None else None)
    fig_2d.canvas.draw()
# Setup figures
fig_2d = plt.figure(figsize=(14, 8))
ax_2d = fig_2d.add_subplot(111)
fig_3d = plt.figure(figsize=(10, 6))
ax_3d = fig_3d.add_subplot(111, projection='3d')
fig_controls = plt.figure(figsize=(4, 8))
ax_curvature = fig_controls.add_axes([0.2, 0.8, 0.6, 0.03])
curvature_slider = Slider(ax_curvature, 'Curvature (kappa)', 0.1, 2.0, valinit=curvature)
ax_height = fig_controls.add_axes([0.2, 0.7, 0.6, 0.03])
height_slider = Slider(ax_height, 'Height', 0.1, 2.0, valinit=height)
ax_rings = fig_controls.add_axes([0.2, 0.6, 0.6, 0.03])
rings_slider = Slider(ax_rings, 'Rings', 5, 50, valinit=num_rings, valstep=1)
ax_level = fig_controls.add_axes([0.2, 0.5, 0.6, 0.03])
level_slider = Slider(ax_level, 'Fractal Level', 0, 5, valinit=fractal_level, valstep=1)
ax_radial = fig_controls.add_axes([0.2, 0.4, 0.6, 0.03])
radial_slider = Slider(ax_radial, 'Radial Chord', 0.1, 1.0, valinit=radial_chord)
ax_tangential = fig_controls.add_axes([0.2, 0.3, 0.6, 0.03])
tangential_slider = Slider(ax_tangential, 'Tangential Chord', 0.0, 0.5, valinit=tangential_chord)
ax_height_chord = fig_controls.add_axes([0.2, 0.2, 0.6, 0.03])
height_chord_slider = Slider(ax_height_chord, 'Height Chord', 0.0, 0.5, valinit=height_chord)
# Plot A3 page
ax_2d.plot([0, WIDTH, WIDTH, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k-', label='A3 Landscape Page')
for x in PURPLE_LINES:
    ax_2d.plot([x * WIDTH, x * WIDTH], [0, HEIGHT], 'm-', label='Purple Dividers' if x == PURPLE_LINES[0] else None)
# Horizon line
horizon_line, = ax_2d.plot([0, WIDTH], [HORIZON_HEIGHT, HORIZON_HEIGHT], 'b:', label='Horizon/Eye Line')
# Golden spiral
x_spiral, y_spiral = compute_golden_spiral()
golden_spiral, = ax_2d.plot(x_spiral + WIDTH/2, y_spiral + HEIGHT/2, 'gold', label='Golden Spiral')
# Golden window
golden_window, y_min, y_max = compute_golden_window(x_spiral + WIDTH/2, y_spiral + HEIGHT/2)
ax_2d.fill_between([PURPLE_LINES[0] * WIDTH - 0.05, PURPLE_LINES[0] * WIDTH + 0.05], y_min, y_max, color='yellow', alpha=0.5, label='Golden Window')
# Ghost curve init
ghost_curve, = ax_2d.plot([], [], 'g--', label='Ghost Curve Preview')
# Control indicators in legend
ax_2d.plot([], [], ' ', label='R: Toggle draw mode')
ax_2d.plot([], [], 'b--', label='A: Toggle protractor')
ax_2d.plot([], [], 'c-', label='M: Toggle measure (ruler)')
ax_2d.plot([], [], ' ', label='D: Toggle dimension')
ax_2d.plot([], [], 'r-', label='C: Close polyhedron (manual)')
ax_2d.plot([], [], ' ', label='Click near first point to close')
ax_2d.plot([], [], ' ', label='Click to select curve')
ax_2d.plot([], [], ' ', label='G: To construction geom')
ax_2d.plot([], [], ' ', label='H: Hide/show')
ax_2d.plot([], [], ' ', label='E: Reset canvas')
ax_2d.plot([], [], ' ', label='S: Export STL')
ax_2d.plot([], [], 'k-', label='Curvature Slider (Controls window)')
# Update curvature
def update_curvature(val):
    global curvature
    curvature = val
    if len(drawing_points) >= 1:
        kappas[-1] = curvature
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
    fig_2d.canvas.draw()
curvature_slider.on_changed(update_curvature)
# Update height
def update_height(val):
    global height
    height = val
    if is_closed:
        update_3d_model()
height_slider.on_changed(update_height)
# Update rings
def update_rings(val):
    global num_rings
    num_rings = int(val)
    if is_closed:
        update_3d_model()
rings_slider.on_changed(update_rings)
# Update fractal level
def update_level(val):
    global fractal_level
    fractal_level = int(val)
    if is_closed:
        update_3d_model()
level_slider.on_changed(update_level)
# Update radial chord
def update_radial(val):
    global radial_chord
    radial_chord = val
    if is_closed:
        update_3d_model()
radial_slider.on_changed(update_radial)
# Update tangential chord
def update_tangential(val):
    global tangential_chord
    tangential_chord = val
    if is_closed:
        update_3d_model()
tangential_slider.on_changed(update_tangential)
# Update height chord
def update_height_chord(val):
    global height_chord
    height_chord = val
    if is_closed:
        update_3d_model()
height_chord_slider.on_changed(update_height_chord)
# Toggle draw mode
def toggle_draw(event):
    global draw_mode
    if event.key == 'r':
        draw_mode = not draw_mode
        print(f"Draw mode {'enabled' if draw_mode else 'disabled'}")
        fig_2d.canvas.draw()
# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        if not protractor_active:
            if protractor_line:
                protractor_line.remove()
                protractor_line = None
            if protractor_text:
                protractor_text.remove()
                protractor_text = None
            protractor_points.clear()
        fig_2d.canvas.draw()
# On click for protractor
def on_click_protractor(event):
    global protractor_line, protractor_text, last_angle
    if protractor_active and event.inaxes == ax_2d and event.button == 1:
        protractor_points.append((event.xdata, event.ydata))
        if len(protractor_points) == 2:
            x1, y1 = protractor_points[0]
            x2, y2 = protractor_points[1]
            if protractor_line:
                protractor_line.remove()
            protractor_line, = ax_2d.plot([x1, x2], [y1, y2], 'b--')
            dx = x2 - x1
            dy = y2 - y1
            angle = np.arctan2(dy, dx) * 180 / np.pi
            last_angle = angle
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if protractor_text:
                protractor_text.remove()
            protractor_text = ax_2d.text(mid_x, mid_y, f'Angle: {angle:.2f}°', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            protractor_points.clear()
            fig_2d.canvas.draw()
# Toggle ruler (measure)
def toggle_ruler(event):
    global ruler_active
    if event.key == 'm':
        ruler_active = not ruler_active
        print(f"Measure (ruler) tool {'enabled' if ruler_active else 'disabled'}")
        if not ruler_active:
            if ruler_line:
                ruler_line.remove()
                ruler_line = None
            if ruler_text:
                ruler_text.remove()
                ruler_text = None
            ruler_points.clear()
        fig_2d.canvas.draw()
# On click for ruler
def on_click_ruler(event):
    global ruler_line, ruler_text
    if ruler_active and event.inaxes == ax_2d and event.button == 1:
        ruler_points.append((event.xdata, event.ydata))
        if len(ruler_points) == 2:
            x1, y1 = ruler_points[0]
            x2, y2 = ruler_points[1]
            if ruler_line:
                ruler_line.remove()
            ruler_line, = ax_2d.plot([x1, x2], [y1, y2], 'c-')
            dx = x2 - x1
            dy = y2 - y1
            dist = np.sqrt(dx**2 + dy**2)
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if ruler_text:
                ruler_text.remove()
            ruler_text = ax_2d.text(mid_x, mid_y, f'Dist: {dist:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            ruler_points.clear()
            fig_2d.canvas.draw()
# Toggle dimension
def toggle_dimension(event):
    global dimension_active
    if event.key == 'd':
        dimension_active = not dimension_active
        print(f"Dimension tool {'enabled' if dimension_active else 'disabled'}")
        fig_2d.canvas.draw()
# On click for dimension
def on_click_dimension(event):
    if dimension_active and event.inaxes == ax_2d and event.button == 1:
        if ruler_active and ruler_text:
            dimension_labels.append(ruler_text)
        elif selected_curve:
            x, y = selected_curve.get_data()
            length = np.sum(np.sqrt(np.diff(x)**2 + np.diff(y)**2))
            mid_x = np.mean(x)
            mid_y = np.mean(y)
            dim_text = ax_2d.text(mid_x, mid_y + 0.05, f'Len: {length:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            dimension_labels.append(dim_text)
        fig_2d.canvas.draw()
# Toggle pro mode (lock/unlock)
def toggle_pro_mode(event):
    global pro_mode
    if event.key == 'x':
        pro_mode = not pro_mode
        print(f"Pro mode {'locked' if pro_mode else 'unlocked'}")
        fig_2d.canvas.draw()
# On pick event for nodes
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow') # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()
# Show ghost handles (theta points, midpoints between nodes)
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow') # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()
# Show ghost handles (theta points, midpoints between nodes)
def show_ghost_handles():
    global ghost_handles
    for handle in ghost_handles:
        handle.remove()
    ghost_handles = []
    num_points = len(drawing_points) if not is_closed else len(drawing_points) - 1 # Avoid double midpoint on close
    for i in range(num_points):
        next_i = (i + 1) % len(drawing_points) if is_closed else i + 1
        if next_i >= len(drawing_points):
            continue
        mid_x = (drawing_points[i][0] + drawing_points[next_i][0]) / 2
        mid_y = (drawing_points[i][1] + drawing_points[next_i][1]) / 2
        handle = ax_2d.scatter(mid_x, mid_y, color='yellow', s=30, marker='o')
        ghost_handles.append(handle)
    fig_2d.canvas.draw()
# On button press for dragging
def on_button_press(event):
    global dragging
    if pro_mode and selected_node_index != -1 and event.inaxes == ax_2d and event.button == 1:
        dragging = True
# On button release for dragging
def on_button_release(event):
    global dragging
    dragging = False
# On motion for dragging and preview
def on_motion(event):
    global previous_kappa, dragging, selected_node_index
    if dragging and pro_mode and selected_node_index != -1 and event.inaxes == ax_2d:
        drawing_points[selected_node_index] = (event.xdata, event.ydata)
        node_scatter[selected_node_index].set_offsets([[event.xdata, event.ydata]])
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
        fig_2d.canvas.draw()
        return
    if draw_mode and len(drawing_points) > 0 and event.inaxes == ax_2d and not (protractor_active or ruler_active or dimension_active):
        x, y = event.xdata, event.ydata
        preview_points = drawing_points + [(x, y)]
        preview_kappas = kappas + [curvature]
        close_preview = False
        if len(preview_points) > 2:
            dx_first = x - drawing_points[0][0]
            dy_first = y - drawing_points[0][1]
            dist_first = np.sqrt(dx_first**2 + dy_first**2)
            if dist_first < CLOSE_THRESHOLD:
                preview_points[-1] = drawing_points[0]
                preview_kappas[-1] = curvature
                # Preview kappa1 adjustment for closure
                last_theta = np.sqrt((drawing_points[-1][0] - preview_points[-1][0])**2 + (drawing_points[-1][1] - preview_points[-1][1])**2)
                if last_theta < 1e-10: # Manage '0' snap error in preview
                    last_theta = 1e-10
                decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                preview_kappas[0] = preview_kappas[-1] * decay_factor * curvature
                close_preview = True
        # Compute kappa for preview segment (cursor at theta)
        if len(preview_points) > 1:
            preview_kappa = compute_segment_kappa(preview_points[-2], preview_points[-1], curvature, previous_kappa)
            preview_kappas[-1] = preview_kappa
        x_ghost, y_ghost = custom_interoperations_green_curve(preview_points, preview_kappas, is_closed=close_preview)
        ghost_curve.set_data(x_ghost, y_ghost)
        fig_2d.canvas.draw()
# Generate G-code for the curve with variable speeds (for 2D plotting/CNC, scaled to mm)
def generate_gcode(x, y, speeds, scale=297):
    """
    Generates simple G-code for linear moves along the curve with variable feedrates.
    Args:
        x (array): X coordinates (normalized).
        y (array): Y coordinates (normalized).
        speeds (list): Normalized speeds (0-1) for each point.
        scale (float): Scale factor to convert normalized units to mm (based on A3 height=297mm).
    Returns:
        str: G-code string.
    """
    gcode = "G21 ; Set units to millimeters\n"
    gcode += "G90 ; Absolute positioning\n"
    # Move to start position (rapid)
    gcode += f"G0 X{x[0] * scale:.2f} Y{y[0] * scale:.2f}\n"
    # Linear moves with varying feedrate
    for i in range(1, len(x)):
        feedrate = speeds[i] * 900 + 100 # Scale speed to 100-1000 mm/min
        gcode += f"G1 X{x[i] * scale:.2f} Y{y[i] * scale:.2f} F{feedrate:.0f}\n"
    return gcode
# Drawing mode: Add kappa nodes and update continuous greencurve
def on_click_draw(event):
    global green_curve_line, selected_curve, previous_kappa, vanishing_points, current_vertices, current_faces, is_closed
    if event.inaxes == ax_2d and event.button == 1:
        x, y = event.xdata, event.ydata
        # Snap to dividers if close (UX improvement for precise alignment)
        for div in PURPLE_LINES:
            div_x = div * WIDTH
            if abs(x - div_x) < SNAP_THRESHOLD:
                x = div_x
                break
        if draw_mode and not (protractor_active or ruler_active or dimension_active):
            # Check if near first point to close
            if len(drawing_points) > 2:
                dx_first = x - drawing_points[0][0]
                dy_first = y - drawing_points[0][1]
                dist_first = np.sqrt(dx_first**2 + dy_first**2)
                if dist_first < CLOSE_THRESHOLD:
                    # Adjust kappa1 based on last theta and kappa
                    last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
                    if last_theta < 1e-10: # Manage '0' snap error
                        last_theta = 1e-10
                    decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                    kappas[0] = kappas[-1] * decay_factor * curvature # Affect kappa1 with last kappa and decay
                    drawing_points.append(drawing_points[0])
                    kappas.append(kappas[0]) # Last kappa inherits first kappa's theta (via same value)
                    recalculate_kappas() # Recalculate for closure consistency
                    is_closed = True
                    redraw_green_curve(is_closed=True) # Use closed NURKS for ellipse conditions
                    # Get closed curve
                    x_curve, y_curve = green_curve_line.get_data()
                    if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
                        x_curve = np.append(x_curve, x_curve[0])
                        y_curve = np.append(y_curve, y_curve[0])
                    ax_3d.cla()
                    current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
                    verts = [[current_vertices[i] for i in f] for f in current_faces]
                    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
                    ax_3d.set_xlabel('X')
                    ax_3d.set_ylabel('Y')
                    ax_3d.set_zlabel('Z')
                    ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
                    fig_3d.canvas.draw()
                    print("Polyhedron closed and 3D model generated")
                    # Compute and print speeds for user generated curve
                    print("User Generated Curve Speeds:")
                    speeds = []
                    for i in range(len(x_curve)):
                        speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
                        print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
                        speeds.append(speed)
                    # Generate G-Code
                    gcode = generate_gcode(x_curve, y_curve, speeds)
                    with open('model.gcode', 'w') as f:
                        f.write(gcode)
                    print("G-Code saved to model.gcode")
                    print(gcode)
                    fig_2d.canvas.draw()
                    return
            # Add new kappa node (first endpoint)
            roygbiv = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
            color = roygbiv[len(drawing_points) % 7]
            node = ax_2d.scatter(x, y, color=color, s=50, picker=True, label='Kappa Node' if len(drawing_points) == 0 else None)
            node_scatter.append(node)
            original_colors.append(color)
            drawing_points.append((x, y))
            kappas.append(curvature)
            if len(drawing_points) > 1:
                previous_kappa = compute_segment_kappa(drawing_points[-2], drawing_points[-1], curvature, previous_kappa)
                redraw_green_curve(is_closed=is_closed)
                if len(drawing_points) >= 2:
                    t = np.linspace(0, 1, 100)
                    x_green, y_green = green_curve_line.get_data()
                    curv = compute_curvature(x_green, y_green, t)
                    print(f"Green curve curvature: Max={curv.max():.4f}, Min={curv.min():.4f}")
            if len(drawing_points) >= 3:
                print("Third point added: Introducing depth and triangulation")
                tri_points = drawing_points[-3:]
                vp = compute_vanishing_point(tri_points)
                vanishing_points.append(vp)
                ax_2d.scatter(vp[0], vp[1], color='purple', s=30, label='Vanishing Point' if len(vanishing_points) == 1 else None)
            fig_2d.canvas.draw()
        elif not draw_mode and not (protractor_active or ruler_active or dimension_active):
            min_dist = float('inf')
            selected_curve = None
            if green_curve_line:
                x_curve, y_curve = green_curve_line.get_data()
                dist = np.min(np.sqrt((x_curve - x)**2 + (y_curve - y)**2))
                if dist < min_dist and dist < 0.05:
                    min_dist = dist
                    selected_curve = green_curve_line
            if selected_curve:
                selected_curve.set_linewidth(3.0)
                print("Green curve selected")
                fig_2d.canvas.draw()
# Close polyhedron (manual trigger)
def close_polyhedron(event):
    if event.key == 'c':
        print("Close via clicking near first point when ghosted")
# Auto close on 'c'
def auto_close(event):
    global is_closed, drawing_points, kappas, previous_kappa
    if event.key == 'c' and len(drawing_points) > 2:
        # Adjust kappa1 based on last theta and kappa
        last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
        if last_theta < 1e-10: # Manage '0' snap error
            last_theta = 1e-10
        decay_factor = np.exp(-last_theta / WIDTH / 20.0)
        kappas[0] = kappas[-1] * decay_factor * curvature # Affect kappa1 with last kappa and decay
        drawing_points.append(drawing_points[0])
        kappas.append(kappas[0]) # Last kappa inherits first kappa's theta (via same value)
        recalculate_kappas() # Recalculate for closure consistency
        is_closed = True
        redraw_green_curve(is_closed=True) # Use closed NURKS for ellipse conditions
        # Get closed curve
        x_curve, y_curve = green_curve_line.get_data()
        if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
        print("Polyhedron closed and 3D model generated")
        # Compute and print speeds for user generated curve
        print("User Generated Curve Speeds:")
        speeds = []
        for i in range(len(x_curve)):
            speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
            print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
            speeds.append(speed)
        # Generate G-Code
        gcode = generate_gcode(x_curve, y_curve, speeds)
        with open('model.gcode', 'w') as f:
            f.write(gcode)
        print("G-Code saved to model.gcode")
        print(gcode)
        fig_2d.canvas.draw()
# Change to construction geometry
def to_construction(event):
    global selected_curve
    if event.key == 'g' and selected_curve:
        selected_curve.set_linestyle('--')
        selected_curve.set_color('gray')
        print("Green curve changed to construction geometry")
        selected_curve = None
        fig_2d.canvas.draw()
# Hide/show
def hide_show(event):
    global hidden_elements, selected_curve
    if event.key == 'h':
        if selected_curve:
            if selected_curve.get_visible():
                selected_curve.set_visible(False)
                hidden_elements.append(selected_curve)
                print("Green curve hidden")
            else:
                selected_curve.set_visible(True)
                if selected_curve in hidden_elements:
                    hidden_elements.remove(selected_curve)
                print("Green curve shown")
            selected_curve = None
        else:
            for elem in hidden_elements:
                elem.set_visible(True)
            hidden_elements.clear()
            print("All hidden elements shown")
        fig_2d.canvas.draw()
# Reset canvas
def reset_canvas(event):
    global drawing_points, kappas, previous_kappa, green_curve_line, vanishing_points, selected_curve, current_vertices, current_faces, last_angle, node_scatter, ghost_handles, is_closed, original_colors
    if event.key == 'e':
        drawing_points = []
        kappas = []
        previous_kappa = 1.0
        if green_curve_line:
            green_curve_line.remove()
            green_curve_line = None
        for node in node_scatter:
            node.remove()
        node_scatter = []
        original_colors = []
        for handle in ghost_handles:
            handle.remove()
        ghost_handles = []
        vanishing_points = []
        selected_curve = None
        ax_3d.cla()
        current_vertices = None
        current_faces = None
        last_angle = 0.0
        is_closed = False
        display_pod_surface()
        print("Canvas reset")
        fig_2d.canvas.draw()
# Compute curvature for continuity check
def compute_curvature(x, y, t):
    dt = t[1] - t[0]
    dx_dt = np.gradient(x, dt)
    dy_dt = np.gradient(y, dt)
    d2x_dt2 = np.gradient(dx_dt, dt)
    d2y_dt2 = np.gradient(dy_dt, dt)
    numerator = np.abs(dx_dt * d2y_dt2 - dy_dt * d2x_dt2)
    denominator = (dx_dt**2 + dy_dt**2)**1.5
    denominator = np.where(denominator == 0, 1e-10, denominator)
    return numerator / denominator
# Generate base pod curve (closed for boundary surface, now 3D curve)
def generate_pod_curve_closed(num_points=200, phase=0.0): # Increased num_points for better resolution
    t = np.linspace(0, 2 * np.pi, num_points) # Full closed loop
    r = radial_chord + tangential_chord * np.cos(6 * t + phase) # Flower-like top profile
    x = r * np.cos(t)
    y = r * np.sin(t)
    z = height_chord * np.sin(6 * t + phase) # Add z variation for 3D curve
    return x, y, z
# Function to compute normals
def compute_normal(v1, v2, v3):
    vec1 = v2 - v1
    vec2 = v3 - v1
    normal = np.cross(vec1, vec2)
    norm = np.linalg.norm(normal)
    return normal / norm if norm != 0 else normal
# Export current model to STL
def export_stl():
    global current_vertices, current_faces
    if current_vertices is None or current_faces is None:
        print("No model to export")
        return
    stl_data = b'\x00' * 80 # Header
    stl_data += struct.pack('<I', len(current_faces)) # Number of triangles
    for face in current_faces:
        v1 = current_vertices[face[0]]
        v2 = current_vertices[face[1]]
        v3 = current_vertices[face[2]]
        normal = compute_normal(v1, v2, v3)
        stl_data += struct.pack('<3f', *normal)
        stl_data += struct.pack('<3f', *v1)
        stl_data += struct.pack('<3f', *v2)
        stl_data += struct.pack('<3f', *v3)
        stl_data += b'\x00\x00' # Attribute byte count
    filename = 'model.stl'
    with open(filename, 'wb') as f:
        f.write(stl_data)
    print(f"Saved to {filename}")
    stl_base64 = base64.b64encode(stl_data).decode('utf-8')
    print("Base64 STL:")
    print(stl_base64)
# Save STL on key press
def save_stl(event):
    if event.key == 's':
        export_stl()
# Display pod surface by default in 3D with curvature continuous end caps
def display_pod_surface():
    global current_vertices, current_faces
    x_curve, y_curve, z_curve = generate_pod_curve_closed(200) # Increased for resolution
    current_vertices, current_faces = build_mesh(x_curve, y_curve, z_curve)
    verts = [[current_vertices[i] for i in f] for f in current_faces]
    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
    ax_3d.set_xlabel('X')
    ax_3d.set_ylabel('Y')
    ax_3d.set_zlabel('Z')
    ax_3d.set_title('3D pod Projected Surface (Compound Curvature with End Caps)')
    fig_3d.canvas.draw()
# Draw default pod ellipse as green curve on 2D canvas
def draw_default_pod(ax, color='g'):
    x, y, _ = generate_pod_curve_closed(num_points=36) # Increased to 36 for better flower
    x_control = x[:-1]
    y_control = y[:-1]
    scale = 0.6 # Scale for large curve
    x_control *= scale
    y_control *= scale
    x_control += WIDTH / 2
    y_control += HEIGHT / 2
    points = list(zip(x_control, y_control))
    kappas_pod = [1.0] * len(points)
    x_interp, y_interp = custom_interoperations_green_curve(points, kappas_pod, is_closed=True)
    ax.plot(x_interp, y_interp, color=color, linewidth=3, linestyle='-')
    # Compute and print speeds for default curve
    print("Default Curve Speeds:")
    for i in range(len(x_interp)):
        speed = int(hashlib.sha256(f"{x_interp[i]}{y_interp[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
        print(f"Point {i}: ({x_interp[i]:.4f}, {y_interp[i]:.4f}), Speed: {speed:.4f}")
# Add Mersenne elements to the plot
# First A4 page (adjusted)
ax_2d.plot([0, WIDTH/2, WIDTH/2, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 1')
# Second A4 page
ax_2d.plot([WIDTH/2, WIDTH, WIDTH, WIDTH/2, WIDTH/2], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 2')
# Purple lines (in first A4)
for x in PURPLE_LINES:
    ax_2d.plot([x * (WIDTH/2), x * (WIDTH/2)], [0, HEIGHT], 'm-')
# Red datum line
ax_2d.plot([0, WIDTH], [0, 0], 'r-')
# A4 short edge divisions (first A4 only)
for x in division_positions:
    ax_2d.plot([x, x], [0, 0.02], 'k-', alpha=0.3)
# Plot circle division markers
for x_marker, y_marker in circle_markers:
    ax_2d.plot(x_marker, y_marker, 'k.', markersize=3)
# Full spiral
ax_2d.plot(x_full, y_full, 'k-')
# Green segment
ax_2d.plot(x_green_final, y_green_scaled, 'g-')
# 52 Mersenne prime curves
for i, (x_new, y_new, label) in enumerate(curves):
    line, = ax_2d.plot(x_new, y_new, color=colors[i])
    curve_lines[i] = line
# Flags and staggered labels
label_y_offset = 0.05
for i, (x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq) in enumerate(flag_positions):
    ax_2d.plot([x_end, x_start], [y_end, y_start], 'k--', alpha=0.3)
    ax_2d.plot([x_start, x_flag], [y_start, y_flag], 'k-', alpha=0.5)
    y_label = y_flag - (i % 5) * label_y_offset
    text = ax_2d.text(x_flag, y_label, label, ha='left', va='top', fontsize=6, rotation=45, picker=5)
    harmonic_text = ax_2d.text(x_flag, y_label - 0.1, f"{freq:.1f} Hz", ha='left', va='top', fontsize=6, rotation=45, visible=False)
    annotation_objects.append((text, i))
    harmonic_texts.append(harmonic_text)
# Golden window 1 (vertical at x = 1/3)
idx_crossings_x = np.where(np.diff(np.sign(x_full - PURPLE_LINES[0])))[0]
if len(idx_crossings_x) >= 2:
    y1 = y_full[idx_crossings_x[0]]
    y2 = y_full[idx_crossings_x[1]]
    golden_window_1 = np.abs(y2 - y1)
    print(f"Golden Window 1 at x={PURPLE_LINES[0]}: {golden_window_1:.4f}")
    ax_2d.fill_between([PURPLE_LINES[0] - 0.05, PURPLE_LINES[0] + 0.05], min(y1, y2), max(y1, y2), color='yellow', alpha=0.5)
# Golden window 2 (horizontal at y = 1/3)
idx_crossings_y = np.where(np.diff(np.sign(y_full - 1/3)))[0]
if len(idx_crossings_y) >= 2:
    x1 = x_full[idx_crossings_y[0]]
    x2 = x_full[idx_crossings_y[1]]
    golden_window_2 = np.abs(x2 - x1)
    print(f"Golden Window 2 at y=1/3: {golden_window_2:.4f}")
    ax_2d.fill_betweenx([1/3 - 0.05, 1/3 + 0.05], min(x1, x2), max(x1, x2), color='orange', alpha=0.5)
# Scale label
ax_2d.text(WIDTH, 1.10337, scale_label, ha='right', va='bottom', fontsize=8)
# Update title with scale key
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
# Highlighting functionality for Mersenne labels
highlighted = [None, None]
def on_pick_mersenne(event):
    global highlighted
    artist = event.artist
    for text, idx in annotation_objects:
        if artist == text:
            if highlighted[0] is not None:
                highlighted[0].set_color('black')
                highlighted[0].set_weight('normal')
                curve_lines[highlighted[1]].set_linewidth(1.0)
                curve_lines[highlighted[1]].set_color(colors[highlighted[1]])
            text.set_color('red')
            text.set_weight('bold')
            curve_lines[idx].set_linewidth(2.0)
            curve_lines[idx].set_color('red')
            highlighted = [text, idx]
            fig_2d.canvas.draw()
            break
def on_click_deselect(event):
    global highlighted
    if event.inaxes != ax_2d:
        return
    clicked_on_annotation = False
    for text, idx in annotation_objects:
        if text.contains(event)[0]:
            clicked_on_annotation = True
            break
    if not clicked_on_annotation and highlighted[0] is not None:
        highlighted[0].set_color('black')
        highlighted[0].set_weight('normal')
        curve_lines[highlighted[1]].set_linewidth(1.0)
        curve_lines[highlighted[1]].set_color(colors[highlighted[1]])
        highlighted = [None, None]
        fig_2d.canvas.draw()
# Curve cache for hashing
curve_cache = {}
def compute_curve_points(theta_start, theta_end, num_points, scale_factor, rotation_angle=0):
    # Create a hash key based on parameters
    key = f"{theta_start:.2f}:{theta_end:.2f}:{num_points}:{scale_factor:.4f}:{rotation_angle:.2f}"
    key_hash = hashlib.md5(key.encode()).hexdigest()
    if key_hash in curve_cache:
        return curve_cache[key_hash]
    theta = np.linspace(theta_start, theta_end, num_points)
    r = scale_factor * A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Apply rotation
    if rotation_angle != 0:
        angle_rad = np.deg2rad(rotation_angle)
        x_rot = x * np.cos(angle_rad) - y * np.sin(angle_rad)
        y_rot = x * np.sin(angle_rad) + y * np.cos(angle_rad)
        x, y = x_rot, y_rot
    curve_cache[key_hash] = (x, y)
    return x, y
# Dynamic LOD
def get_num_points_for_curve():
    xlim = ax_2d.get_xlim()
    ylim = ax_2d.get_ylim()
    view_width = xlim[1] - xlim[0]
    view_height = ylim[1] - ylim[0]
    # Base number of points when fully zoomed out
    base_points = 20
    max_points = 200
    # Zoom factor: smaller view range means more zoom
    full_range = WIDTH # Full x-range when zoomed out
    zoom_factor = full_range / view_width
    num_points = int(base_points + (max_points - base_points) * min(zoom_factor / 10, 1))
    return max(base_points, min(max_points, num_points))
# Cursor, spiral, and circumference setup
cursor, = ax_2d.plot([], [], 'ro', markersize=8, label='κ Spiral Cursor', visible=False)
cursor_spiral, = ax_2d.plot([], [], 'g-', alpha=0.5, visible=False)
cursor_circumference = plt.Circle((0, 0), 0, color='b', fill=False, linestyle='--', alpha=0.5, visible=False)
ax_2d.add_patch(cursor_circumference)
cursor_text = ax_2d.text(WIDTH / 2, 1.15, '', ha='center', va='bottom', fontsize=8, visible=False)
baseline_spiral, = ax_2d.plot([], [], 'g-', alpha=0.5, label='Baseline Spiral', visible=False)
baseline_spiral_2, = ax_2d.plot([], [], 'g-', alpha=0.5, label='Baseline Spiral 2', visible=False)
# Crosslines
vertical_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
horizontal_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
vertical_label = ax_2d.text(target_chord, HEIGHT + 0.05, f'Chord: {target_chord:.4f}', ha='center', va='bottom', fontsize=8, visible=False)
# Protractor elements
protractor_line, = ax_2d.plot([], [], 'b-', alpha=0.8, visible=False)
protractor_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8), visible=False)
protractor_arc, = ax_2d.plot([], [], 'b-', alpha=0.5, visible=False)
protractor_spiral_2, = ax_2d.plot([], [], 'g-', alpha=0.5, visible=False)
# Baseline angle (grey ghost line)
baseline_angle_line, = ax_2d.plot([0, WIDTH], [0, 0], 'grey', alpha=0.3, linestyle='--', visible=False)
# Swinging ghost curves
ghost_curves = []
for _ in range(4): # ±5°, ±10° (4 curves total)
    line, = ax_2d.plot([], [], 'grey', alpha=0.2, visible=False)
    ghost_curves.append(line)
# Ruler elements
ruler_divisions = []
for _ in range(10): # Up to 10 division markers
    marker, = ax_2d.plot([], [], 'k|', markersize=10, markeredgewidth=2, visible=False)
    ruler_divisions.append(marker)
ruler_vanishing_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        cursor.set_visible(protractor_active)
        cursor_spiral.set_visible(protractor_active)
        cursor_circumference.set_visible(protractor_active)
        cursor_text.set_visible(protractor_active)
        baseline_spiral.set_visible(protractor_active)
        baseline_spiral_2.set_visible(protractor_active)
        vertical_line.set_visible(protractor_active)
        horizontal_line.set_visible(protractor_active)
        vertical_label.set_visible(protractor_active)
        protractor_line.set_visible(protractor_active)
        protractor_text.set_visible(protractor_active)
        protractor_arc.set_visible(protractor_active)
        protractor_spiral_2.set_visible(protractor_active)
        baseline_angle_line.set_visible(protractor_active)
        for curve in ghost_curves:
            curve.set_visible(protractor_active)
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        fig_2d.canvas.draw()
# On motion for protractor
def on_motion_protractor(event):
    if not protractor_active or event.inaxes != ax_2d:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    # Update cursor position
    cursor.set_data([x], [y])
    # Update circumference
    radius = np.sqrt(x**2 + y**2)
    cursor_circumference.set_center((x, y))
    cursor_circumference.set_radius(radius)
    # Dynamic LOD: Adjust number of points based on zoom
    num_points = get_num_points_for_curve()
    # Update cursor spiral
    x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
    cursor_spiral.set_data(x + x_spiral, y + y_spiral)
    # Update baseline spiral (indexed at (0,0))
    x_base = 0.0
    scale_factor = (event.xdata / WIDTH) if event.xdata > 0 else 0.01
    scaled_a = A_SPIRAL * scale_factor
    height_factor = (event.ydata / HEIGHT) if event.ydata > 0 else 0.01
    x_base_spiral, y_base_spiral = compute_curve_points(2 * np.pi, np.pi, num_points, scale_factor)
    x_base_spiral = x_base + x_base_spiral * np.abs(np.cos(np.linspace(2 * np.pi, np.pi, num_points)))
    y_base_spiral = y_base_spiral * height_factor
    baseline_spiral.set_data(x_base_spiral, y_base_spiral)
    # Compute the chord length of the baseline spiral
    x_start = x_base_spiral[0]
    y_start = y_base_spiral[0]
    x_end = x_base_spiral[-1]
    y_end = y_base_spiral[-1]
    baseline_chord = np.sqrt((x_end - x_start)**2 + (y_end - y_start)**2)
    # Update second baseline spiral (indexed at (1.0, 0))
    x_base_2 = 1.0
    x_base_spiral_2, y_base_spiral_2 = compute_curve_points(2 * np.pi, np.pi, num_points, scale_factor)
    x_base_spiral_2 = x_base_2 + x_base_spiral_2 * np.abs(np.cos(np.linspace(2 * np.pi, np.pi, num_points)))
    y_base_spiral_2 = y_base_spiral_2 * height_factor
    baseline_spiral_2.set_data(x_base_spiral_2, y_base_spiral_2)
    # Compute the chord length of the second baseline spiral
    x_start_2 = x_base_spiral_2[0]
    y_start_2 = y_base_spiral_2[0]
    x_end_2 = x_base_spiral_2[-1]
    y_end_2 = y_base_spiral_2[-1]
    baseline_chord_2 = np.sqrt((x_end_2 - x_start_2)**2 + (y_end_2 - y_start_2)**2)
    # Update crosslines
    vertical_line.set_data([target_chord, target_chord], [0, HEIGHT])
    vertical_label.set_position((target_chord, HEIGHT + 0.05))
    if y > 0:
        horizontal_line.set_data([0, WIDTH], [y, y])
    else:
        horizontal_line.set_data([], [])
    # Update protractor line (from (0,0) to mouse position)
    anchor_x, anchor_y = 0.0, 0.0
    protractor_line.set_data([anchor_x, x], [anchor_y, y])
    # Compute the angle relative to the baseline (y=0)
    dx = x - anchor_x
    dy = y - anchor_y
    angle = np.arctan2(dy, dx) * 180 / np.pi
    # Update protractor arc
    mid_x = (anchor_x + x) / 2
    mid_y = (anchor_y + y) / 2
    radius_arc = np.sqrt(dx**2 + dy**2) / 4
    start_angle = 0
    end_angle = angle
    theta_arc = np.linspace(np.deg2rad(start_angle), np.deg2rad(end_angle), num_points)
    x_arc = mid_x + radius_arc * np.cos(theta_arc)
    y_arc = mid_y + radius_arc * np.sin(theta_arc)
    protractor_arc.set_data(x_arc, y_arc)
    # Update swinging ghost curves
    offsets = [-10, -5, 5, 10] # Degrees
    for i, offset in enumerate(offsets):
        angle_offset = angle + offset
        x_ghost, y_ghost = compute_curve_points(np.pi, 2 * np.pi, num_points // 2, 1.0, angle_offset)
        ghost_curves[i].set_data(anchor_x + x_ghost, anchor_y + y_ghost)
    # Update protractor spiral at the mouse position
    line_vec = np.array([x - anchor_x, y - anchor_y])
    line_len = np.sqrt(dx**2 + dy**2)
    if line_len == 0:
        line_len = 1e-10
    normal_vec = np.array([-(y - anchor_y), x - anchor_x]) / line_len
    x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
    x_mirrored = []
    y_mirrored = []
    for xs, ys in zip(x_spiral, y_spiral):
        point = np.array([xs, ys])
        v = point - np.array([anchor_x, anchor_y])
        projection = np.dot(v, normal_vec) * normal_vec
        mirrored_point = point - 2 * projection
        x_mirrored.append(mirrored_point[0])
        y_mirrored.append(mirrored_point[1])
    protractor_spiral_2.set_data(x + x_mirrored, y + y_mirrored)
    # Update protractor text
    protractor_text.set_position((mid_x, mid_y))
    protractor_text.set_text(f'Angle: {angle:.2f}°\nκ at 2πR: {kappa_at_2piR:.4f}')
    # Calculate chord length from cursor to the start of the green segment
    x_start_green, y_start_green = x_green_final[0], y_green_scaled[0]
    chord_to_green = np.sqrt((x - x_start_green)**2 + (y - y_start_green)**2)
    # Update cursor text
    text_str = (f'κ: {scale_factor:.4f}\n'
                f'Height Factor: {height_factor:.4f}\n'
                f'Cursor: ({x:.4f}, {y:.4f})\n'
                f'Chord to Green: {chord_to_green:.4f}\n'
                f'Baseline Chord (x=0): {baseline_chord:.4f}\n'
                f'Baseline Chord (x=1): {baseline_chord_2:.4f}')
    cursor_text.set_text(text_str)
    fig_2d.canvas.draw()
# Toggle harmonics
def toggle_harmonics(event):
    global show_harmonics
    if event.key == 'h':
        show_harmonics = not show_harmonics
        for text in harmonic_texts:
            text.set_visible(show_harmonics)
        print(f"Harmonic frequencies {'shown' if show_harmonics else 'hidden'}")
        fig_2d.canvas.draw()
# Save plot
def save_plot(event):
    if event.key == 'w':
        plt.savefig("nu_curve.png", dpi=300, bbox_inches='tight')
        print("Plot saved as nu_curve.png")
        if MPLD3_AVAILABLE:
            mpld3.save_html(fig_2d, "nu_curve.html")
            print("Interactive plot saved as nu_curve.html")
        else:
            print("Skipping HTML export because mpld3 is not installed.")
# Connect events
fig_2d.canvas.mpl_connect('pick_event', on_pick_mersenne)
fig_2d.canvas.mpl_connect('button_press_event', on_click_deselect)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_harmonics)
fig_2d.canvas.mpl_connect('key_press_event', save_plot)
fig_2d.canvas.mpl_connect('key_press_event', toggle_draw)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('key_press_event', toggle_dimension)
fig_2d.canvas.mpl_connect('key_press_event', to_construction)
fig_2d.canvas.mpl_connect('key_press_event', hide_show)
fig_2d.canvas.mpl_connect('key_press_event', reset_canvas)
fig_2d.canvas.mpl_connect('key_press_event', save_stl)
fig_2d.canvas.mpl_connect('button_press_event', on_click_protractor)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_dimension)
fig_2d.canvas.mpl_connect('button_press_event', on_click_draw)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion)
fig_2d.canvas.mpl_connect('key_press_event', auto_close)
fig_2d.canvas.mpl_connect('key_press_event', toggle_pro_mode)
fig_2d.canvas.mpl_connect('pick_event', on_pick)
fig_2d.canvas.mpl_connect('button_press_event', on_button_press)
fig_2d.canvas.mpl_connect('button_release_event', on_button_release)
# Plot properties
ax_2d.set_xlim(-0.1, WIDTH + 0.1)
ax_2d.set_ylim(-1.5, HEIGHT + 0.1)
ax_2d.set_xlabel('x (Exponents: 2 to 11B)')
ax_2d.set_ylabel('y')
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
ax_2d.grid(True)
ax_2d.set_aspect('equal')
# Display default pod surface and draw default pod
display_pod_surface()
draw_default_pod(ax_2d)
plt.show()

----- END id_util_nurks_surface.py -----

----- id_util_tetra_profile.py -----
# SPDX-License-Identifier: AGPL-3.0-or-later
# Copyright (C) 2025 Anonymous
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection

def generate_flower_profile(ns_diameter=1.0, nw_se_diameter=0.8, ne_sw_diameter=0.9, twist=0.0, amplitude=0.2, radii=0.5, num_petals=7, num_points=1000):
    """
    Generate a flower-shaped top profile using parametric equations.
    
    Parameters:
    - ns_diameter: North-South diameter (vertical axis).
    - nw_se_diameter: Northwest-Southeast diameter (one diagonal).
    - ne_sw_diameter: Northeast-Southwest diameter (other diagonal).
    - twist: Twist angle in radians for petal rotation.
    - amplitude: Amplitude of petal undulations.
    - radii: Base radius scaling for petals.
    - num_petals: Number of petals in the flower shape.
    - num_points: Number of points to generate for the curve.
    
    Returns:
    - x, y: Arrays of x and y coordinates for the 2D flower profile.
    """
    theta = np.linspace(0, 2 * np.pi, num_points)
    
    # Base elliptical shape using the diameters
    a = ns_diameter / 2  # Semi-major axis (NS)
    b = ne_sw_diameter / 2  # Semi-minor axis approximation
    c = nw_se_diameter / 2  # Another diagonal for variation
    
    # Parametric radius with petal undulations and twist
    r = radii + amplitude * np.sin(num_petals * (theta + twist))
    
    # Incorporate elliptical deformation
    x = r * np.cos(theta) * (a + c) / 2
    y = r * np.sin(theta) * (b + a) / 2
    
    # Apply twist to the entire shape
    twist_mat = np.array([[np.cos(twist), -np.sin(twist)],
                          [np.sin(twist), np.cos(twist)]])
    points = np.vstack([x, y])
    twisted_points = twist_mat @ points
    
    return twisted_points[0], twisted_points[1]

def bspline_basis(u, i, p, knots):
    """
    Recursive B-spline basis function.
    
    Parameters:
    - u: Parameter value.
    - i: Basis index.
    - p: Degree.
    - knots: Knot vector.
    
    Returns:
    - Basis value.
    """
    if p == 0:
        return 1.0 if knots[i] <= u < knots[i + 1] else 0.0
    den1 = knots[i + p] - knots[i]
    den2 = knots[i + p + 1] - knots[i + 1]
    term1 = ((u - knots[i]) / den1 * bspline_basis(u, i, p - 1, knots)) if den1 > 0 else 0.0
    term2 = ((knots[i + p + 1] - u) / den2 * bspline_basis(u, i + 1, p - 1, knots)) if den2 > 0 else 0.0
    return term1 + term2

def apply_kspline_smoothing(x, y, kappa=1.0, degree=5, num_output_points=1000, num_controls=28):
    """
    Apply a kappa-modulated spline smoothing (KSpline) to the profile points using pure NumPy.
    This is a Non-Uniform Rational Kappa Spline (NURKS) implementation without SciPy dependencies.
    Subsamples input points to control points, uses constant weights based on kappa for rational spline.
    
    Parameters:
    - x, y: Input coordinates.
    - kappa: Curvature modulation factor (used as uniform weight).
    - degree: Spline degree.
    - num_output_points: Number of points in the output curve.
    - num_controls: Number of control points to subsample.
    
    Returns:
    - smooth_x, smooth_y: Smoothed coordinates.
    """
    # Subsample to control points
    idx = np.linspace(0, len(x) - 1, num_controls, dtype=int)
    control_points = np.array([[x[i], y[i]] for i in idx])
    
    # Weights uniform based on kappa
    weights = np.full(len(control_points), kappa)
    
    # For closed curve, append points for periodicity
    control_points = np.concatenate((control_points, control_points[1:degree + 1]))
    weights = np.concatenate((weights, weights[1:degree + 1]))
    
    n = len(control_points) - 1
    # Clamped uniform knot vector
    knots = np.concatenate(([0] * (degree + 1), np.linspace(0, 1, n - degree + 2), [1] * (degree)))
    
    u_fine = np.linspace(0, 1, num_output_points)
    
    smooth_x = np.zeros(num_output_points)
    smooth_y = np.zeros(num_output_points)
    
    for j, u in enumerate(u_fine):
        num_x, num_y, den = 0.0, 0.0, 0.0
        for i in range(len(control_points)):
            b = bspline_basis(u, i, degree, knots)
            w = weights[i] * b
            num_x += w * control_points[i, 0]
            num_y += w * control_points[i, 1]
            den += w
        if den > 0:
            smooth_x[j] = num_x / den
            smooth_y[j] = num_y / den
    
    return smooth_x, smooth_y

def generate_tetra_surface(x_profile, y_profile, height=1.0, num_layers=10, twist_per_layer=0.1):
    """
    Generate a 3D tetrahedral-like surface by extruding the 2D profile.
    This creates a stacked mesh with twisting layers for a petal-shaped volume.
    
    Parameters:
    - x_profile, y_profile: 2D profile coordinates.
    - height: Total height of the 3D mesh.
    - num_layers: Number of layers for extrusion.
    - twist_per_layer: Twist increment per layer.
    
    Returns:
    - vertices: 3D vertices (Nx3 array).
    - faces: Triangular faces (Mx3 array).
    """
    num_points = len(x_profile)
    vertices = []
    faces = []
    
    dz = height / num_layers
    for layer in range(num_layers + 1):
        z = layer * dz
        twist = layer * twist_per_layer
        rot_mat = np.array([[np.cos(twist), -np.sin(twist)],
                            [np.sin(twist), np.cos(twist)]])
        rotated = rot_mat @ np.vstack([x_profile, y_profile])
        for i in range(num_points):
            vertices.append([rotated[0, i], rotated[1, i], z])
    
    # Create triangular faces (simple extrusion triangulation)
    for layer in range(num_layers):
        base_idx = layer * num_points
        next_idx = (layer + 1) * num_points
        for i in range(num_points):
            j = (i + 1) % num_points
            # Two triangles per quad
            faces.append([base_idx + i, base_idx + j, next_idx + i])
            faces.append([base_idx + j, next_idx + j, next_idx + i])
    
    return np.array(vertices), np.array(faces)

def visualize_mesh(vertices, faces):
    """
    Visualize the 3D mesh using matplotlib.
    
    Parameters:
    - vertices: 3D vertices.
    - faces: Triangular faces.
    """
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.add_collection3d(Poly3DCollection(vertices[faces], alpha=0.5, edgecolor='k'))
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    limits = np.ptp(vertices, axis=0) / 2
    ax.set_xlim(-limits[0], limits[0])
    ax.set_ylim(-limits[1], limits[1])
    ax.set_zlim(0, limits[2] * 2)
    plt.show()

# Example usage
if __name__ == "__main__":
    # Generate flower profile
    x, y = generate_flower_profile(ns_diameter=2.0, nw_se_diameter=1.5, ne_sw_diameter=1.8, twist=0.2, amplitude=0.3, radii=1.0, num_petals=7)
    
    # Smooth with KSpline (pure NumPy implementation)
    smooth_x, smooth_y = apply_kspline_smoothing(x, y, kappa=0.9)
    
    # Generate tetra surface
    vertices, faces = generate_tetra_surface(smooth_x, smooth_y, height=2.0, num_layers=20, twist_per_layer=0.05)
    
    # Visualize
    visualize_mesh(vertices, faces)

----- END id_util_tetra_profile.py -----

----- id_util_tetra_surface.py -----
# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Define control points for a simple NURKS surface (e.g., a curved dome)
control_points = np.array([
    [[0, 0, 0], [1, 0, 0], [2, 0, 0]],
    [[0, 1, 0], [1, 1, 2], [2, 1, 0]],
    [[0, 2, 0], [1, 2, 0], [2, 2, 0]]
])

# Weights for rational aspect - expand to match shape
weights = np.array([
    [1, 1, 1],
    [1, 1.5, 1],
    [1, 1, 1]
])

# Kappa parameter for curvature adjustment
kappa = 1.0  # Adjust this for more/less curvature

# Simple NURBS surface evaluation (bilinear for demo)
u = np.linspace(0, 1, 50)
v = np.linspace(0, 1, 50)
U, V = np.meshgrid(u, v)

X = np.zeros_like(U)
Y = np.zeros_like(U)
Z = np.zeros_like(U)

for i in range(len(u)):
    for j in range(len(v)):
        denom = 0
        numer_x, numer_y, numer_z = 0, 0, 0
        for a in range(3):
            for b in range(3):
                basis = (1 - u[i])**(2-a) * u[i]**a * (1 - v[j])**(2-b) * v[j]**b  # Bilinear basis (degree 2 approx)
                w = weights[a, b] * basis
                denom += w
                numer_x += w * control_points[a, b, 0]
                numer_y += w * control_points[a, b, 1]
                numer_z += w * control_points[a, b, 2] * kappa  # Kappa modulates Z
        X[i, j] = numer_x / denom
        Y[i, j] = numer_y / denom
        Z[i, j] = numer_z / denom

# Plot the surface
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_wireframe(X, Y, Z, color='black')
ax.plot_surface(X, Y, Z, cmap='viridis')

# Show control points
for a in range(3):
    for b in range(3):
        point = control_points[a, b]
        ax.scatter(point[0], point[1], point[2], color='red', s=50)

ax.set_title('NURKS Surface with Control Points')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')

plt.show()

----- END id_util_tetra_surface.py -----

----- nurks_surface.py -----
# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import cm
from matplotlib.widgets import Slider
import hashlib
from decimal import Decimal, getcontext
import warnings
from matplotlib import MatplotlibDeprecationWarning
import struct
import base64
# Import mpld3 if available for HTML export
try:
    import mpld3
    MPLD3_AVAILABLE = True
except ImportError:
    print("mpld3 not installed. HTML export will be skipped. Install mpld3 with 'pip install mpld3' to enable.")
    MPLD3_AVAILABLE = False
from temperature_salt import secure_hash_two
from kappawise import kappa_coord
from id_util_nurks_surface import custom_interoperations_green_curve
# Set precision for Decimal
getcontext().prec = 28
# Suppress warnings
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)
# A3 landscape dimensions (normalized: width long side, height short side)
WIDTH = 420 / 297 # A3 landscape: 420mm width, 297mm height, normalized height=1.0
HEIGHT = 1.0
PURPLE_LINES = [1/3, 2/3] # Dividers on the width
unit_per_mm = 1.0 / 297 # Normalize to A3 short side
scale_label = f"Scale: 1mm = {unit_per_mm:.5f} units (A3 short side = 297mm)"
# Dreyfuss human factors: Optimal eye distance ~20 inches (508mm)
EYE_DISTANCE = 500 * unit_per_mm # Normalized eye distance to viewport
HORIZON_HEIGHT = HEIGHT * 0.5 # Default horizon line at half height
EYE_LINE = HORIZON_HEIGHT # Eye line coincides with horizon
# Golden spiral parameters
PHI = (1 + np.sqrt(5)) / 2
kappa = 1 / PHI
A_SPIRAL = 0.001 # Scaled down slightly from 0.01 to fit better
B_SPIRAL = np.log(PHI) / (np.pi / 2)
# Define κθπ for the green segment
theta_max = kappa * np.pi**2 / PHI
# Compute the full spiral
theta_full = np.linspace(0, 10 * np.pi, 1000)
r_full = A_SPIRAL * np.exp(B_SPIRAL * theta_full)
x_full = r_full * np.cos(theta_full)
y_full = r_full * np.sin(theta_full)
# Compute the green segment (θ from π to 2π)
theta_green = np.linspace(np.pi, 2 * np.pi, 200)
r_green = A_SPIRAL * np.exp(B_SPIRAL * theta_green)
x_green = r_green * np.cos(theta_green)
y_green = r_green * np.sin(theta_green)
# Compute the chord and shift
x1, y1 = x_green[0], y_green[0]
x2, y2 = x_green[-1], y_green[-1]
chord_length = np.abs(x2 - x1)
# Shift so the segment starts at x=0
x_green_shifted = x_green - x1
x_green_final = x_green_shifted
# Scale to match the target chord length (between purple lines)
target_chord = PURPLE_LINES[1] - PURPLE_LINES[0]
scale_factor = target_chord / chord_length if chord_length != 0 else 1.0
x_green_scaled = x_green_final * scale_factor
y_green_scaled = y_green * scale_factor
# Shift to start at the first purple line
x_green_final = x_green_scaled + PURPLE_LINES[0]
# Compute κ at 2πR for the green segment
r_max = A_SPIRAL * np.exp(B_SPIRAL * theta_max)
two_pi_r = 2 * np.pi * r_max
kappa_at_2piR = two_pi_r / PHI
# Define the 52 Mersenne prime exponents (updated with the latest known as of 2025)
mersenne_exponents = [
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
    3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
    110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
    6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
    37156667, 42643801, 43112609, 57885161, 74207281, 77232917, 82589933,
    136279841 # Latest known Mersenne prime exponent as of 2025 (52nd)
]
# Map exponents to x-positions (0 to width)
min_exponent = 2
max_exponent_at_x1 = 1_100_000_000
exponent_range_per_x = (max_exponent_at_x1 - min_exponent) / 1.0
x_positions = [(exponent - min_exponent) / exponent_range_per_x * WIDTH for exponent in mersenne_exponents] # Scale to full WIDTH
# Create the 52 curves data
curves = []
curve_lines = []
colors = plt.cm.viridis(np.linspace(0, 1, len(mersenne_exponents)))
for i, (exponent, x_pos) in enumerate(zip(mersenne_exponents, x_positions)):
    scale = x_pos / chord_length if chord_length != 0 else 1.0
    x_new = x_green * scale
    y_new = y_green * scale
    x_new_shifted = x_new - x_new[0]
    curves.append((x_new_shifted, y_new, f"M{exponent}"))
    curve_lines.append(None)
# A4 short edge divisions (110 parts, scaled to first part of WIDTH)
division_step = WIDTH / 2 / 110 # Assume first half is A4-like
division_positions = np.arange(0, WIDTH / 2 + division_step, division_step)
# Scale key for the title
scale_key_positions = division_positions[::10] / (WIDTH / 2) # Normalize to 0-1 for first half
scale_key_exponents = [int(2 + (1_100_000_000 - 2) * x) for x in scale_key_positions]
scale_key_text = "Scale (x=0 to WIDTH/2): " + ", ".join([f"{x:.2f}: {exp:,}" for x, exp in zip(scale_key_positions, scale_key_exponents)])
# Flags for Mersenne primes
flag_length = 0.5
start_y = -0.1
wedge_angles = np.linspace(90, 360, len(curves))
flag_positions = []
annotation_objects = []
harmonic_frequencies = []
circle_markers = []
min_exp = min(mersenne_exponents)
max_exp = max(mersenne_exponents)
log_min = np.log(min_exp)
log_max = np.log(max_exp)
min_freq_exp = -4.459
max_freq_exp = 5.506
exponent_range = max_freq_exp - min_freq_exp
log_range = log_max - log_min
for i, (x_new, y_new, label) in enumerate(curves):
    x_end = x_new[-1]
    y_end = y_new[-1]
    x_start = x_end
    y_start = start_y
    angle = np.deg2rad(wedge_angles[i])
    x_flag = x_start + flag_length * np.cos(angle)
    y_flag = y_start + flag_length * np.sin(angle)
    exponent = mersenne_exponents[i]
    scaled_exponent = min_freq_exp + (np.log(exponent) - log_min) / log_range * exponent_range
    freq = 440 * 2**scaled_exponent
    harmonic_frequencies.append(freq)
    flag_positions.append((x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq))
    angle_deg = wedge_angles[i]
    if (angle_deg - 90) % 5 == 0:
        angle_rad = np.deg2rad(angle_deg)
        x_marker = x_start + (flag_length * 0.5) * np.cos(angle_rad)
        y_marker = y_start + (flag_length * 0.5) * np.sin(angle_rad)
        circle_markers.append((x_marker, y_marker))
# Global variables for interactive modes
protractor_active = False
ruler_active = False
draw_mode = False
dimension_active = False
pro_mode = False
is_closed = False
selected_curve = None
hidden_elements = []
protractor_points = []
protractor_line = None
protractor_text = None
ruler_points = []
ruler_line = None
ruler_text = None
dimension_labels = []
drawing_points = [] # Kappa nodes (first endpoint of each greenchord)
kappas = [] # Kappa values at each node
node_scatter = [] # List of scatter objects for kappa nodes
original_colors = [] # List to store original colors of nodes
selected_node_index = -1
dragging = False
ghost_handles = [] # List for theta ghost handles
green_curve_line = None # Single plot object for the interoperated greencurve
CLOSE_THRESHOLD = 0.05 # Distance to first point to consider closing
SNAP_THRESHOLD = 0.05 # Threshold for snapping to dividers (UX improvement)
vanishing_points = [] # Vanishing points for each triangulation
previous_kappa = 1.0 # Initial kappa for decay
curvature = 1.0 # Initial curvature (kappa)
height = 0.5 # Initial height for 3D model
num_rings = 20 # Number of loft rings
fractal_level = 3 # Fractal level for flowers
radial_chord = 0.5 # Radial chord for flower
tangential_chord = 0.2 # Tangential chord for flower
height_chord = 0.1 # Height chord for flower
current_vertices = None
current_faces = None
last_angle = 0.0 # Last measured angle from protractor
show_harmonics = False
harmonic_texts = []
annotation_objects = []
# Pre-compute kappa grid
kappa_grid = np.random.rand(100,100,360)  # Placeholder for 3D kappa grid
# Fractal Flower Mesh
def fractal_flower(center, scale, level, all_polygons, rotation_angle=0.0):
    """
    Recursive generates flower-shaped polygons for the surface.
    Collects all base-level flower polygons in all_polygons (list of list of [x,y,z]).
    Uses 36 points for better flower resolution with curved petals.
    Applies rotation to the points.
    Args:
        center: [x, y, z] center of the flower.
        scale: Scale factor for the flower size.
        level: Current recursion depth.
        all_polygons: List to collect all base flower polygons.
        rotation_angle: Rotation angle in radians for the flower.
    """
    rot_cos = np.cos(rotation_angle)
    rot_sin = np.sin(rotation_angle)
    num_points = 37 # 36 points for higher resolution
    t = np.linspace(0, 2 * np.pi, num_points)[:-1]
    r = scale * (radial_chord + tangential_chord * np.sin(6 * t)) # 6 petals, use sin for symmetry if needed
    dx = r * np.cos(t)
    dy = r * np.sin(t)
    dz = scale * height_chord * np.cos(6 * t) # Curved z for surface
    # Apply rotation to dx, dy (around z)
    x_rot = center[0] + dx * rot_cos - dy * rot_sin
    y_rot = center[1] + dx * rot_sin + dy * rot_cos
    z_rot = center[2] + dz
    polygon = [[x_rot[j], y_rot[j], z_rot[j]] for j in range(len(t))]
    all_polygons.append(polygon)
    if level == 0:
        return
    # Add smaller flowers at petal tips
    small_scale = scale / PHI # Golden ratio scale
    for i in range(6):
        theta = i * (2 * np.pi / 6)
        tip_r = scale * (radial_chord + tangential_chord) # Max r for tip
        tip_dx = tip_r * np.cos(theta)
        tip_dy = tip_r * np.sin(theta)
        tip_dz = scale * height_chord
        # Rotate tip offset
        tip_x = center[0] + tip_dx * rot_cos - tip_dy * rot_sin
        tip_y = center[1] + tip_dx * rot_sin + tip_dy * rot_cos
        tip_z = center[2] + tip_dz
        tip_center = [tip_x, tip_y, tip_z]
        fractal_flower(tip_center, small_scale, level - 1, all_polygons, rotation_angle + np.pi)
# Triangulate polygon for rendering (fan triangulation)
def triangulate_poly(poly):
    tris = []
    for i in range(1, len(poly) - 1):
        tris.append([poly[0], poly[i], poly[i+1]])
    return tris
# Hash entropy for lower surface
def hash_entropy(p):
    h_str = f"{p[0]:.6f}{p[1]:.6f}{p[2]:.6f}"
    h = int(hashlib.sha256(h_str.encode()).hexdigest(), 16) % 1000 / 1000.0 * 0.05 - 0.025
    return h
# Build mesh using fractal flower (ties to curve by scaling to curve length)
def build_mesh(x_curve, y_curve, z_curve=None, height=0.5, num_rings=20, num_points=None, fractal_level=3):
    """
    Builds two surfaces meeting at the 3D curve with vertical tangent, inheriting each other's curvature in transition.
    Integrates fractal flower for complex surface detail on caps, scaled by curve length.
    Uses flower modulation in loft rings for interlacing petals.
    Args:
        x_curve, y_curve, z_curve: Curve coordinates.
        height: Height for lofting.
        num_rings: Number of rings for loft.
        num_points: Number of points to sample curve.
        fractal_level: Recursion level for fractal flower.
    Returns:
        vertices (np.array): Array of [x, y, z].
        faces (list): List of [idx1, idx2, idx3].
    """
    if num_points is not None:
        indices = np.linspace(0, len(x_curve) - 1, num_points, dtype=int)
        x_curve = x_curve[indices]
        y_curve = y_curve[indices]
        if z_curve is not None:
            z_curve = z_curve[indices]
    n = len(x_curve)
    if z_curve is None:
        z_curve = np.zeros(n) # Default to flat if no z provided
    # Use node 2 as datum when closed
    center_x = drawing_points[1][0] if is_closed and len(drawing_points) > 1 else drawing_points[0][0] if drawing_points else np.mean(x_curve)
    center_y = drawing_points[1][1] if is_closed and len(drawing_points) > 1 else drawing_points[0][1] if drawing_points else np.mean(y_curve)
    vertices = []
    faces = []
    # Parting line on 3D curve
    parting_base = len(vertices)
    for i in range(n):
        vertices.append([x_curve[i], y_curve[i], z_curve[i]])
    # Upper surface: rings inward with vertical tangent at edge and flower modulation
    upper_bases = [parting_base]
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2 # Vertical tangent at s=0 (dr/ds=0)
        g_val = (height / 2) * s**2 # Quadratic for constant curvature
        base = len(vertices)
        upper_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = 0.0 # Upper phase
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s # Modulation increases inward
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) + g_val + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_upper_idx = len(vertices)
    vertices.append([center_x, center_y, height / 2])
    # Lower surface: mirrored with phase offset for interlacing and entropy
    lower_bases = [parting_base] # Shared edge
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2
        g_val = (height / 2) * s**2 # Quadratic for constant curvature (sign same for inheritance magnitude)
        base = len(vertices)
        lower_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = np.pi / 6 # Lower phase offset for interlacing
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) - g_val + hash_entropy([x, y, z]) + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_lower_idx = len(vertices)
    vertices.append([center_x, center_y, -height / 2])
    # Faces for upper surface
    for ll in range(len(upper_bases) - 1):
        base = upper_bases[ll]
        next_base = upper_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, base + next_i, next_base + next_i])
            faces.append([base + i, next_base + next_i, next_base + i])
    # Faces for lower surface
    for ll in range(len(lower_bases) - 1):
        base = lower_bases[ll]
        next_base = lower_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, next_base + i, next_base + next_i])
            faces.append([base + i, next_base + next_i, base + next_i])
    # Integrate fractal flower for caps (no fan, use flower fractals)
    # Compute curve length for scale
    curve_length = np.sum(np.sqrt(np.diff(x_curve)**2 + np.diff(y_curve)**2))
    flower_scale = curve_length * 0.1 if curve_length > 0 else 0.5 # Scale to curve
    all_polygons = [] # List of list of [x,y,z] for each polygon
    # Upper cap flower
    fractal_flower(vertices[center_upper_idx], flower_scale, fractal_level, all_polygons, rotation_angle=np.pi)
    # Lower cap flower
    fractal_flower(vertices[center_lower_idx], flower_scale, fractal_level, all_polygons, rotation_angle=np.pi)
    # Add polygons to mesh (triangulate for rendering)
    for poly in all_polygons:
        base_idx = len(vertices)
        vertices.extend(poly)
        for tri in triangulate_poly(range(len(poly))):
            faces.append([base_idx + tri[0], base_idx + tri[1], base_idx + tri[2]])
    # Convert to numpy array
    vertices = np.array(vertices)
    # Snap to integers if hash ends with 0
    for i in range(len(vertices)):
        v = vertices[i]
        h_str = f"{v[0]:.6f}{v[1]:.6f}{v[2]:.4f}"
        h = hashlib.sha256(h_str.encode()).hexdigest()[-1]
        if h == '0':
            vertices[i] = np.round(vertices[i])
    # Add compound curvature modulation with angle and 3D kappa grid for smooth orthographic projections
    grid_size, _, num_angles = kappa_grid.shape
    angle_idx = int((last_angle / 360) * num_angles) % num_angles
    kappa_slice = kappa_grid[:, :, angle_idx]
    # Normalize vertices to -1 to 1 for grid mapping (assuming curve bounds approx [0, WIDTH] x [0, HEIGHT])
    max_dim = max(np.max(np.abs(vertices[:, 0])), np.max(np.abs(vertices[:, 1])))
    norm_x = np.clip(((vertices[:, 0] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    norm_y = np.clip(((vertices[:, 1] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    kappa_mod = kappa_slice[norm_y, norm_x]
    vertices[:, 2] += kappa_mod * 0.1 # Scale z modulation
    vertices[:, 0] += kappa_mod * 0.05 * np.sin(2 * np.pi * vertices[:, 2] / height) # Compound in x
    vertices[:, 1] += kappa_mod * 0.05 * np.cos(2 * np.pi * vertices[:, 2] / height) # Compound in y
    # Make flowers sacrificial: remove flower faces after modulation (assume last added are flowers)
    flower_face_start = len(faces) - len(all_polygons) * 35 # Adjusted for 36 points per flower (approx 35 triangles)
    faces = faces[:flower_face_start]
    return vertices, faces
# NURBS basis function
def nurbs_basis(u, i, p, knots):
    if p == 0:
        return 1.0 if knots[i] <= u <= knots[i+1] else 0.0 # Include = for end
    if knots[i+p] == knots[i]:
        c1 = 0.0
    else:
        c1 = (u - knots[i]) / (knots[i+p] - knots[i]) * nurbs_basis(u, i, p-1, knots)
    if knots[i+p+1] == knots[i+1]:
        c2 = 0.0
    else:
        c2 = (knots[i+p+1] - u) / (knots[i+p+1] - knots[i+1]) * nurbs_basis(u, i+1, p-1, knots)
    return c1 + c2
# Compute NURBS curve point
def nurbs_curve_point(u, control_points, weights, p, knots):
    n = len(control_points) - 1
    x = 0.0
    y = 0.0
    denom = 0.0
    for i in range(n + 1):
        b = nurbs_basis(u, i, p, knots)
        denom += b * weights[i]
        x += b * weights[i] * control_points[i][0]
        y += b * weights[i] * control_points[i][1]
    if denom == 0:
        return 0, 0
    return x / denom, y / denom
# Generate NURBS curve
def generate_nurbs_curve(points, weights, p, knots, num_points=1000):
    u_min, u_max = knots[p], knots[-p-1]
    u_values = np.linspace(u_min, u_max, num_points, endpoint=False)
    curve = [nurbs_curve_point(u, points, weights, p, knots) for u in u_values]
    curve.append(curve[0]) # Append first point for exact closure
    return np.array([list(pt) for pt in curve]) # Convert to np.array of shape (num_points+1, 2)
# Compute golden spiral
def compute_golden_spiral():
    theta = np.linspace(0, 10 * np.pi, 1000)
    r = A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Scale down to fit within page bounds
    scale_factor = min(WIDTH, HEIGHT) / (2 * np.max(np.abs([x, y]))) * 0.8 # 80% of max to fit comfortably
    x *= scale_factor
    y *= scale_factor
    return x, y
def bspline_basis(u, i, p, knots):
    if p == 0:
        if i < 0 or i + 1 >= len(knots):
            return 0.0
        return 1.0 if knots[i] <= u <= knots[i + 1] else 0.0
 
    if i < 0 or i >= len(knots) - 1:
        return 0.0
 
    term1 = 0.0
    if i + p < len(knots):
        den1 = knots[i + p] - knots[i]
        if den1 > 0:
            term1 = ((u - knots[i]) / den1) * bspline_basis(u, i, p - 1, knots)
 
    term2 = 0.0
    if i + p + 1 < len(knots):
        den2 = knots[i + p + 1] - knots[i + 1]
        if den2 > 0:
            term2 = ((knots[i + p + 1] - u) / den2) * bspline_basis(u, i + 1, p - 1, knots)
 
    return term1 + term2
def bspline_basis_periodic(u, i, p, knots, n):
    i = i % n
    if p == 0:
        k0 = knots[i % len(knots)]
        k1 = knots[(i + 1) % len(knots)]
        if k0 > k1: # Wrap-around interval
            return 1.0 if u >= k0 or u < k1 else 0.0
        else:
            return 1.0 if k0 <= u < k1 else 0.0
 
    k_i = knots[i % len(knots)]
    k_ip = knots[(i + p) % len(knots)]
    den1 = k_ip - k_i
    if den1 < 0:
        den1 += 1.0 # Adjust for wrap-around
    term1 = 0.0
    if den1 > 0:
        term1 = ((u - k_i) / den1) * bspline_basis_periodic(u, i, p - 1, knots, n)
 
    k_i1 = knots[(i + 1) % len(knots)]
    k_ip1 = knots[(i + p + 1) % len(knots)]
    den2 = k_ip1 - k_i1
    if den2 < 0:
        den2 += 1.0 # Adjust for wrap-around
    term2 = 0.0
    if den2 > 0:
        term2 = ((k_ip1 - u) / den2) * bspline_basis_periodic(u, i + 1, p - 1, knots, n)
 
    return term1 + term2
# Custom interoperations for greencurve using NURBS with local kappa adjustment for closure
def custom_interoperations_green_curve(points, kappas, is_closed=False):
    """
    Custom Non-Uniform Rational Kappa Spline (NURKS) approximation for green curve with closure adjustments.
    For closed curves, extends control points on both sides and shifts knot vector for smooth periodicity.
    """
    points = np.array(points)
    kappas = np.array(kappas)
    degree = 3 # Fixed degree for continuity
    num_output_points = 1000
 
    if is_closed and len(points) > degree:
        n = len(points)
        extended_points = np.concatenate((points[n-degree:], points, points[0:degree]))
        extended_kappas = np.concatenate((kappas[n-degree:], kappas, kappas[0:degree]))
        len_extended = len(extended_points)
        knots = np.linspace(-degree / float(n), 1 + degree / float(n), len_extended + 1)
 
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
 
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
 
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len_extended):
                b = bspline_basis(u, i, degree, knots)
                w = extended_kappas[i] * b
                num_x += w * extended_points[i, 0]
                num_y += w * extended_points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
 
        smooth_x = np.append(smooth_x, smooth_x[0])
        smooth_y = np.append(smooth_y, smooth_y[0])
 
    else:
        # Cumsum of distances for open
        t = np.cumsum([0] + [np.linalg.norm(points[i+1] - points[i]) for i in range(len(points)-1)])
        knots = np.concatenate(([0] * (degree + 1), t / t[-1] if t[-1] > 0 else np.linspace(0, 1, len(t)), [1] * (degree)))
 
        u_fine = np.linspace(0, 1, num_output_points, endpoint=False)
 
        smooth_x = np.zeros(num_output_points)
        smooth_y = np.zeros(num_output_points)
 
        for j, u in enumerate(u_fine):
            num_x, num_y, den = 0.0, 0.0, 0.0
            for i in range(len(points)):
                b = bspline_basis(u, i, degree, knots)
                w = kappas[i] * b if i < len(kappas) else kappas[-1] * b
                num_x += w * points[i, 0]
                num_y += w * points[i, 1]
                den += w
            if den > 0:
                smooth_x[j] = num_x / den
                smooth_y[j] = num_y / den
 
    return smooth_x, smooth_y
# Compute kappa for a segment, second endpoint influences next kappa
def compute_segment_kappa(p1, p2, base_kappa=1.0, prev_kappa=1.0):
    x1, y1 = p1
    x2, y2 = p2
    theta = np.sqrt((x2 - x1)**2 + (y2 - y1)**2) # Theta is distance
    if theta < 1e-10:
        return prev_kappa
    decay_factor = np.exp(-theta / WIDTH / 20.0) # Further reduced decay rate
    return prev_kappa * decay_factor * base_kappa
# Recalculate kappas after changes (e.g., closure or node move) for consistency
def recalculate_kappas():
    global previous_kappa
    previous_kappa = kappas[0] # Start with first kappa
    for i in range(1, len(drawing_points)):
        kappas[i] = compute_segment_kappa(drawing_points[i-1], drawing_points[i], curvature, previous_kappa)
        previous_kappa = kappas[i]
# Update 3D model on changes (e.g., height slider or curve update)
def update_3d_model():
    global current_vertices, current_faces
    if green_curve_line:
        x_curve, y_curve = green_curve_line.get_data()
        if is_closed and np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)), height=height)
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
# Golden window calculation
def compute_golden_window(x_spiral, y_spiral):
    idx_crossings = np.where(np.diff(np.sign(x_spiral - PURPLE_LINES[0] * WIDTH)))[0]
    if len(idx_crossings) >= 2:
        y1 = y_spiral[idx_crossings[0]]
        y2 = y_spiral[idx_crossings[1]]
        return np.abs(y2 - y1), min(y1, y2), max(y1, y2)
    return 0, 0, 0
# Compute vanishing point for a triangulation
def compute_vanishing_point(tri_points, eye_distance=EYE_DISTANCE):
    mid_x = np.mean([p[0] for p in tri_points])
    mid_y = np.mean([p[1] for p in tri_points])
    vx = mid_x
    vy = HORIZON_HEIGHT + eye_distance * (mid_y - EYE_LINE) / WIDTH
    return vx, vy
# Redraw green curve
def redraw_green_curve(is_closed=False):
    global green_curve_line
    if green_curve_line:
        green_curve_line.remove()
        green_curve_line = None
    if len(drawing_points) >= 2:
        adjusted_kappas = kappas.copy()
        if is_closed and len(adjusted_kappas) > 1:
            adjusted_kappas[1] = 1.5 * adjusted_kappas[1] # Local kappa adjustment for ellipse conditions
        x_green, y_green = custom_interoperations_green_curve(drawing_points, adjusted_kappas, is_closed=is_closed)
        green_curve_line, = ax_2d.plot(x_green, y_green, 'g-', label='Green Curve' if green_curve_line is None else None)
    fig_2d.canvas.draw()
# Setup figures
fig_2d = plt.figure(figsize=(14, 8))
ax_2d = fig_2d.add_subplot(111)
fig_3d = plt.figure(figsize=(10, 6))
ax_3d = fig_3d.add_subplot(111, projection='3d')
fig_controls = plt.figure(figsize=(4, 8))
ax_curvature = fig_controls.add_axes([0.2, 0.8, 0.6, 0.03])
curvature_slider = Slider(ax_curvature, 'Curvature (kappa)', 0.1, 2.0, valinit=curvature)
ax_height = fig_controls.add_axes([0.2, 0.7, 0.6, 0.03])
height_slider = Slider(ax_height, 'Height', 0.1, 2.0, valinit=height)
ax_rings = fig_controls.add_axes([0.2, 0.6, 0.6, 0.03])
rings_slider = Slider(ax_rings, 'Rings', 5, 50, valinit=num_rings, valstep=1)
ax_level = fig_controls.add_axes([0.2, 0.5, 0.6, 0.03])
level_slider = Slider(ax_level, 'Fractal Level', 0, 5, valinit=fractal_level, valstep=1)
ax_radial = fig_controls.add_axes([0.2, 0.4, 0.6, 0.03])
radial_slider = Slider(ax_radial, 'Radial Chord', 0.1, 1.0, valinit=radial_chord)
ax_tangential = fig_controls.add_axes([0.2, 0.3, 0.6, 0.03])
tangential_slider = Slider(ax_tangential, 'Tangential Chord', 0.0, 0.5, valinit=tangential_chord)
ax_height_chord = fig_controls.add_axes([0.2, 0.2, 0.6, 0.03])
height_chord_slider = Slider(ax_height_chord, 'Height Chord', 0.0, 0.5, valinit=height_chord)
# Plot A3 page
ax_2d.plot([0, WIDTH, WIDTH, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k-', label='A3 Landscape Page')
for x in PURPLE_LINES:
    ax_2d.plot([x * WIDTH, x * WIDTH], [0, HEIGHT], 'm-', label='Purple Dividers' if x == PURPLE_LINES[0] else None)
# Horizon line
horizon_line, = ax_2d.plot([0, WIDTH], [HORIZON_HEIGHT, HORIZON_HEIGHT], 'b:', label='Horizon/Eye Line')
# Golden spiral
x_spiral, y_spiral = compute_golden_spiral()
golden_spiral, = ax_2d.plot(x_spiral + WIDTH/2, y_spiral + HEIGHT/2, 'gold', label='Golden Spiral')
# Golden window
golden_window, y_min, y_max = compute_golden_window(x_spiral + WIDTH/2, y_spiral + HEIGHT/2)
ax_2d.fill_between([PURPLE_LINES[0] * WIDTH - 0.05, PURPLE_LINES[0] * WIDTH + 0.05], y_min, y_max, color='yellow', alpha=0.5, label='Golden Window')
# Ghost curve init
ghost_curve, = ax_2d.plot([], [], 'g--', label='Ghost Curve Preview')
# Control indicators in legend
ax_2d.plot([], [], ' ', label='R: Toggle draw mode')
ax_2d.plot([], [], 'b--', label='A: Toggle protractor')
ax_2d.plot([], [], 'c-', label='M: Toggle measure (ruler)')
ax_2d.plot([], [], ' ', label='D: Toggle dimension')
ax_2d.plot([], [], 'r-', label='C: Close polyhedron (manual)')
ax_2d.plot([], [], ' ', label='Click near first point to close')
ax_2d.plot([], [], ' ', label='Click to select curve')
ax_2d.plot([], [], ' ', label='G: To construction geom')
ax_2d.plot([], [], ' ', label='H: Hide/show')
ax_2d.plot([], [], ' ', label='E: Reset canvas')
ax_2d.plot([], [], ' ', label='S: Export STL')
ax_2d.plot([], [], 'k-', label='Curvature Slider (Controls window)')
# Update curvature
def update_curvature(val):
    global curvature
    curvature = val
    if len(drawing_points) >= 1:
        kappas[-1] = curvature
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
    fig_2d.canvas.draw()
curvature_slider.on_changed(update_curvature)
# Update height
def update_height(val):
    global height
    height = val
    if is_closed:
        update_3d_model()
height_slider.on_changed(update_height)
# Update rings
def update_rings(val):
    global num_rings
    num_rings = int(val)
    if is_closed:
        update_3d_model()
rings_slider.on_changed(update_rings)
# Update fractal level
def update_level(val):
    global fractal_level
    fractal_level = int(val)
    if is_closed:
        update_3d_model()
level_slider.on_changed(update_level)
# Update radial chord
def update_radial(val):
    global radial_chord
    radial_chord = val
    if is_closed:
        update_3d_model()
radial_slider.on_changed(update_radial)
# Update tangential chord
def update_tangential(val):
    global tangential_chord
    tangential_chord = val
    if is_closed:
        update_3d_model()
tangential_slider.on_changed(update_tangential)
# Update height chord
def update_height_chord(val):
    global height_chord
    height_chord = val
    if is_closed:
        update_3d_model()
height_chord_slider.on_changed(update_height_chord)
# Toggle draw mode
def toggle_draw(event):
    global draw_mode
    if event.key == 'r':
        draw_mode = not draw_mode
        print(f"Draw mode {'enabled' if draw_mode else 'disabled'}")
        fig_2d.canvas.draw()
# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        if not protractor_active:
            if protractor_line:
                protractor_line.remove()
                protractor_line = None
            if protractor_text:
                protractor_text.remove()
                protractor_text = None
            protractor_points.clear()
        fig_2d.canvas.draw()
# On click for protractor
def on_click_protractor(event):
    global protractor_line, protractor_text, last_angle
    if protractor_active and event.inaxes == ax_2d and event.button == 1:
        protractor_points.append((event.xdata, event.ydata))
        if len(protractor_points) == 2:
            x1, y1 = protractor_points[0]
            x2, y2 = protractor_points[1]
            if protractor_line:
                protractor_line.remove()
            protractor_line, = ax_2d.plot([x1, x2], [y1, y2], 'b--')
            dx = x2 - x1
            dy = y2 - y1
            angle = np.arctan2(dy, dx) * 180 / np.pi
            last_angle = angle
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if protractor_text:
                protractor_text.remove()
            protractor_text = ax_2d.text(mid_x, mid_y, f'Angle: {angle:.2f}°', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            protractor_points.clear()
            fig_2d.canvas.draw()
# Toggle ruler (measure)
def toggle_ruler(event):
    global ruler_active
    if event.key == 'm':
        ruler_active = not ruler_active
        print(f"Measure (ruler) tool {'enabled' if ruler_active else 'disabled'}")
        if not ruler_active:
            if ruler_line:
                ruler_line.remove()
                ruler_line = None
            if ruler_text:
                ruler_text.remove()
                ruler_text = None
            ruler_points.clear()
        fig_2d.canvas.draw()
# On click for ruler
def on_click_ruler(event):
    global ruler_line, ruler_text
    if ruler_active and event.inaxes == ax_2d and event.button == 1:
        ruler_points.append((event.xdata, event.ydata))
        if len(ruler_points) == 2:
            x1, y1 = ruler_points[0]
            x2, y2 = ruler_points[1]
            if ruler_line:
                ruler_line.remove()
            ruler_line, = ax_2d.plot([x1, x2], [y1, y2], 'c-')
            dx = x2 - x1
            dy = y2 - y1
            dist = np.sqrt(dx**2 + dy**2)
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if ruler_text:
                ruler_text.remove()
            ruler_text = ax_2d.text(mid_x, mid_y, f'Dist: {dist:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            ruler_points.clear()
            fig_2d.canvas.draw()
# Toggle dimension
def toggle_dimension(event):
    global dimension_active
    if event.key == 'd':
        dimension_active = not dimension_active
        print(f"Dimension tool {'enabled' if dimension_active else 'disabled'}")
        fig_2d.canvas.draw()
# On click for dimension
def on_click_dimension(event):
    if dimension_active and event.inaxes == ax_2d and event.button == 1:
        if ruler_active and ruler_text:
            dimension_labels.append(ruler_text)
        elif selected_curve:
            x, y = selected_curve.get_data()
            length = np.sum(np.sqrt(np.diff(x)**2 + np.diff(y)**2))
            mid_x = np.mean(x)
            mid_y = np.mean(y)
            dim_text = ax_2d.text(mid_x, mid_y + 0.05, f'Len: {length:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            dimension_labels.append(dim_text)
        fig_2d.canvas.draw()
# Toggle pro mode (lock/unlock)
def toggle_pro_mode(event):
    global pro_mode
    if event.key == 'x':
        pro_mode = not pro_mode
        print(f"Pro mode {'locked' if pro_mode else 'unlocked'}")
        fig_2d.canvas.draw()
# On pick event for nodes
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow') # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()
# Show ghost handles (theta points, midpoints between nodes)
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow') # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()
# Show ghost handles (theta points, midpoints between nodes)
def show_ghost_handles():
    global ghost_handles
    for handle in ghost_handles:
        handle.remove()
    ghost_handles = []
    num_points = len(drawing_points) if not is_closed else len(drawing_points) - 1 # Avoid double midpoint on close
    for i in range(num_points):
        next_i = (i + 1) % len(drawing_points) if is_closed else i + 1
        if next_i >= len(drawing_points):
            continue
        mid_x = (drawing_points[i][0] + drawing_points[next_i][0]) / 2
        mid_y = (drawing_points[i][1] + drawing_points[next_i][1]) / 2
        handle = ax_2d.scatter(mid_x, mid_y, color='yellow', s=30, marker='o')
        ghost_handles.append(handle)
    fig_2d.canvas.draw()
# On button press for dragging
def on_button_press(event):
    global dragging
    if pro_mode and selected_node_index != -1 and event.inaxes == ax_2d and event.button == 1:
        dragging = True
# On button release for dragging
def on_button_release(event):
    global dragging
    dragging = False
# On motion for dragging and preview
def on_motion(event):
    global previous_kappa, dragging, selected_node_index
    if dragging and pro_mode and selected_node_index != -1 and event.inaxes == ax_2d:
        drawing_points[selected_node_index] = (event.xdata, event.ydata)
        node_scatter[selected_node_index].set_offsets([[event.xdata, event.ydata]])
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
        fig_2d.canvas.draw()
        return
    if draw_mode and len(drawing_points) > 0 and event.inaxes == ax_2d and not (protractor_active or ruler_active or dimension_active):
        x, y = event.xdata, event.ydata
        preview_points = drawing_points + [(x, y)]
        preview_kappas = kappas + [curvature]
        close_preview = False
        if len(preview_points) > 2:
            dx_first = x - drawing_points[0][0]
            dy_first = y - drawing_points[0][1]
            dist_first = np.sqrt(dx_first**2 + dy_first**2)
            if dist_first < CLOSE_THRESHOLD:
                preview_points[-1] = drawing_points[0]
                preview_kappas[-1] = curvature
                # Preview kappa1 adjustment for closure
                last_theta = np.sqrt((drawing_points[-1][0] - preview_points[-1][0])**2 + (drawing_points[-1][1] - preview_points[-1][1])**2)
                if last_theta < 1e-10: # Manage '0' snap error in preview
                    last_theta = 1e-10
                decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                preview_kappas[0] = preview_kappas[-1] * decay_factor * curvature
                close_preview = True
        # Compute kappa for preview segment (cursor at theta)
        if len(preview_points) > 1:
            preview_kappa = compute_segment_kappa(preview_points[-2], preview_points[-1], curvature, previous_kappa)
            preview_kappas[-1] = preview_kappa
        x_ghost, y_ghost = custom_interoperations_green_curve(preview_points, preview_kappas, is_closed=close_preview)
        ghost_curve.set_data(x_ghost, y_ghost)
        fig_2d.canvas.draw()
# Generate G-code for the curve with variable speeds (for 2D plotting/CNC, scaled to mm)
def generate_gcode(x, y, speeds, scale=297):
    """
    Generates simple G-code for linear moves along the curve with variable feedrates.
    Args:
        x (array): X coordinates (normalized).
        y (array): Y coordinates (normalized).
        speeds (list): Normalized speeds (0-1) for each point.
        scale (float): Scale factor to convert normalized units to mm (based on A3 height=297mm).
    Returns:
        str: G-code string.
    """
    gcode = "G21 ; Set units to millimeters\n"
    gcode += "G90 ; Absolute positioning\n"
    # Move to start position (rapid)
    gcode += f"G0 X{x[0] * scale:.2f} Y{y[0] * scale:.2f}\n"
    # Linear moves with varying feedrate
    for i in range(1, len(x)):
        feedrate = speeds[i] * 900 + 100 # Scale speed to 100-1000 mm/min
        gcode += f"G1 X{x[i] * scale:.2f} Y{y[i] * scale:.2f} F{feedrate:.0f}\n"
    return gcode
# Drawing mode: Add kappa nodes and update continuous greencurve
def on_click_draw(event):
    global green_curve_line, selected_curve, previous_kappa, vanishing_points, current_vertices, current_faces, is_closed
    if event.inaxes == ax_2d and event.button == 1:
        x, y = event.xdata, event.ydata
        # Snap to dividers if close (UX improvement for precise alignment)
        for div in PURPLE_LINES:
            div_x = div * WIDTH
            if abs(x - div_x) < SNAP_THRESHOLD:
                x = div_x
                break
        if draw_mode and not (protractor_active or ruler_active or dimension_active):
            # Check if near first point to close
            if len(drawing_points) > 2:
                dx_first = x - drawing_points[0][0]
                dy_first = y - drawing_points[0][1]
                dist_first = np.sqrt(dx_first**2 + dy_first**2)
                if dist_first < CLOSE_THRESHOLD:
                    # Adjust kappa1 based on last theta and kappa
                    last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
                    if last_theta < 1e-10: # Manage '0' snap error
                        last_theta = 1e-10
                    decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                    kappas[0] = kappas[-1] * decay_factor * curvature # Affect kappa1 with last kappa and decay
                    drawing_points.append(drawing_points[0])
                    kappas.append(kappas[0]) # Last kappa inherits first kappa's theta (via same value)
                    recalculate_kappas() # Recalculate for closure consistency
                    is_closed = True
                    redraw_green_curve(is_closed=True) # Use closed NURKS for ellipse conditions
                    # Get closed curve
                    x_curve, y_curve = green_curve_line.get_data()
                    if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
                        x_curve = np.append(x_curve, x_curve[0])
                        y_curve = np.append(y_curve, y_curve[0])
                    ax_3d.cla()
                    current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
                    verts = [[current_vertices[i] for i in f] for f in current_faces]
                    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
                    ax_3d.set_xlabel('X')
                    ax_3d.set_ylabel('Y')
                    ax_3d.set_zlabel('Z')
                    ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
                    fig_3d.canvas.draw()
                    print("Polyhedron closed and 3D model generated")
                    # Compute and print speeds for user generated curve
                    print("User Generated Curve Speeds:")
                    speeds = []
                    for i in range(len(x_curve)):
                        speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
                        print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
                        speeds.append(speed)
                    # Generate G-Code
                    gcode = generate_gcode(x_curve, y_curve, speeds)
                    with open('model.gcode', 'w') as f:
                        f.write(gcode)
                    print("G-Code saved to model.gcode")
                    print(gcode)
                    fig_2d.canvas.draw()
                    return
            # Add new kappa node (first endpoint)
            roygbiv = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
            color = roygbiv[len(drawing_points) % 7]
            node = ax_2d.scatter(x, y, color=color, s=50, picker=True, label='Kappa Node' if len(drawing_points) == 0 else None)
            node_scatter.append(node)
            original_colors.append(color)
            drawing_points.append((x, y))
            kappas.append(curvature)
            if len(drawing_points) > 1:
                previous_kappa = compute_segment_kappa(drawing_points[-2], drawing_points[-1], curvature, previous_kappa)
                redraw_green_curve(is_closed=is_closed)
                if len(drawing_points) >= 2:
                    t = np.linspace(0, 1, 100)
                    x_green, y_green = green_curve_line.get_data()
                    curv = compute_curvature(x_green, y_green, t)
                    print(f"Green curve curvature: Max={curv.max():.4f}, Min={curv.min():.4f}")
            if len(drawing_points) >= 3:
                print("Third point added: Introducing depth and triangulation")
                tri_points = drawing_points[-3:]
                vp = compute_vanishing_point(tri_points)
                vanishing_points.append(vp)
                ax_2d.scatter(vp[0], vp[1], color='purple', s=30, label='Vanishing Point' if len(vanishing_points) == 1 else None)
            fig_2d.canvas.draw()
        elif not draw_mode and not (protractor_active or ruler_active or dimension_active):
            min_dist = float('inf')
            selected_curve = None
            if green_curve_line:
                x_curve, y_curve = green_curve_line.get_data()
                dist = np.min(np.sqrt((x_curve - x)**2 + (y_curve - y)**2))
                if dist < min_dist and dist < 0.05:
                    min_dist = dist
                    selected_curve = green_curve_line
            if selected_curve:
                selected_curve.set_linewidth(3.0)
                print("Green curve selected")
                fig_2d.canvas.draw()
# Close polyhedron (manual trigger)
def close_polyhedron(event):
    if event.key == 'c':
        print("Close via clicking near first point when ghosted")
# Auto close on 'c'
def auto_close(event):
    global is_closed, drawing_points, kappas, previous_kappa
    if event.key == 'c' and len(drawing_points) > 2:
        # Adjust kappa1 based on last theta and kappa
        last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
        if last_theta < 1e-10: # Manage '0' snap error
            last_theta = 1e-10
        decay_factor = np.exp(-last_theta / WIDTH / 20.0)
        kappas[0] = kappas[-1] * decay_factor * curvature # Affect kappa1 with last kappa and decay
        drawing_points.append(drawing_points[0])
        kappas.append(kappas[0]) # Last kappa inherits first kappa's theta (via same value)
        recalculate_kappas() # Recalculate for closure consistency
        is_closed = True
        redraw_green_curve(is_closed=True) # Use closed NURKS for ellipse conditions
        # Get closed curve
        x_curve, y_curve = green_curve_line.get_data()
        if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
        print("Polyhedron closed and 3D model generated")
        # Compute and print speeds for user generated curve
        print("User Generated Curve Speeds:")
        speeds = []
        for i in range(len(x_curve)):
            speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
            print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
            speeds.append(speed)
        # Generate G-Code
        gcode = generate_gcode(x_curve, y_curve, speeds)
        with open('model.gcode', 'w') as f:
            f.write(gcode)
        print("G-Code saved to model.gcode")
        print(gcode)
        fig_2d.canvas.draw()
# Change to construction geometry
def to_construction(event):
    global selected_curve
    if event.key == 'g' and selected_curve:
        selected_curve.set_linestyle('--')
        selected_curve.set_color('gray')
        print("Green curve changed to construction geometry")
        selected_curve = None
        fig_2d.canvas.draw()
# Hide/show
def hide_show(event):
    global hidden_elements, selected_curve
    if event.key == 'h':
        if selected_curve:
            if selected_curve.get_visible():
                selected_curve.set_visible(False)
                hidden_elements.append(selected_curve)
                print("Green curve hidden")
            else:
                selected_curve.set_visible(True)
                if selected_curve in hidden_elements:
                    hidden_elements.remove(selected_curve)
                print("Green curve shown")
            selected_curve = None
        else:
            for elem in hidden_elements:
                elem.set_visible(True)
            hidden_elements.clear()
            print("All hidden elements shown")
        fig_2d.canvas.draw()
# Reset canvas
def reset_canvas(event):
    global drawing_points, kappas, previous_kappa, green_curve_line, vanishing_points, selected_curve, current_vertices, current_faces, last_angle, node_scatter, ghost_handles, is_closed, original_colors
    if event.key == 'e':
        drawing_points = []
        kappas = []
        previous_kappa = 1.0
        if green_curve_line:
            green_curve_line.remove()
            green_curve_line = None
        for node in node_scatter:
            node.remove()
        node_scatter = []
        original_colors = []
        for handle in ghost_handles:
            handle.remove()
        ghost_handles = []
        vanishing_points = []
        selected_curve = None
        ax_3d.cla()
        current_vertices = None
        current_faces = None
        last_angle = 0.0
        is_closed = False
        display_pod_surface()
        print("Canvas reset")
        fig_2d.canvas.draw()
# Compute curvature for continuity check
def compute_curvature(x, y, t):
    dt = t[1] - t[0]
    dx_dt = np.gradient(x, dt)
    dy_dt = np.gradient(y, dt)
    d2x_dt2 = np.gradient(dx_dt, dt)
    d2y_dt2 = np.gradient(dy_dt, dt)
    numerator = np.abs(dx_dt * d2y_dt2 - dy_dt * d2x_dt2)
    denominator = (dx_dt**2 + dy_dt**2)**1.5
    denominator = np.where(denominator == 0, 1e-10, denominator)
    return numerator / denominator
# Generate base pod curve (closed for boundary surface, now 3D curve)
def generate_pod_curve_closed(num_points=200, phase=0.0): # Increased num_points for better resolution
    t = np.linspace(0, 2 * np.pi, num_points) # Full closed loop
    r = radial_chord + tangential_chord * np.cos(6 * t + phase) # Flower-like top profile
    x = r * np.cos(t)
    y = r * np.sin(t)
    z = height_chord * np.sin(6 * t + phase) # Add z variation for 3D curve
    return x, y, z
# Function to compute normals
def compute_normal(v1, v2, v3):
    vec1 = v2 - v1
    vec2 = v3 - v1
    normal = np.cross(vec1, vec2)
    norm = np.linalg.norm(normal)
    return normal / norm if norm != 0 else normal
# Export current model to STL
def export_stl():
    global current_vertices, current_faces
    if current_vertices is None or current_faces is None:
        print("No model to export")
        return
    stl_data = b'\x00' * 80 # Header
    stl_data += struct.pack('<I', len(current_faces)) # Number of triangles
    for face in current_faces:
        v1 = current_vertices[face[0]]
        v2 = current_vertices[face[1]]
        v3 = current_vertices[face[2]]
        normal = compute_normal(v1, v2, v3)
        stl_data += struct.pack('<3f', *normal)
        stl_data += struct.pack('<3f', *v1)
        stl_data += struct.pack('<3f', *v2)
        stl_data += struct.pack('<3f', *v3)
        stl_data += b'\x00\x00' # Attribute byte count
    filename = 'model.stl'
    with open(filename, 'wb') as f:
        f.write(stl_data)
    print(f"Saved to {filename}")
    stl_base64 = base64.b64encode(stl_data).decode('utf-8')
    print("Base64 STL:")
    print(stl_base64)
# Save STL on key press
def save_stl(event):
    if event.key == 's':
        export_stl()
# Display pod surface by default in 3D with curvature continuous end caps
def display_pod_surface():
    global current_vertices, current_faces
    x_curve, y_curve, z_curve = generate_pod_curve_closed(200) # Increased for resolution
    current_vertices, current_faces = build_mesh(x_curve, y_curve, z_curve)
    verts = [[current_vertices[i] for i in f] for f in current_faces]
    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
    ax_3d.set_xlabel('X')
    ax_3d.set_ylabel('Y')
    ax_3d.set_zlabel('Z')
    ax_3d.set_title('3D pod Projected Surface (Compound Curvature with End Caps)')
    fig_3d.canvas.draw()
# Draw default pod ellipse as green curve on 2D canvas
def draw_default_pod(ax, color='g'):
    x, y, _ = generate_pod_curve_closed(num_points=36) # Increased to 36 for better flower
    x_control = x[:-1]
    y_control = y[:-1]
    scale = 0.6 # Scale for large curve
    x_control *= scale
    y_control *= scale
    x_control += WIDTH / 2
    y_control += HEIGHT / 2
    points = list(zip(x_control, y_control))
    kappas_pod = [1.0] * len(points)
    x_interp, y_interp = custom_interoperations_green_curve(points, kappas_pod, is_closed=True)
    ax.plot(x_interp, y_interp, color=color, linewidth=3, linestyle='-')
    # Compute and print speeds for default curve
    print("Default Curve Speeds:")
    for i in range(len(x_interp)):
        speed = int(hashlib.sha256(f"{x_interp[i]}{y_interp[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
        print(f"Point {i}: ({x_interp[i]:.4f}, {y_interp[i]:.4f}), Speed: {speed:.4f}")
# Add Mersenne elements to the plot
# First A4 page (adjusted)
ax_2d.plot([0, WIDTH/2, WIDTH/2, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 1')
# Second A4 page
ax_2d.plot([WIDTH/2, WIDTH, WIDTH, WIDTH/2, WIDTH/2], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 2')
# Purple lines (in first A4)
for x in PURPLE_LINES:
    ax_2d.plot([x * (WIDTH/2), x * (WIDTH/2)], [0, HEIGHT], 'm-')
# Red datum line
ax_2d.plot([0, WIDTH], [0, 0], 'r-')
# A4 short edge divisions (first A4 only)
for x in division_positions:
    ax_2d.plot([x, x], [0, 0.02], 'k-', alpha=0.3)
# Plot circle division markers
for x_marker, y_marker in circle_markers:
    ax_2d.plot(x_marker, y_marker, 'k.', markersize=3)
# Full spiral
ax_2d.plot(x_full, y_full, 'k-')
# Green segment
ax_2d.plot(x_green_final, y_green_scaled, 'g-')
# 52 Mersenne prime curves
for i, (x_new, y_new, label) in enumerate(curves):
    line, = ax_2d.plot(x_new, y_new, color=colors[i])
    curve_lines[i] = line
# Flags and staggered labels
label_y_offset = 0.05
for i, (x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq) in enumerate(flag_positions):
    ax_2d.plot([x_end, x_start], [y_end, y_start], 'k--', alpha=0.3)
    ax_2d.plot([x_start, x_flag], [y_start, y_flag], 'k-', alpha=0.5)
    y_label = y_flag - (i % 5) * label_y_offset
    text = ax_2d.text(x_flag, y_label, label, ha='left', va='top', fontsize=6, rotation=45, picker=5)
    harmonic_text = ax_2d.text(x_flag, y_label - 0.1, f"{freq:.1f} Hz", ha='left', va='top', fontsize=6, rotation=45, visible=False)
    annotation_objects.append((text, i))
    harmonic_texts.append(harmonic_text)
# Golden window 1 (vertical at x = 1/3)
idx_crossings_x = np.where(np.diff(np.sign(x_full - PURPLE_LINES[0])))[0]
if len(idx_crossings_x) >= 2:
    y1 = y_full[idx_crossings_x[0]]
    y2 = y_full[idx_crossings_x[1]]
    golden_window_1 = np.abs(y2 - y1)
    print(f"Golden Window 1 at x={PURPLE_LINES[0]}: {golden_window_1:.4f}")
    ax_2d.fill_between([PURPLE_LINES[0] - 0.05, PURPLE_LINES[0] + 0.05], min(y1, y2), max(y1, y2), color='yellow', alpha=0.5)
# Golden window 2 (horizontal at y = 1/3)
idx_crossings_y = np.where(np.diff(np.sign(y_full - 1/3)))[0]
if len(idx_crossings_y) >= 2:
    x1 = x_full[idx_crossings_y[0]]
    x2 = x_full[idx_crossings_y[1]]
    golden_window_2 = np.abs(x2 - x1)
    print(f"Golden Window 2 at y=1/3: {golden_window_2:.4f}")
    ax_2d.fill_betweenx([1/3 - 0.05, 1/3 + 0.05], min(x1, x2), max(x1, x2), color='orange', alpha=0.5)
# Scale label
ax_2d.text(WIDTH, 1.10337, scale_label, ha='right', va='bottom', fontsize=8)
# Update title with scale key
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
# Highlighting functionality for Mersenne labels
highlighted = [None, None]
def on_pick_mersenne(event):
    global highlighted
    artist = event.artist
    for text, idx in annotation_objects:
        if artist == text:
            if highlighted[0] is not None:
                highlighted[0].set_color('black')
                highlighted[0].set_weight('normal')
                curve_lines[highlighted[1]].set_linewidth(1.0)
                curve_lines[highlighted[1]].set_color(colors[highlighted[1]])
            text.set_color('red')
            text.set_weight('bold')
            curve_lines[idx].set_linewidth(2.0)
            curve_lines[idx].set_color('red')
            highlighted = [text, idx]
            fig_2d.canvas.draw()
            break
def on_click_deselect(event):
    global highlighted
    if event.inaxes != ax_2d:
        return
    clicked_on_annotation = False
    for text, idx in annotation_objects:
        if text.contains(event)[0]:
            clicked_on_annotation = True
            break
    if not clicked_on_annotation and highlighted[0] is not None:
        highlighted[0].set_color('black')
        highlighted[0].set_weight('normal')
        curve_lines[highlighted[1]].set_linewidth(1.0)
        curve_lines[highlighted[1]].set_color(colors[highlighted[1]])
        highlighted = [None, None]
        fig_2d.canvas.draw()
# Curve cache for hashing
curve_cache = {}
def compute_curve_points(theta_start, theta_end, num_points, scale_factor, rotation_angle=0):
    # Create a hash key based on parameters
    key = f"{theta_start:.2f}:{theta_end:.2f}:{num_points}:{scale_factor:.4f}:{rotation_angle:.2f}"
    key_hash = hashlib.md5(key.encode()).hexdigest()
    if key_hash in curve_cache:
        return curve_cache[key_hash]
    theta = np.linspace(theta_start, theta_end, num_points)
    r = scale_factor * A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Apply rotation
    if rotation_angle != 0:
        angle_rad = np.deg2rad(rotation_angle)
        x_rot = x * np.cos(angle_rad) - y * np.sin(angle_rad)
        y_rot = x * np.sin(angle_rad) + y * np.cos(angle_rad)
        x, y = x_rot, y_rot
    curve_cache[key_hash] = (x, y)
    return x, y
# Dynamic LOD
def get_num_points_for_curve():
    xlim = ax_2d.get_xlim()
    ylim = ax_2d.get_ylim()
    view_width = xlim[1] - xlim[0]
    view_height = ylim[1] - ylim[0]
    # Base number of points when fully zoomed out
    base_points = 20
    max_points = 200
    # Zoom factor: smaller view range means more zoom
    full_range = WIDTH # Full x-range when zoomed out
    zoom_factor = full_range / view_width
    num_points = int(base_points + (max_points - base_points) * min(zoom_factor / 10, 1))
    return max(base_points, min(max_points, num_points))
# Cursor, spiral, and circumference setup
cursor, = ax_2d.plot([], [], 'ro', markersize=8, label='κ Spiral Cursor', visible=False)
cursor_spiral, = ax_2d.plot([], [], 'g-', alpha=0.5, visible=False)
cursor_circumference = plt.Circle((0, 0), 0, color='b', fill=False, linestyle='--', alpha=0.5, visible=False)
ax_2d.add_patch(cursor_circumference)
cursor_text = ax_2d.text(WIDTH / 2, 1.15, '', ha='center', va='bottom', fontsize=8, visible=False)
baseline_spiral, = ax_2d.plot([], [], 'g-', alpha=0.5, label='Baseline Spiral', visible=False)
baseline_spiral_2, = ax_2d.plot([], [], 'g-', alpha=0.5, label='Baseline Spiral 2', visible=False)
# Crosslines
vertical_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
horizontal_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
vertical_label = ax_2d.text(target_chord, HEIGHT + 0.05, f'Chord: {target_chord:.4f}', ha='center', va='bottom', fontsize=8, visible=False)
# Protractor elements
protractor_line, = ax_2d.plot([], [], 'b-', alpha=0.8, visible=False)
protractor_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8), visible=False)
protractor_arc, = ax_2d.plot([], [], 'b-', alpha=0.5, visible=False)
protractor_spiral_2, = ax_2d.plot([], [], 'g-', alpha=0.5, visible=False)
# Baseline angle (grey ghost line)
baseline_angle_line, = ax_2d.plot([0, WIDTH], [0, 0], 'grey', alpha=0.3, linestyle='--', visible=False)
# Swinging ghost curves
ghost_curves = []
for _ in range(4): # ±5°, ±10° (4 curves total)
    line, = ax_2d.plot([], [], 'grey', alpha=0.2, visible=False)
    ghost_curves.append(line)
# Ruler elements
ruler_divisions = []
for _ in range(10): # Up to 10 division markers
    marker, = ax_2d.plot([], [], 'k|', markersize=10, markeredgewidth=2, visible=False)
    ruler_divisions.append(marker)
ruler_vanishing_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        cursor.set_visible(protractor_active)
        cursor_spiral.set_visible(protractor_active)
        cursor_circumference.set_visible(protractor_active)
        cursor_text.set_visible(protractor_active)
        baseline_spiral.set_visible(protractor_active)
        baseline_spiral_2.set_visible(protractor_active)
        vertical_line.set_visible(protractor_active)
        horizontal_line.set_visible(protractor_active)
        vertical_label.set_visible(protractor_active)
        protractor_line.set_visible(protractor_active)
        protractor_text.set_visible(protractor_active)
        protractor_arc.set_visible(protractor_active)
        protractor_spiral_2.set_visible(protractor_active)
        baseline_angle_line.set_visible(protractor_active)
        for curve in ghost_curves:
            curve.set_visible(protractor_active)
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        fig_2d.canvas.draw()
# On motion for protractor
def on_motion_protractor(event):
    if not protractor_active or event.inaxes != ax_2d:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    # Update cursor position
    cursor.set_data([x], [y])
    # Update circumference
    radius = np.sqrt(x**2 + y**2)
    cursor_circumference.set_center((x, y))
    cursor_circumference.set_radius(radius)
    # Dynamic LOD: Adjust number of points based on zoom
    num_points = get_num_points_for_curve()
    # Update cursor spiral
    x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
    cursor_spiral.set_data(x + x_spiral, y + y_spiral)
    # Update baseline spiral (indexed at (0,0))
    x_base = 0.0
    scale_factor = (event.xdata / WIDTH) if event.xdata > 0 else 0.01
    scaled_a = A_SPIRAL * scale_factor
    height_factor = (event.ydata / HEIGHT) if event.ydata > 0 else 0.01
    x_base_spiral, y_base_spiral = compute_curve_points(2 * np.pi, np.pi, num_points, scale_factor)
    x_base_spiral = x_base + x_base_spiral * np.abs(np.cos(np.linspace(2 * np.pi, np.pi, num_points)))
    y_base_spiral = y_base_spiral * height_factor
    baseline_spiral.set_data(x_base_spiral, y_base_spiral)
    # Compute the chord length of the baseline spiral
    x_start = x_base_spiral[0]
    y_start = y_base_spiral[0]
    x_end = x_base_spiral[-1]
    y_end = y_base_spiral[-1]
    baseline_chord = np.sqrt((x_end - x_start)**2 + (y_end - y_start)**2)
    # Update second baseline spiral (indexed at (1.0, 0))
    x_base_2 = 1.0
    x_base_spiral_2, y_base_spiral_2 = compute_curve_points(2 * np.pi, np.pi, num_points, scale_factor)
    x_base_spiral_2 = x_base_2 + x_base_spiral_2 * np.abs(np.cos(np.linspace(2 * np.pi, np.pi, num_points)))
    y_base_spiral_2 = y_base_spiral_2 * height_factor
    baseline_spiral_2.set_data(x_base_spiral_2, y_base_spiral_2)
    # Compute the chord length of the second baseline spiral
    x_start_2 = x_base_spiral_2[0]
    y_start_2 = y_base_spiral_2[0]
    x_end_2 = x_base_spiral_2[-1]
    y_end_2 = y_base_spiral_2[-1]
    baseline_chord_2 = np.sqrt((x_end_2 - x_start_2)**2 + (y_end_2 - y_start_2)**2)
    # Update crosslines
    vertical_line.set_data([target_chord, target_chord], [0, HEIGHT])
    vertical_label.set_position((target_chord, HEIGHT + 0.05))
    if y > 0:
        horizontal_line.set_data([0, WIDTH], [y, y])
    else:
        horizontal_line.set_data([], [])
    # Update protractor line (from (0,0) to mouse position)
    anchor_x, anchor_y = 0.0, 0.0
    protractor_line.set_data([anchor_x, x], [anchor_y, y])
    # Compute the angle relative to the baseline (y=0)
    dx = x - anchor_x
    dy = y - anchor_y
    angle = np.arctan2(dy, dx) * 180 / np.pi
    # Update protractor arc
    mid_x = (anchor_x + x) / 2
    mid_y = (anchor_y + y) / 2
    radius_arc = np.sqrt(dx**2 + dy**2) / 4
    start_angle = 0
    end_angle = angle
    theta_arc = np.linspace(np.deg2rad(start_angle), np.deg2rad(end_angle), num_points)
    x_arc = mid_x + radius_arc * np.cos(theta_arc)
    y_arc = mid_y + radius_arc * np.sin(theta_arc)
    protractor_arc.set_data(x_arc, y_arc)
    # Update swinging ghost curves
    offsets = [-10, -5, 5, 10] # Degrees
    for i, offset in enumerate(offsets):
        angle_offset = angle + offset
        x_ghost, y_ghost = compute_curve_points(np.pi, 2 * np.pi, num_points // 2, 1.0, angle_offset)
        ghost_curves[i].set_data(anchor_x + x_ghost, anchor_y + y_ghost)
    # Update protractor spiral at the mouse position
    line_vec = np.array([x - anchor_x, y - anchor_y])
    line_len = np.sqrt(dx**2 + dy**2)
    if line_len == 0:
        line_len = 1e-10
    normal_vec = np.array([-(y - anchor_y), x - anchor_x]) / line_len
    x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
    x_mirrored = []
    y_mirrored = []
    for xs, ys in zip(x_spiral, y_spiral):
        point = np.array([xs, ys])
        v = point - np.array([anchor_x, anchor_y])
        projection = np.dot(v, normal_vec) * normal_vec
        mirrored_point = point - 2 * projection
        x_mirrored.append(mirrored_point[0])
        y_mirrored.append(mirrored_point[1])
    protractor_spiral_2.set_data(x + x_mirrored, y + y_mirrored)
    # Update protractor text
    protractor_text.set_position((mid_x, mid_y))
    protractor_text.set_text(f'Angle: {angle:.2f}°\nκ at 2πR: {kappa_at_2piR:.4f}')
    # Calculate chord length from cursor to the start of the green segment
    x_start_green, y_start_green = x_green_final[0], y_green_scaled[0]
    chord_to_green = np.sqrt((x - x_start_green)**2 + (y - y_start_green)**2)
    # Update cursor text
    text_str = (f'κ: {scale_factor:.4f}\n'
                f'Height Factor: {height_factor:.4f}\n'
                f'Cursor: ({x:.4f}, {y:.4f})\n'
                f'Chord to Green: {chord_to_green:.4f}\n'
                f'Baseline Chord (x=0): {baseline_chord:.4f}\n'
                f'Baseline Chord (x=1): {baseline_chord_2:.4f}')
    cursor_text.set_text(text_str)
    fig_2d.canvas.draw()
# Toggle harmonics
def toggle_harmonics(event):
    global show_harmonics
    if event.key == 'h':
        show_harmonics = not show_harmonics
        for text in harmonic_texts:
            text.set_visible(show_harmonics)
        print(f"Harmonic frequencies {'shown' if show_harmonics else 'hidden'}")
        fig_2d.canvas.draw()
# Save plot
def save_plot(event):
    if event.key == 'w':
        plt.savefig("nu_curve.png", dpi=300, bbox_inches='tight')
        print("Plot saved as nu_curve.png")
        if MPLD3_AVAILABLE:
            mpld3.save_html(fig_2d, "nu_curve.html")
            print("Interactive plot saved as nu_curve.html")
        else:
            print("Skipping HTML export because mpld3 is not installed.")
# Connect events
fig_2d.canvas.mpl_connect('pick_event', on_pick_mersenne)
fig_2d.canvas.mpl_connect('button_press_event', on_click_deselect)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_harmonics)
fig_2d.canvas.mpl_connect('key_press_event', save_plot)
fig_2d.canvas.mpl_connect('key_press_event', toggle_draw)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('key_press_event', toggle_dimension)
fig_2d.canvas.mpl_connect('key_press_event', to_construction)
fig_2d.canvas.mpl_connect('key_press_event', hide_show)
fig_2d.canvas.mpl_connect('key_press_event', reset_canvas)
fig_2d.canvas.mpl_connect('key_press_event', save_stl)
fig_2d.canvas.mpl_connect('button_press_event', on_click_protractor)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_dimension)
fig_2d.canvas.mpl_connect('button_press_event', on_click_draw)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion)
fig_2d.canvas.mpl_connect('key_press_event', auto_close)
fig_2d.canvas.mpl_connect('key_press_event', toggle_pro_mode)
fig_2d.canvas.mpl_connect('pick_event', on_pick)
fig_2d.canvas.mpl_connect('button_press_event', on_button_press)
fig_2d.canvas.mpl_connect('button_release_event', on_button_release)
# Plot properties
ax_2d.set_xlim(-0.1, WIDTH + 0.1)
ax_2d.set_ylim(-1.5, HEIGHT + 0.1)
ax_2d.set_xlabel('x (Exponents: 2 to 11B)')
ax_2d.set_ylabel('y')
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
ax_2d.grid(True)
ax_2d.set_aspect('equal')
# Display default pod surface and draw default pod
display_pod_surface()
draw_default_pod(ax_2d)
plt.show()

----- END nurks_surface.py -----

----- tetra -----
# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import cm
from matplotlib.widgets import Slider
import hashlib
from decimal import Decimal, getcontext
import warnings
from matplotlib import MatplotlibDeprecationWarning
import struct
import base64
# Import mpld3 if available for HTML export
try:
    import mpld3
    MPLD3_AVAILABLE = True
except ImportError:
    print("mpld3 not installed. HTML export will be skipped. Install mpld3 with 'pip install mpld3' to enable.")
    MPLD3_AVAILABLE = False
from temperature_salt import secure_hash_two
from kappawise import kappa_coord
from nurks_surface import bspline_basis, bspline_basis_periodic, custom_interoperations_green_curve
# Set precision for Decimal
getcontext().prec = 28
# Suppress warnings
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)
# A3 landscape dimensions (normalized: width long side, height short side)
WIDTH = 420 / 297 # A3 landscape: 420mm width, 297mm height, normalized height=1.0
HEIGHT = 1.0
PURPLE_LINES = [1/3, 2/3] # Dividers on the width
unit_per_mm = 1.0 / 297 # Normalize to A3 short side
scale_label = f"Scale: 1mm = {unit_per_mm:.5f} units (A3 short side = 297mm)"
# Dreyfuss human factors: Optimal eye distance ~20 inches (508mm)
EYE_DISTANCE = 500 * unit_per_mm # Normalized eye distance to viewport
HORIZON_HEIGHT = HEIGHT * 0.5 # Default horizon line at half height
EYE_LINE = HORIZON_HEIGHT # Eye line coincides with horizon
# Golden spiral parameters
PHI = (1 + np.sqrt(5)) / 2
kappa = 1 / PHI
A_SPIRAL = 0.001 # Scaled down slightly from 0.01 to fit better
B_SPIRAL = np.log(PHI) / (np.pi / 2)
# Define κθπ for the green segment
theta_max = kappa * np.pi**2 / PHI
# Compute the full spiral
theta_full = np.linspace(0, 10 * np.pi, 1000)
r_full = A_SPIRAL * np.exp(B_SPIRAL * theta_full)
x_full = r_full * np.cos(theta_full)
y_full = r_full * np.sin(theta_full)
# Compute the green segment (θ from π to 2π)
theta_green = np.linspace(np.pi, 2 * np.pi, 200)
r_green = A_SPIRAL * np.exp(B_SPIRAL * theta_green)
x_green = r_green * np.cos(theta_green)
y_green = r_green * np.sin(theta_green)
# Compute the chord and shift
x1, y1 = x_green[0], y_green[0]
x2, y2 = x_green[-1], y_green[-1]
chord_length = np.abs(x2 - x1)
# Shift so the segment starts at x=0
x_green_shifted = x_green - x1
x_green_final = x_green_shifted
# Scale to match the target chord length (between purple lines)
target_chord = PURPLE_LINES[1] - PURPLE_LINES[0]
scale_factor = target_chord / chord_length if chord_length != 0 else 1.0
x_green_scaled = x_green_final * scale_factor
y_green_scaled = y_green * scale_factor
# Shift to start at the first purple line
x_green_final = x_green_scaled + PURPLE_LINES[0]
# Compute κ at 2πR for the green segment
r_max = A_SPIRAL * np.exp(B_SPIRAL * theta_max)
two_pi_r = 2 * np.pi * r_max
kappa_at_2piR = two_pi_r / PHI
# Define the 52 Mersenne prime exponents (updated with the latest known as of 2025)
mersenne_exponents = [
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
    3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
    110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
    6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
    37156667, 42643801, 43112609, 57885161, 74207281, 77232917, 82589933,
    136279841 # Latest known Mersenne prime exponent as of 2025 (52nd)
]
# Map exponents to x-positions (0 to width)
min_exponent = 2
max_exponent_at_x1 = 1_100_000_000
exponent_range_per_x = (max_exponent_at_x1 - min_exponent) / 1.0
x_positions = [(exponent - min_exponent) / exponent_range_per_x * WIDTH for exponent in mersenne_exponents] # Scale to full WIDTH
# Create the 52 curves data
curves = []
curve_lines = []
colors = plt.cm.viridis(np.linspace(0, 1, len(mersenne_exponents)))
for i, (exponent, x_pos) in enumerate(zip(mersenne_exponents, x_positions)):
    scale = x_pos / chord_length if chord_length != 0 else 1.0
    x_new = x_green * scale
    y_new = y_green * scale
    x_new_shifted = x_new - x_new[0]
    curves.append((x_new_shifted, y_new, f"M{exponent}"))
    curve_lines.append(None)
# A4 short edge divisions (110 parts, scaled to first part of WIDTH)
division_step = WIDTH / 2 / 110 # Assume first half is A4-like
division_positions = np.arange(0, WIDTH / 2 + division_step, division_step)
# Scale key for the title
scale_key_positions = division_positions[::10] / (WIDTH / 2) # Normalize to 0-1 for first half
scale_key_exponents = [int(2 + (1_100_000_000 - 2) * x) for x in scale_key_positions]
scale_key_text = "Scale (x=0 to WIDTH/2): " + ", ".join([f"{x:.2f}: {exp:,}" for x, exp in zip(scale_key_positions, scale_key_exponents)])
# Flags for Mersenne primes
flag_length = 0.5
start_y = -0.1
wedge_angles = np.linspace(90, 360, len(curves))
flag_positions = []
annotation_objects = []
harmonic_frequencies = []
circle_markers = []
min_exp = min(mersenne_exponents)
max_exp = max(mersenne_exponents)
log_min = np.log(min_exp)
log_max = np.log(max_exp)
min_freq_exp = -4.459
max_freq_exp = 5.506
exponent_range = max_freq_exp - min_freq_exp
log_range = log_max - log_min
for i, (x_new, y_new, label) in enumerate(curves):
    x_end = x_new[-1]
    y_end = y_new[-1]
    x_start = x_end
    y_start = start_y
    angle = np.deg2rad(wedge_angles[i])
    x_flag = x_start + flag_length * np.cos(angle)
    y_flag = y_start + flag_length * np.sin(angle)
    exponent = mersenne_exponents[i]
    scaled_exponent = min_freq_exp + (np.log(exponent) - log_min) / log_range * exponent_range
    freq = 440 * 2**scaled_exponent
    harmonic_frequencies.append(freq)
    flag_positions.append((x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq))
    angle_deg = wedge_angles[i]
    if (angle_deg - 90) % 5 == 0:
        angle_rad = np.deg2rad(angle_deg)
        x_marker = x_start + (flag_length * 0.5) * np.cos(angle_rad)
        y_marker = y_start + (flag_length * 0.5) * np.sin(angle_rad)
        circle_markers.append((x_marker, y_marker))
# Global variables for interactive modes
protractor_active = False
ruler_active = False
draw_mode = False
dimension_active = False
pro_mode = False
is_closed = False
selected_curve = None
hidden_elements = []
protractor_points = []
protractor_line = None
protractor_text = None
ruler_points = []
ruler_line = None
ruler_text = None
dimension_labels = []
drawing_points = [] # Kappa nodes (first endpoint of each greenchord)
kappas = [] # Kappa values at each node
node_scatter = [] # List of scatter objects for kappa nodes
original_colors = [] # List to store original colors of nodes
selected_node_index = -1
dragging = False
ghost_handles = [] # List for theta ghost handles
green_curve_line = None # Single plot object for the interoperated greencurve
CLOSE_THRESHOLD = 0.05 # Distance to first point to consider closing
SNAP_THRESHOLD = 0.05 # Threshold for snapping to dividers (UX improvement)
vanishing_points = [] # Vanishing points for each triangulation
previous_kappa = 1.0 # Initial kappa for decay
curvature = 1.0 # Initial curvature (kappa)
height = 0.5 # Initial height for 3D model
num_rings = 20 # Number of loft rings
fractal_level = 3 # Fractal level for flowers
radial_chord = 0.5 # Radial chord for flower
tangential_chord = 0.2 # Tangential chord for flower
height_chord = 0.1 # Height chord for flower
current_vertices = None
current_faces = None
last_angle = 0.0 # Last measured angle from protractor
show_harmonics = False
harmonic_texts = []
annotation_objects = []
# Pre-compute kappa grid
kappa_grid = kappa_coord(grid_size=100)
# Fractal Flower Mesh
def fractal_flower(center, scale, level, all_polygons, rotation_angle=0.0):
    """
    Recursively generates flower-shaped polygons for the surface.
    Collects all base-level flower polygons in all_polygons (list of list of [x,y,z]).
    Uses 36 points for better flower resolution with curved petals.
    Applies rotation to the points.
    Args:
        center: [x, y, z] center of the flower.
        scale: Scale factor for the flower size.
        level: Current recursion depth.
        all_polygons: List to collect all base flower polygons.
        rotation_angle: Rotation angle in radians for the flower.
    """
    rot_cos = np.cos(rotation_angle)
    rot_sin = np.sin(rotation_angle)
    num_points = 37 # 36 points for higher resolution
    t = np.linspace(0, 2 * np.pi, num_points)[:-1]
    r = scale * (radial_chord + tangential_chord * np.sin(6 * t)) # 6 petals, use sin for symmetry if needed
    dx = r * np.cos(t)
    dy = r * np.sin(t)
    dz = scale * height_chord * np.cos(6 * t) # Curved z for surface
    # Apply rotation to dx, dy (around z)
    x_rot = center[0] + dx * rot_cos - dy * rot_sin
    y_rot = center[1] + dx * rot_sin + dy * rot_cos
    z_rot = center[2] + dz
    polygon = [[x_rot[j], y_rot[j], z_rot[j]] for j in range(len(t))]
    all_polygons.append(polygon)
    if level == 0:
        return
    # Add smaller flowers at petal tips
    small_scale = scale / PHI # Golden ratio scale
    for i in range(6):
        theta = i * (2 * np.pi / 6)
        tip_r = scale * (radial_chord + tangential_chord) # Max r for tip
        tip_dx = tip_r * np.cos(theta)
        tip_dy = tip_r * np.sin(theta)
        tip_dz = scale * height_chord
        # Rotate tip offset
        tip_x = center[0] + tip_dx * rot_cos - tip_dy * rot_sin
        tip_y = center[1] + tip_dx * rot_sin + tip_dy * rot_cos
        tip_z = center[2] + tip_dz
        tip_center = [tip_x, tip_y, tip_z]
        fractal_flower(tip_center, small_scale, level - 1, all_polygons, rotation_angle + np.pi)
# Triangulate polygon for rendering (fan triangulation)
def triangulate_poly(poly):
    tris = []
    for i in range(1, len(poly) - 1):
        tris.append([poly[0], poly[i], poly[i+1]])
    return tris
# Hash entropy for lower surface
def hash_entropy(p):
    h_str = f"{p[0]:.6f}{p[1]:.6f}{p[2]:.6f}"
    h = int(hashlib.sha256(h_str.encode()).hexdigest(), 16) % 1000 / 1000.0 * 0.05 - 0.025
    return h
# Build mesh using fractal flower (ties to curve by scaling to curve length)
def build_mesh(x_curve, y_curve, z_curve=None, height=0.5, num_rings=20, num_points=None, fractal_level=3):
    """
    Builds two surfaces meeting at the 3D curve with vertical tangent, inheriting each other's curvature in transition.
    Integrates fractal flower for complex surface detail on caps, scaled by curve length.
    Uses flower modulation in loft rings for interlacing petals.
    Args:
        x_curve, y_curve, z_curve: Curve coordinates.
        height: Height for lofting.
        num_rings: Number of rings for loft.
        num_points: Number of points to sample curve.
        fractal_level: Recursion level for fractal flower.
    Returns:
        vertices (np.array): Array of [x, y, z].
        faces (list): List of [idx1, idx2, idx3].
    """
    if num_points is not None:
        indices = np.linspace(0, len(x_curve) - 1, num_points, dtype=int)
        x_curve = x_curve[indices]
        y_curve = y_curve[indices]
        if z_curve is not None:
            z_curve = z_curve[indices]
    n = len(x_curve)
    if z_curve is None:
        z_curve = np.zeros(n) # Default to flat if no z provided
    # Use node 2 as datum when closed
    center_x = drawing_points[1][0] if is_closed and len(drawing_points) > 1 else drawing_points[0][0] if drawing_points else np.mean(x_curve)
    center_y = drawing_points[1][1] if is_closed and len(drawing_points) > 1 else drawing_points[0][1] if drawing_points else np.mean(y_curve)
    vertices = []
    faces = []
    # Parting line on 3D curve
    parting_base = len(vertices)
    for i in range(n):
        vertices.append([x_curve[i], y_curve[i], z_curve[i]])
    # Upper surface: rings inward with vertical tangent at edge and flower modulation
    upper_bases = [parting_base]
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2 # Vertical tangent at s=0 (dr/ds=0)
        g_val = (height / 2) * s**2 # Quadratic for constant curvature
        base = len(vertices)
        upper_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = 0.0 # Upper phase
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s # Modulation increases inward
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) + g_val + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_upper_idx = len(vertices)
    vertices.append([center_x, center_y, height / 2])
    # Lower surface: mirrored with phase offset for interlacing and entropy
    lower_bases = [parting_base] # Shared edge
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2
        g_val = (height / 2) * s**2 # Quadratic for constant curvature (sign same for inheritance magnitude)
        base = len(vertices)
        lower_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = np.pi / 6 # Lower phase offset for interlacing
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) - g_val + hash_entropy([x, y, z]) + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_lower_idx = len(vertices)
    vertices.append([center_x, center_y, -height / 2])
    # Faces for upper surface
    for ll in range(len(upper_bases) - 1):
        base = upper_bases[ll]
        next_base = upper_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, base + next_i, next_base + next_i])
            faces.append([base + i, next_base + next_i, next_base + i])
    # Faces for lower surface
    for ll in range(len(lower_bases) - 1):
        base = lower_bases[ll]
        next_base = lower_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, next_base + i, next_base + next_i])
            faces.append([base + i, next_base + next_i, base + next_i])
    # Integrate fractal flower for caps (no fan, use flower fractals)
    # Compute curve length for scale
    curve_length = np.sum(np.sqrt(np.diff(x_curve)**2 + np.diff(y_curve)**2))
    flower_scale = curve_length * 0.1 if curve_length > 0 else 0.5 # Scale to curve
    all_polygons = [] # List of list of [x,y,z] for each polygon
    # Upper cap flower
    fractal_flower(vertices[center_upper_idx], flower_scale, fractal_level, all_polygons, rotation_angle=np.pi)
    # Lower cap flower
    fractal_flower(vertices[center_lower_idx], flower_scale, fractal_level, all_polygons, rotation_angle=np.pi)
    # Add polygons to mesh (triangulate for rendering)
    for poly in all_polygons:
        base_idx = len(vertices)
        vertices.extend(poly)
        for tri in triangulate_poly(range(len(poly))):
            faces.append([base_idx + tri[0], base_idx + tri[1], base_idx + tri[2]])
    # Convert to numpy array
    vertices = np.array(vertices)
    # Snap to integers if hash ends with 0
    for i in range(len(vertices)):
        v = vertices[i]
        h_str = f"{v[0]:.6f}{v[1]:.6f}{v[2]:.4f}"
        h = hashlib.sha256(h_str.encode()).hexdigest()[-1]
        if h == '0':
            vertices[i] = np.round(vertices[i])
    # Add compound curvature modulation with angle and 3D kappa grid for smooth orthographic projections
    grid_size, _, num_angles = kappa_grid.shape
    angle_idx = int((last_angle / 360) * num_angles) % num_angles
    kappa_slice = kappa_grid[:, :, angle_idx]
    # Normalize vertices to -1 to 1 for grid mapping (assuming curve bounds approx [0, WIDTH] x [0, HEIGHT])
    max_dim = max(np.max(np.abs(vertices[:, 0])), np.max(np.abs(vertices[:, 1])))
    norm_x = np.clip(((vertices[:, 0] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    norm_y = np.clip(((vertices[:, 1] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    kappa_mod = kappa_slice[norm_y, norm_x]
    vertices[:, 2] += kappa_mod * 0.1 # Scale z modulation
    vertices[:, 0] += kappa_mod * 0.05 * np.sin(2 * np.pi * vertices[:, 2] / height) # Compound in x
    vertices[:, 1] += kappa_mod * 0.05 * np.cos(2 * np.pi * vertices[:, 2] / height) # Compound in y
    # Make flowers sacrificial: remove flower faces after modulation (assume last added are flowers)
    flower_face_start = len(faces) - len(all_polygons) * 35 # Adjusted for 36 points per flower (approx 35 triangles)
    faces = faces[:flower_face_start]
    return vertices, faces
# NURBS basis function
def nurbs_basis(u, i, p, knots):
    if p == 0:
        return 1.0 if knots[i] <= u <= knots[i+1] else 0.0 # Include = for end
    if knots[i+p] == knots[i]:
        c1 = 0.0
    else:
        c1 = (u - knots[i]) / (knots[i+p] - knots[i]) * nurbs_basis(u, i, p-1, knots)
    if knots[i+p+1] == knots[i+1]:
        c2 = 0.0
    else:
        c2 = (knots[i+p+1] - u) / (knots[i+p+1] - knots[i+1]) * nurbs_basis(u, i+1, p-1, knots)
    return c1 + c2
# Compute NURBS curve point
def nurbs_curve_point(u, control_points, weights, p, knots):
    n = len(control_points) - 1
    x = 0.0
    y = 0.0
    denom = 0.0
    for i in range(n + 1):
        b = nurbs_basis(u, i, p, knots)
        denom += b * weights[i]
        x += b * weights[i] * control_points[i][0]
        y += b * weights[i] * control_points[i][1]
    if denom == 0:
        return 0, 0
    return x / denom, y / denom
# Generate NURBS curve
def generate_nurbs_curve(points, weights, p, knots, num_points=1000):
    u_min, u_max = knots[p], knots[-p-1]
    u_values = np.linspace(u_min, u_max, num_points, endpoint=False)
    curve = [nurbs_curve_point(u, points, weights, p, knots) for u in u_values]
    curve.append(curve[0]) # Append first point for exact closure
    return np.array([list(pt) for pt in curve]) # Convert to np.array of shape (num_points+1, 2)
# Compute golden spiral
def compute_golden_spiral():
    theta = np.linspace(0, 10 * np.pi, 1000)
    r = A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Scale down to fit within page bounds
    scale_factor = min(WIDTH, HEIGHT) / (2 * np.max(np.abs([x, y]))) * 0.8 # 80% of max to fit comfortably
    x *= scale_factor
    y *= scale_factor
    return x, y
# Compute kappa for a segment, second endpoint influences next kappa
def compute_segment_kappa(p1, p2, base_kappa=1.0, prev_kappa=1.0):
    x1, y1 = p1
    x2, y2 = p2
    theta = np.sqrt((x2 - x1)**2 + (y2 - y1)**2) # Theta is distance
    if theta < 1e-10:
        return prev_kappa
    decay_factor = np.exp(-theta / WIDTH / 20.0) # Further reduced decay rate
    return prev_kappa * decay_factor * base_kappa
# Recalculate kappas after changes (e.g., closure or node move) for consistency
def recalculate_kappas():
    global previous_kappa
    previous_kappa = kappas[0] # Start with first kappa
    for i in range(1, len(drawing_points)):
        kappas[i] = compute_segment_kappa(drawing_points[i-1], drawing_points[i], curvature, previous_kappa)
        previous_kappa = kappas[i]
# Update 3D model on changes (e.g., height slider or curve update)
def update_3d_model():
    global current_vertices, current_faces
    if green_curve_line:
        x_curve, y_curve = green_curve_line.get_data()
        if is_closed and np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)), height=height)
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
# Golden window calculation
def compute_golden_window(x_spiral, y_spiral):
    idx_crossings = np.where(np.diff(np.sign(x_spiral - PURPLE_LINES[0] * WIDTH)))[0]
    if len(idx_crossings) >= 2:
        y1 = y_spiral[idx_crossings[0]]
        y2 = y_spiral[idx_crossings[1]]
        return np.abs(y2 - y1), min(y1, y2), max(y1, y2)
    return 0, 0, 0
# Compute vanishing point for a triangulation
def compute_vanishing_point(tri_points, eye_distance=EYE_DISTANCE):
    mid_x = np.mean([p[0] for p in tri_points])
    mid_y = np.mean([p[1] for p in tri_points])
    vx = mid_x
    vy = HORIZON_HEIGHT + eye_distance * (mid_y - EYE_LINE) / WIDTH
    return vx, vy
# Redraw green curve
def redraw_green_curve(is_closed=False):
    global green_curve_line
    if green_curve_line:
        green_curve_line.remove()
        green_curve_line = None
    if len(drawing_points) >= 2:
        adjusted_kappas = kappas.copy()
        if is_closed and len(adjusted_kappas) > 1:
            adjusted_kappas[1] = 1.5 * adjusted_kappas[1] # Local kappa adjustment for ellipse conditions
        x_green, y_green = custom_interoperations_green_curve(drawing_points, adjusted_kappas, is_closed=is_closed)
        green_curve_line, = ax_2d.plot(x_green, y_green, 'g-', label='Green Curve' if green_curve_line is None else None)
    fig_2d.canvas.draw()
# Setup figures
fig_2d = plt.figure(figsize=(14, 8))
ax_2d = fig_2d.add_subplot(111)
fig_3d = plt.figure(figsize=(10, 6))
ax_3d = fig_3d.add_subplot(111, projection='3d')
fig_controls = plt.figure(figsize=(4, 8))
ax_curvature = fig_controls.add_axes([0.2, 0.8, 0.6, 0.03])
curvature_slider = Slider(ax_curvature, 'Curvature (kappa)', 0.1, 2.0, valinit=curvature)
ax_height = fig_controls.add_axes([0.2, 0.7, 0.6, 0.03])
height_slider = Slider(ax_height, 'Height', 0.1, 2.0, valinit=height)
ax_rings = fig_controls.add_axes([0.2, 0.6, 0.6, 0.03])
rings_slider = Slider(ax_rings, 'Rings', 5, 50, valinit=num_rings, valstep=1)
ax_level = fig_controls.add_axes([0.2, 0.5, 0.6, 0.03])
level_slider = Slider(ax_level, 'Fractal Level', 0, 5, valinit=fractal_level, valstep=1)
ax_radial = fig_controls.add_axes([0.2, 0.4, 0.6, 0.03])
radial_slider = Slider(ax_radial, 'Radial Chord', 0.1, 1.0, valinit=radial_chord)
ax_tangential = fig_controls.add_axes([0.2, 0.3, 0.6, 0.03])
tangential_slider = Slider(ax_tangential, 'Tangential Chord', 0.0, 0.5, valinit=tangential_chord)
ax_height_chord = fig_controls.add_axes([0.2, 0.2, 0.6, 0.03])
height_chord_slider = Slider(ax_height_chord, 'Height Chord', 0.0, 0.5, valinit=height_chord)
# Plot A3 page
ax_2d.plot([0, WIDTH, WIDTH, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k-', label='A3 Landscape Page')
for x in PURPLE_LINES:
    ax_2d.plot([x * WIDTH, x * WIDTH], [0, HEIGHT], 'm-', label='Purple Dividers' if x == PURPLE_LINES[0] else None)
# Horizon line
horizon_line, = ax_2d.plot([0, WIDTH], [HORIZON_HEIGHT, HORIZON_HEIGHT], 'b:', label='Horizon/Eye Line')
# Golden spiral
x_spiral, y_spiral = compute_golden_spiral()
golden_spiral, = ax_2d.plot(x_spiral + WIDTH/2, y_spiral + HEIGHT/2, 'gold', label='Golden Spiral')
# Golden window
golden_window, y_min, y_max = compute_golden_window(x_spiral + WIDTH/2, y_spiral + HEIGHT/2)
ax_2d.fill_between([PURPLE_LINES[0] * WIDTH - 0.05, PURPLE_LINES[0] * WIDTH + 0.05], y_min, y_max, color='yellow', alpha=0.5, label='Golden Window')
# Ghost curve init
ghost_curve, = ax_2d.plot([], [], 'g--', label='Ghost Curve Preview')
# Control indicators in legend
ax_2d.plot([], [], ' ', label='R: Toggle draw mode')
ax_2d.plot([], [], 'b--', label='A: Toggle protractor')
ax_2d.plot([], [], 'c-', label='M: Toggle measure (ruler)')
ax_2d.plot([], [], ' ', label='D: Toggle dimension')
ax_2d.plot([], [], 'r-', label='C: Close polyhedron (manual)')
ax_2d.plot([], [], ' ', label='Click near first point to close')
ax_2d.plot([], [], ' ', label='Click to select curve')
ax_2d.plot([], [], ' ', label='G: To construction geom')
ax_2d.plot([], [], ' ', label='H: Hide/show')
ax_2d.plot([], [], ' ', label='E: Reset canvas')
ax_2d.plot([], [], ' ', label='S: Export STL')
ax_2d.plot([], [], 'k-', label='Curvature Slider (Controls window)')
# Update curvature
def update_curvature(val):
    global curvature
    curvature = val
    if len(drawing_points) >= 1:
        kappas[-1] = curvature
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
    fig_2d.canvas.draw()
curvature_slider.on_changed(update_curvature)
# Update height
def update_height(val):
    global height
    height = val
    if is_closed:
        update_3d_model()
height_slider.on_changed(update_height)
# Update rings
def update_rings(val):
    global num_rings
    num_rings = int(val)
    if is_closed:
        update_3d_model()
rings_slider.on_changed(update_rings)
# Update fractal level
def update_level(val):
    global fractal_level
    fractal_level = int(val)
    if is_closed:
        update_3d_model()
level_slider.on_changed(update_level)
# Update radial chord
def update_radial(val):
    global radial_chord
    radial_chord = val
    if is_closed:
        update_3d_model()
radial_slider.on_changed(update_radial)
# Update tangential chord
def update_tangential(val):
    global tangential_chord
    tangential_chord = val
    if is_closed:
        update_3d_model()
tangential_slider.on_changed(update_tangential)
# Update height chord
def update_height_chord(val):
    global height_chord
    height_chord = val
    if is_closed:
        update_3d_model()
height_chord_slider.on_changed(update_height_chord)
# Toggle draw mode
def toggle_draw(event):
    global draw_mode
    if event.key == 'r':
        draw_mode = not draw_mode
        print(f"Draw mode {'enabled' if draw_mode else 'disabled'}")
        fig_2d.canvas.draw()
# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        if not protractor_active:
            if protractor_line:
                protractor_line.remove()
                protractor_line = None
            if protractor_text:
                protractor_text.remove()
                protractor_text = None
            protractor_points.clear()
        fig_2d.canvas.draw()
# On click for protractor
def on_click_protractor(event):
    global protractor_line, protractor_text, last_angle
    if protractor_active and event.inaxes == ax_2d and event.button == 1:
        protractor_points.append((event.xdata, event.ydata))
        if len(protractor_points) == 2:
            x1, y1 = protractor_points[0]
            x2, y2 = protractor_points[1]
            if protractor_line:
                protractor_line.remove()
            protractor_line, = ax_2d.plot([x1, x2], [y1, y2], 'b--')
            dx = x2 - x1
            dy = y2 - y1
            angle = np.arctan2(dy, dx) * 180 / np.pi
            last_angle = angle
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if protractor_text:
                protractor_text.remove()
            protractor_text = ax_2d.text(mid_x, mid_y, f'Angle: {angle:.2f}°', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            protractor_points.clear()
            fig_2d.canvas.draw()
# Toggle ruler (measure)
def toggle_ruler(event):
    global ruler_active
    if event.key == 'm':
        ruler_active = not ruler_active
        print(f"Measure (ruler) tool {'enabled' if ruler_active else 'disabled'}")
        if not ruler_active:
            if ruler_line:
                ruler_line.remove()
                ruler_line = None
            if ruler_text:
                ruler_text.remove()
                ruler_text = None
            ruler_points.clear()
        fig_2d.canvas.draw()
# On click for ruler
def on_click_ruler(event):
    global ruler_line, ruler_text
    if ruler_active and event.inaxes == ax_2d and event.button == 1:
        ruler_points.append((event.xdata, event.ydata))
        if len(ruler_points) == 2:
            x1, y1 = ruler_points[0]
            x2, y2 = ruler_points[1]
            if ruler_line:
                ruler_line.remove()
            ruler_line, = ax_2d.plot([x1, x2], [y1, y2], 'c-')
            dx = x2 - x1
            dy = y2 - y1
            dist = np.sqrt(dx**2 + dy**2)
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if ruler_text:
                ruler_text.remove()
            ruler_text = ax_2d.text(mid_x, mid_y, f'Dist: {dist:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            ruler_points.clear()
            fig_2d.canvas.draw()
# Toggle dimension
def toggle_dimension(event):
    global dimension_active
    if event.key == 'd':
        dimension_active = not dimension_active
        print(f"Dimension tool {'enabled' if dimension_active else 'disabled'}")
        fig_2d.canvas.draw()
# On click for dimension
def on_click_dimension(event):
    if dimension_active and event.inaxes == ax_2d and event.button == 1:
        if ruler_active and ruler_text:
            dimension_labels.append(ruler_text)
        elif selected_curve:
            x, y = selected_curve.get_data()
            length = np.sum(np.sqrt(np.diff(x)**2 + np.diff(y)**2))
            mid_x = np.mean(x)
            mid_y = np.mean(y)
            dim_text = ax_2d.text(mid_x, mid_y + 0.05, f'Len: {length:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            dimension_labels.append(dim_text)
        fig_2d.canvas.draw()
# Toggle pro mode (lock/unlock)
def toggle_pro_mode(event):
    global pro_mode
    if event.key == 'x':
        pro_mode = not pro_mode
        print(f"Pro mode {'locked' if pro_mode else 'unlocked'}")
        fig_2d.canvas.draw()
# On pick event for nodes
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow') # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()
# Show ghost handles (theta points, midpoints between nodes)
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow') # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()
# Show ghost handles (theta points, midpoints between nodes)
def show_ghost_handles():
    global ghost_handles
    for handle in ghost_handles:
        handle.remove()
    ghost_handles = []
    num_points = len(drawing_points) if not is_closed else len(drawing_points) - 1 # Avoid double midpoint on close
    for i in range(num_points):
        next_i = (i + 1) % len(drawing_points) if is_closed else i + 1
        if next_i >= len(drawing_points):
            continue
        mid_x = (drawing_points[i][0] + drawing_points[next_i][0]) / 2
        mid_y = (drawing_points[i][1] + drawing_points[next_i][1]) / 2
        handle = ax_2d.scatter(mid_x, mid_y, color='yellow', s=30, marker='o')
        ghost_handles.append(handle)
    fig_2d.canvas.draw()
# On button press for dragging
def on_button_press(event):
    global dragging
    if pro_mode and selected_node_index != -1 and event.inaxes == ax_2d and event.button == 1:
        dragging = True
# On button release for dragging
def on_button_release(event):
    global dragging
    dragging = False
# On motion for dragging and preview
def on_motion(event):
    global previous_kappa, dragging, selected_node_index
    if dragging and pro_mode and selected_node_index != -1 and event.inaxes == ax_2d:
        drawing_points[selected_node_index] = (event.xdata, event.ydata)
        node_scatter[selected_node_index].set_offsets([[event.xdata, event.ydata]])
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
        fig_2d.canvas.draw()
        return
    if draw_mode and len(drawing_points) > 0 and event.inaxes == ax_2d and not (protractor_active or ruler_active or dimension_active):
        x, y = event.xdata, event.ydata
        preview_points = drawing_points + [(x, y)]
        preview_kappas = kappas + [curvature]
        close_preview = False
        if len(preview_points) > 2:
            dx_first = x - drawing_points[0][0]
            dy_first = y - drawing_points[0][1]
            dist_first = np.sqrt(dx_first**2 + dy_first**2)
            if dist_first < CLOSE_THRESHOLD:
                preview_points[-1] = drawing_points[0]
                preview_kappas[-1] = curvature
                # Preview kappa1 adjustment for closure
                last_theta = np.sqrt((drawing_points[-1][0] - preview_points[-1][0])**2 + (drawing_points[-1][1] - preview_points[-1][1])**2)
                if last_theta < 1e-10: # Manage '0' snap error in preview
                    last_theta = 1e-10
                decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                preview_kappas[0] = preview_kappas[-1] * decay_factor * curvature
                close_preview = True
        # Compute kappa for preview segment (cursor at theta)
        if len(preview_points) > 1:
            preview_kappa = compute_segment_kappa(preview_points[-2], preview_points[-1], curvature, previous_kappa)
            preview_kappas[-1] = preview_kappa
        x_ghost, y_ghost = custom_interoperations_green_curve(preview_points, preview_kappas, is_closed=close_preview)
        ghost_curve.set_data(x_ghost, y_ghost)
        fig_2d.canvas.draw()
# Generate G-code for the curve with variable speeds (for 2D plotting/CNC, scaled to mm)
def generate_gcode(x, y, speeds, scale=297):
    """
    Generates simple G-code for linear moves along the curve with variable feedrates.
    Args:
        x (array): X coordinates (normalized).
        y (array): Y coordinates (normalized).
        speeds (list): Normalized speeds (0-1) for each point.
        scale (float): Scale factor to convert normalized units to mm (based on A3 height=297mm).
    Returns:
        str: G-code string.
    """
    gcode = "G21 ; Set units to millimeters\n"
    gcode += "G90 ; Absolute positioning\n"
    # Move to start position (rapid)
    gcode += f"G0 X{x[0] * scale:.2f} Y{y[0] * scale:.2f}\n"
    # Linear moves with varying feedrate
    for i in range(1, len(x)):
        feedrate = speeds[i] * 900 + 100 # Scale speed to 100-1000 mm/min
        gcode += f"G1 X{x[i] * scale:.2f} Y{y[i] * scale:.2f} F{feedrate:.0f}\n"
    return gcode
# Drawing mode: Add kappa nodes and update continuous greencurve
def on_click_draw(event):
    global green_curve_line, selected_curve, previous_kappa, vanishing_points, current_vertices, current_faces, is_closed
    if event.inaxes == ax_2d and event.button == 1:
        x, y = event.xdata, event.ydata
        # Snap to dividers if close (UX improvement for precise alignment)
        for div in PURPLE_LINES:
            div_x = div * WIDTH
            if abs(x - div_x) < SNAP_THRESHOLD:
                x = div_x
                break
        if draw_mode and not (protractor_active or ruler_active or dimension_active):
            # Check if near first point to close
            if len(drawing_points) > 2:
                dx_first = x - drawing_points[0][0]
                dy_first = y - drawing_points[0][1]
                dist_first = np.sqrt(dx_first**2 + dy_first**2)
                if dist_first < CLOSE_THRESHOLD:
                    # Adjust kappa1 based on last theta and kappa
                    last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
                    if last_theta < 1e-10: # Manage '0' snap error
                        last_theta = 1e-10
                    decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                    kappas[0] = kappas[-1] * decay_factor * curvature # Affect kappa1 with last kappa and decay
                    drawing_points.append(drawing_points[0])
                    kappas.append(kappas[0]) # Last kappa inherits first kappa's theta (via same value)
                    recalculate_kappas() # Recalculate for closure consistency
                    is_closed = True
                    redraw_green_curve(is_closed=True) # Use closed NURKS for ellipse conditions
                    # Get closed curve
                    x_curve, y_curve = green_curve_line.get_data()
                    if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
                        x_curve = np.append(x_curve, x_curve[0])
                        y_curve = np.append(y_curve, y_curve[0])
                    ax_3d.cla()
                    current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
                    verts = [[current_vertices[i] for i in f] for f in current_faces]
                    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
                    ax_3d.set_xlabel('X')
                    ax_3d.set_ylabel('Y')
                    ax_3d.set_zlabel('Z')
                    ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
                    fig_3d.canvas.draw()
                    print("Polyhedron closed and 3D model generated")
                    # Compute and print speeds for user generated curve
                    print("User Generated Curve Speeds:")
                    speeds = []
                    for i in range(len(x_curve)):
                        speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
                        print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
                        speeds.append(speed)
                    # Generate G-Code
                    gcode = generate_gcode(x_curve, y_curve, speeds)
                    with open('model.gcode', 'w') as f:
                        f.write(gcode)
                    print("G-Code saved to model.gcode")
                    print(gcode)
                    fig_2d.canvas.draw()
                    return
            # Add new kappa node (first endpoint)
            roygbiv = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
            color = roygbiv[len(drawing_points) % 7]
            node = ax_2d.scatter(x, y, color=color, s=50, picker=True, label='Kappa Node' if len(drawing_points) == 0 else None)
            node_scatter.append(node)
            original_colors.append(color)
            drawing_points.append((x, y))
            kappas.append(curvature)
            if len(drawing_points) > 1:
                previous_kappa = compute_segment_kappa(drawing_points[-2], drawing_points[-1], curvature, previous_kappa)
                redraw_green_curve(is_closed=is_closed)
                if len(drawing_points) >= 2:
                    t = np.linspace(0, 1, 100)
                    x_green, y_green = green_curve_line.get_data()
                    curv = compute_curvature(x_green, y_green, t)
                    print(f"Green curve curvature: Max={curv.max():.4f}, Min={curv.min():.4f}")
            if len(drawing_points) >= 3:
                print("Third point added: Introducing depth and triangulation")
                tri_points = drawing_points[-3:]
                vp = compute_vanishing_point(tri_points)
                vanishing_points.append(vp)
                ax_2d.scatter(vp[0], vp[1], color='purple', s=30, label='Vanishing Point' if len(vanishing_points) == 1 else None)
            fig_2d.canvas.draw()
        elif not draw_mode and not (protractor_active or ruler_active or dimension_active):
            min_dist = float('inf')
            selected_curve = None
            if green_curve_line:
                x_curve, y_curve = green_curve_line.get_data()
                dist = np.min(np.sqrt((x_curve - x)**2 + (y_curve - y)**2))
                if dist < min_dist and dist < 0.05:
                    min_dist = dist
                    selected_curve = green_curve_line
            if selected_curve:
                selected_curve.set_linewidth(3.0)
                print("Green curve selected")
                fig_2d.canvas.draw()
# Close polyhedron (manual trigger)
def close_polyhedron(event):
    if event.key == 'c':
        print("Close via clicking near first point when ghosted")
# Auto close on 'c'
def auto_close(event):
    global is_closed, drawing_points, kappas, previous_kappa
    if event.key == 'c' and len(drawing_points) > 2:
        # Adjust kappa1 based on last theta and kappa
        last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
        if last_theta < 1e-10: # Manage '0' snap error
            last_theta = 1e-10
        decay_factor = np.exp(-last_theta / WIDTH / 20.0)
        kappas[0] = kappas[-1] * decay_factor * curvature # Affect kappa1 with last kappa and decay
        drawing_points.append(drawing_points[0])
        kappas.append(kappas[0]) # Last kappa inherits first kappa's theta (via same value)
        recalculate_kappas() # Recalculate for closure consistency
        is_closed = True
        redraw_green_curve(is_closed=True) # Use closed NURKS for ellipse conditions
        # Get closed curve
        x_curve, y_curve = green_curve_line.get_data()
        if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
        print("Polyhedron closed and 3D model generated")
        # Compute and print speeds for user generated curve
        print("User Generated Curve Speeds:")
        speeds = []
        for i in range(len(x_curve)):
            speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
            print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
            speeds.append(speed)
        # Generate G-Code
        gcode = generate_gcode(x_curve, y_curve, speeds)
        with open('model.gcode', 'w') as f:
            f.write(gcode)
        print("G-Code saved to model.gcode")
        print(gcode)
        fig_2d.canvas.draw()
# Change to construction geometry
def to_construction(event):
    global selected_curve
    if event.key == 'g' and selected_curve:
        selected_curve.set_linestyle('--')
        selected_curve.set_color('gray')
        print("Green curve changed to construction geometry")
        selected_curve = None
        fig_2d.canvas.draw()
# Hide/show
def hide_show(event):
    global hidden_elements, selected_curve
    if event.key == 'h':
        if selected_curve:
            if selected_curve.get_visible():
                selected_curve.set_visible(False)
                hidden_elements.append(selected_curve)
                print("Green curve hidden")
            else:
                selected_curve.set_visible(True)
                if selected_curve in hidden_elements:
                    hidden_elements.remove(selected_curve)
                print("Green curve shown")
            selected_curve = None
        else:
            for elem in hidden_elements:
                elem.set_visible(True)
            hidden_elements.clear()
            print("All hidden elements shown")
        fig_2d.canvas.draw()
# Reset canvas
def reset_canvas(event):
    global drawing_points, kappas, previous_kappa, green_curve_line, vanishing_points, selected_curve, current_vertices, current_faces, last_angle, node_scatter, ghost_handles, is_closed, original_colors
    if event.key == 'e':
        drawing_points = []
        kappas = []
        previous_kappa = 1.0
        if green_curve_line:
            green_curve_line.remove()
            green_curve_line = None
        for node in node_scatter:
            node.remove()
        node_scatter = []
        original_colors = []
        for handle in ghost_handles:
            handle.remove()
        ghost_handles = []
        vanishing_points = []
        selected_curve = None
        ax_3d.cla()
        current_vertices = None
        current_faces = None
        last_angle = 0.0
        is_closed = False
        display_pod_surface()
        print("Canvas reset")
        fig_2d.canvas.draw()
# Compute curvature for continuity check
def compute_curvature(x, y, t):
    dt = t[1] - t[0]
    dx_dt = np.gradient(x, dt)
    dy_dt = np.gradient(y, dt)
    d2x_dt2 = np.gradient(dx_dt, dt)
    d2y_dt2 = np.gradient(dy_dt, dt)
    numerator = np.abs(dx_dt * d2y_dt2 - dy_dt * d2x_dt2)
    denominator = (dx_dt**2 + dy_dt**2)**1.5
    denominator = np.where(denominator == 0, 1e-10, denominator)
    return numerator / denominator
# Generate base pod curve (closed for boundary surface, now 3D curve)
def generate_pod_curve_closed(num_points=200, phase=0.0): # Increased num_points for better resolution
    t = np.linspace(0, 2 * np.pi, num_points) # Full closed loop
    r = radial_chord + tangential_chord * np.cos(6 * t + phase) # Flower-like top profile
    x = r * np.cos(t)
    y = r * np.sin(t)
    z = height_chord * np.sin(6 * t + phase) # Add z variation for 3D curve
    return x, y, z
# Function to compute normals
def compute_normal(v1, v2, v3):
    vec1 = v2 - v1
    vec2 = v3 - v1
    normal = np.cross(vec1, vec2)
    norm = np.linalg.norm(normal)
    return normal / norm if norm != 0 else normal
# Export current model to STL
def export_stl():
    global current_vertices, current_faces
    if current_vertices is None or current_faces is None:
        print("No model to export")
        return
    stl_data = b'\x00' * 80 # Header
    stl_data += struct.pack('<I', len(current_faces)) # Number of triangles
    for face in current_faces:
        v1 = current_vertices[face[0]]
        v2 = current_vertices[face[1]]
        v3 = current_vertices[face[2]]
        normal = compute_normal(v1, v2, v3)
        stl_data += struct.pack('<3f', *normal)
        stl_data += struct.pack('<3f', *v1)
        stl_data += struct.pack('<3f', *v2)
        stl_data += struct.pack('<3f', *v3)
        stl_data += b'\x00\x00' # Attribute byte count
    filename = 'model.stl'
    with open(filename, 'wb') as f:
        f.write(stl_data)
    print(f"Saved to {filename}")
    stl_base64 = base64.b64encode(stl_data).decode('utf-8')
    print("Base64 STL:")
    print(stl_base64)
# Save STL on key press
def save_stl(event):
    if event.key == 's':
        export_stl()
# Display pod surface by default in 3D with curvature continuous end caps
def display_pod_surface():
    global current_vertices, current_faces
    x_curve, y_curve, z_curve = generate_pod_curve_closed(200) # Increased for resolution
    current_vertices, current_faces = build_mesh(x_curve, y_curve, z_curve)
    verts = [[current_vertices[i] for i in f] for f in current_faces]
    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
    ax_3d.set_xlabel('X')
    ax_3d.set_ylabel('Y')
    ax_3d.set_zlabel('Z')
    ax_3d.set_title('3D pod Projected Surface (Compound Curvature with End Caps)')
    fig_3d.canvas.draw()
# Draw default pod ellipse as green curve on 2D canvas
def draw_default_pod(ax, color='g'):
    x, y, _ = generate_pod_curve_closed(num_points=36) # Increased to 36 for better flower
    x_control = x[:-1]
    y_control = y[:-1]
    scale = 0.6 # Scale for large curve
    x_control *= scale
    y_control *= scale
    x_control += WIDTH / 2
    y_control += HEIGHT / 2
    points = list(zip(x_control, y_control))
    kappas_pod = [1.0] * len(points)
    x_interp, y_interp = custom_interoperations_green_curve(points, kappas_pod, is_closed=True)
    ax.plot(x_interp, y_interp, color=color, linewidth=3, linestyle='-')
    # Compute and print speeds for default curve
    print("Default Curve Speeds:")
    for i in range(len(x_interp)):
        speed = int(hashlib.sha256(f"{x_interp[i]}{y_interp[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
        print(f"Point {i}: ({x_interp[i]:.4f}, {y_interp[i]:.4f}), Speed: {speed:.4f}")
# Add Mersenne elements to the plot
# First A4 page (adjusted)
ax_2d.plot([0, WIDTH/2, WIDTH/2, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 1')
# Second A4 page
ax_2d.plot([WIDTH/2, WIDTH, WIDTH, WIDTH/2, WIDTH/2], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 2')
# Purple lines (in first A4)
for x in PURPLE_LINES:
    ax_2d.plot([x * (WIDTH/2), x * (WIDTH/2)], [0, HEIGHT], 'm-')
# Red datum line
ax_2d.plot([0, WIDTH], [0, 0], 'r-')
# A4 short edge divisions (first A4 only)
for x in division_positions:
    ax_2d.plot([x, x], [0, 0.02], 'k-', alpha=0.3)
# Plot circle division markers
for x_marker, y_marker in circle_markers:
    ax_2d.plot(x_marker, y_marker, 'k.', markersize=3)
# Full spiral
ax_2d.plot(x_full, y_full, 'k-')
# Green segment
ax_2d.plot(x_green_final, y_green_scaled, 'g-')
# 52 Mersenne prime curves
for i, (x_new, y_new, label) in enumerate(curves):
    line, = ax_2d.plot(x_new, y_new, color=colors[i])
    curve_lines[i] = line
# Flags and staggered labels
label_y_offset = 0.05
for i, (x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq) in enumerate(flag_positions):
    ax_2d.plot([x_end, x_start], [y_end, y_start], 'k--', alpha=0.3)
    ax_2d.plot([x_start, x_flag], [y_start, y_flag], 'k-', alpha=0.5)
    y_label = y_flag - (i % 5) * label_y_offset
    text = ax_2d.text(x_flag, y_label, label, ha='left', va='top', fontsize=6, rotation=45, picker=5)
    harmonic_text = ax_2d.text(x_flag, y_label - 0.1, f"{freq:.1f} Hz", ha='left', va='top', fontsize=6, rotation=45, visible=False)
    annotation_objects.append((text, i))
    harmonic_texts.append(harmonic_text)
# Golden window 1 (vertical at x = 1/3)
idx_crossings_x = np.where(np.diff(np.sign(x_full - PURPLE_LINES[0])))[0]
if len(idx_crossings_x) >= 2:
    y1 = y_full[idx_crossings_x[0]]
    y2 = y_full[idx_crossings_x[1]]
    golden_window_1 = np.abs(y2 - y1)
    print(f"Golden Window 1 at x={PURPLE_LINES[0]}: {golden_window_1:.4f}")
    ax_2d.fill_between([PURPLE_LINES[0] - 0.05, PURPLE_LINES[0] + 0.05], min(y1, y2), max(y1, y2), color='yellow', alpha=0.5)
# Golden window 2 (horizontal at y = 1/3)
idx_crossings_y = np.where(np.diff(np.sign(y_full - 1/3)))[0]
if len(idx_crossings_y) >= 2:
    x1 = x_full[idx_crossings_y[0]]
    x2 = x_full[idx_crossings_y[1]]
    golden_window_2 = np.abs(x2 - x1)
    print(f"Golden Window 2 at y=1/3: {golden_window_2:.4f}")
    ax_2d.fill_betweenx([1/3 - 0.05, 1/3 + 0.05], min(x1, x2), max(x1, x2), color='orange', alpha=0.5)
# Scale label
ax_2d.text(WIDTH, 1.10337, scale_label, ha='right', va='bottom', fontsize=8)
# Update title with scale key
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
# Highlighting functionality for Mersenne labels
highlighted = [None, None]
def on_pick_mersenne(event):
    global highlighted
    artist = event.artist
    for text, idx in annotation_objects:
        if artist == text:
            if highlighted[0] is not None:
                highlighted[0].set_color('black')
                highlighted[0].set_weight('normal')
                curve_lines[highlighted[1]].set_linewidth(1.0)
                curve_lines[highlighted[1]].set_color(colors[highlighted[1]])
            text.set_color('red')
            text.set_weight('bold')
            curve_lines[idx].set_linewidth(2.0)
            curve_lines[idx].set_color('red')
            highlighted = [text, idx]
            fig_2d.canvas.draw()
            break
def on_click_deselect(event):
    global highlighted
    if event.inaxes != ax_2d:
        return
    clicked_on_annotation = False
    for text, idx in annotation_objects:
        if text.contains(event)[0]:
            clicked_on_annotation = True
            break
    if not clicked_on_annotation and highlighted[0] is not None:
        highlighted[0].set_color('black')
        highlighted[0].set_weight('normal')
        curve_lines[highlighted[1]].set_linewidth(1.0)
        curve_lines[highlighted[1]].set_color(colors[highlighted[1]])
        highlighted = [None, None]
        fig_2d.canvas.draw()
# Curve cache for hashing
curve_cache = {}
def compute_curve_points(theta_start, theta_end, num_points, scale_factor, rotation_angle=0):
    # Create a hash key based on parameters
    key = f"{theta_start:.2f}:{theta_end:.2f}:{num_points}:{scale_factor:.4f}:{rotation_angle:.2f}"
    key_hash = hashlib.md5(key.encode()).hexdigest()
    if key_hash in curve_cache:
        return curve_cache[key_hash]
    theta = np.linspace(theta_start, theta_end, num_points)
    r = scale_factor * A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Apply rotation
    if rotation_angle != 0:
        angle_rad = np.deg2rad(rotation_angle)
        x_rot = x * np.cos(angle_rad) - y * np.sin(angle_rad)
        y_rot = x * np.sin(angle_rad) + y * np.cos(angle_rad)
        x, y = x_rot, y_rot
    curve_cache[key_hash] = (x, y)
    return x, y
# Dynamic LOD
def get_num_points_for_curve():
    xlim = ax_2d.get_xlim()
    ylim = ax_2d.get_ylim()
    view_width = xlim[1] - xlim[0]
    view_height = ylim[1] - ylim[0]
    # Base number of points when fully zoomed out
    base_points = 20
    max_points = 200
    # Zoom factor: smaller view range means more zoom
    full_range = WIDTH # Full x-range when zoomed out
    zoom_factor = full_range / view_width
    num_points = int(base_points + (max_points - base_points) * min(zoom_factor / 10, 1))
    return max(base_points, min(max_points, num_points))
# Cursor, spiral, and circumference setup
cursor, = ax_2d.plot([], [], 'ro', markersize=8, label='κ Spiral Cursor', visible=False)
cursor_spiral, = ax_2d.plot([], [], 'g-', alpha=0.5, visible=False)
cursor_circumference = plt.Circle((0, 0), 0, color='b', fill=False, linestyle='--', alpha=0.5, visible=False)
ax_2d.add_patch(cursor_circumference)
cursor_text = ax_2d.text(WIDTH / 2, 1.15, '', ha='center', va='bottom', fontsize=8, visible=False)
baseline_spiral, = ax_2d.plot([], [], 'g-', alpha=0.5, label='Baseline Spiral', visible=False)
baseline_spiral_2, = ax_2d.plot([], [], 'g-', alpha=0.5, label='Baseline Spiral 2', visible=False)
# Crosslines
vertical_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
horizontal_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
vertical_label = ax_2d.text(target_chord, HEIGHT + 0.05, f'Chord: {target_chord:.4f}', ha='center', va='bottom', fontsize=8, visible=False)
# Protractor elements
protractor_line, = ax_2d.plot([], [], 'b-', alpha=0.8, visible=False)
protractor_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8), visible=False)
protractor_arc, = ax_2d.plot([], [], 'b-', alpha=0.5, visible=False)
protractor_spiral_2, = ax_2d.plot([], [], 'g-', alpha=0.5, visible=False)
# Baseline angle (grey ghost line)
baseline_angle_line, = ax_2d.plot([0, WIDTH], [0, 0], 'grey', alpha=0.3, linestyle='--', visible=False)
# Swinging ghost curves
ghost_curves = []
for _ in range(4): # ±5°, ±10° (4 curves total)
    line, = ax_2d.plot([], [], 'grey', alpha=0.2, visible=False)
    ghost_curves.append(line)
# Ruler elements
ruler_divisions = []
for _ in range(10): # Up to 10 division markers
    marker, = ax_2d.plot([], [], 'k|', markersize=10, markeredgewidth=2, visible=False)
    ruler_divisions.append(marker)
ruler_vanishing_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        cursor.set_visible(protractor_active)
        cursor_spiral.set_visible(protractor_active)
        cursor_circumference.set_visible(protractor_active)
        cursor_text.set_visible(protractor_active)
        baseline_spiral.set_visible(protractor_active)
        baseline_spiral_2.set_visible(protractor_active)
        vertical_line.set_visible(protractor_active)
        horizontal_line.set_visible(protractor_active)
        vertical_label.set_visible(protractor_active)
        protractor_line.set_visible(protractor_active)
        protractor_text.set_visible(protractor_active)
        protractor_arc.set_visible(protractor_active)
        protractor_spiral_2.set_visible(protractor_active)
        baseline_angle_line.set_visible(protractor_active)
        for curve in ghost_curves:
            curve.set_visible(protractor_active)
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        fig_2d.canvas.draw()
# On motion for protractor
def on_motion_protractor(event):
    if not protractor_active or event.inaxes != ax_2d:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    # Update cursor position
    cursor.set_data([x], [y])
    # Update circumference
    radius = np.sqrt(x**2 + y**2)
    cursor_circumference.set_center((x, y))
    cursor_circumference.set_radius(radius)
    # Dynamic LOD: Adjust number of points based on zoom
    num_points = get_num_points_for_curve()
    # Update cursor spiral
    x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
    cursor_spiral.set_data(x + x_spiral, y + y_spiral)
    # Update baseline spiral (indexed at (0,0))
    x_base = 0.0
    scale_factor = (event.xdata / WIDTH) if event.xdata > 0 else 0.01
    scaled_a = A_SPIRAL * scale_factor
    height_factor = (event.ydata / HEIGHT) if event.ydata > 0 else 0.01
    x_base_spiral, y_base_spiral = compute_curve_points(2 * np.pi, np.pi, num_points, scale_factor)
    x_base_spiral = x_base + x_base_spiral * np.abs(np.cos(np.linspace(2 * np.pi, np.pi, num_points)))
    y_base_spiral = y_base_spiral * height_factor
    baseline_spiral.set_data(x_base_spiral, y_base_spiral)
    # Compute the chord length of the baseline spiral
    x_start = x_base_spiral[0]
    y_start = y_base_spiral[0]
    x_end = x_base_spiral[-1]
    y_end = y_base_spiral[-1]
    baseline_chord = np.sqrt((x_end - x_start)**2 + (y_end - y_start)**2)
    # Update second baseline spiral (indexed at (1.0, 0))
    x_base_2 = 1.0
    x_base_spiral_2, y_base_spiral_2 = compute_curve_points(2 * np.pi, np.pi, num_points, scale_factor)
    x_base_spiral_2 = x_base_2 + x_base_spiral_2 * np.abs(np.cos(np.linspace(2 * np.pi, np.pi, num_points)))
    y_base_spiral_2 = y_base_spiral_2 * height_factor
    baseline_spiral_2.set_data(x_base_spiral_2, y_base_spiral_2)
    # Compute the chord length of the second baseline spiral
    x_start_2 = x_base_spiral_2[0]
    y_start_2 = y_base_spiral_2[0]
    x_end_2 = x_base_spiral_2[-1]
    y_end_2 = y_base_spiral_2[-1]
    baseline_chord_2 = np.sqrt((x_end_2 - x_start_2)**2 + (y_end_2 - y_start_2)**2)
    # Update crosslines
    vertical_line.set_data([target_chord, target_chord], [0, HEIGHT])
    vertical_label.set_position((target_chord, HEIGHT + 0.05))
    if y > 0:
        horizontal_line.set_data([0, WIDTH], [y, y])
    else:
        horizontal_line.set_data([], [])
    # Update protractor line (from (0,0) to mouse position)
    anchor_x, anchor_y = 0.0, 0.0
    protractor_line.set_data([anchor_x, x], [anchor_y, y])
    # Compute the angle relative to the baseline (y=0)
    dx = x - anchor_x
    dy = y - anchor_y
    angle = np.arctan2(dy, dx) * 180 / np.pi
    # Update protractor arc
    mid_x = (anchor_x + x) / 2
    mid_y = (anchor_y + y) / 2
    radius_arc = np.sqrt(dx**2 + dy**2) / 4
    start_angle = 0
    end_angle = angle
    theta_arc = np.linspace(np.deg2rad(start_angle), np.deg2rad(end_angle), num_points)
    x_arc = mid_x + radius_arc * np.cos(theta_arc)
    y_arc = mid_y + radius_arc * np.sin(theta_arc)
    protractor_arc.set_data(x_arc, y_arc)
    # Update swinging ghost curves
    offsets = [-10, -5, 5, 10] # Degrees
    for i, offset in enumerate(offsets):
        angle_offset = angle + offset
        x_ghost, y_ghost = compute_curve_points(np.pi, 2 * np.pi, num_points // 2, 1.0, angle_offset)
        ghost_curves[i].set_data(anchor_x + x_ghost, anchor_y + y_ghost)
    # Update protractor spiral at the mouse position
    line_vec = np.array([x - anchor_x, y - anchor_y])
    line_len = np.sqrt(dx**2 + dy**2)
    if line_len == 0:
        line_len = 1e-10
    normal_vec = np.array([-(y - anchor_y), x - anchor_x]) / line_len
    x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
    x_mirrored = []
    y_mirrored = []
    for xs, ys in zip(x_spiral, y_spiral):
        point = np.array([xs, ys])
        v = point - np.array([anchor_x, anchor_y])
        projection = np.dot(v, normal_vec) * normal_vec
        mirrored_point = point - 2 * projection
        x_mirrored.append(mirrored_point[0])
        y_mirrored.append(mirrored_point[1])
    protractor_spiral_2.set_data(x + x_mirrored, y + y_mirrored)
    # Update protractor text
    protractor_text.set_position((mid_x, mid_y))
    protractor_text.set_text(f'Angle: {angle:.2f}°\nκ at 2πR: {kappa_at_2piR:.4f}')
    # Calculate chord length from cursor to the start of the green segment
    x_start_green, y_start_green = x_green_final[0], y_green_scaled[0]
    chord_to_green = np.sqrt((x - x_start_green)**2 + (y - y_start_green)**2)
    # Update cursor text
    text_str = (f'κ: {scale_factor:.4f}\n'
                f'Height Factor: {height_factor:.4f}\n'
                f'Cursor: ({x:.4f}, {y:.4f})\n'
                f'Chord to Green: {chord_to_green:.4f}\n'
                f'Baseline Chord (x=0): {baseline_chord:.4f}\n'
                f'Baseline Chord (x=1): {baseline_chord_2:.4f}')
    cursor_text.set_text(text_str)
    fig_2d.canvas.draw()
# Toggle harmonics
def toggle_harmonics(event):
    global show_harmonics
    if event.key == 'h':
        show_harmonics = not show_harmonics
        for text in harmonic_texts:
            text.set_visible(show_harmonics)
        print(f"Harmonic frequencies {'shown' if show_harmonics else 'hidden'}")
        fig_2d.canvas.draw()
# Save plot
def save_plot(event):
    if event.key == 'w':
        plt.savefig("nu_curve.png", dpi=300, bbox_inches='tight')
        print("Plot saved as nu_curve.png")
        if MPLD3_AVAILABLE:
            mpld3.save_html(fig_2d, "nu_curve.html")
            print("Interactive plot saved as nu_curve.html")
        else:
            print("Skipping HTML export because mpld3 is not installed.")
# Connect events
fig_2d.canvas.mpl_connect('pick_event', on_pick_mersenne)
fig_2d.canvas.mpl_connect('button_press_event', on_click_deselect)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_harmonics)
fig_2d.canvas.mpl_connect('key_press_event', save_plot)
fig_2d.canvas.mpl_connect('key_press_event', toggle_draw)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('key_press_event', toggle_dimension)
fig_2d.canvas.mpl_connect('key_press_event', to_construction)
fig_2d.canvas.mpl_connect('key_press_event', hide_show)
fig_2d.canvas.mpl_connect('key_press_event', reset_canvas)
fig_2d.canvas.mpl_connect('key_press_event', save_stl)
fig_2d.canvas.mpl_connect('button_press_event', on_click_protractor)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_dimension)
fig_2d.canvas.mpl_connect('button_press_event', on_click_draw)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion)
fig_2d.canvas.mpl_connect('key_press_event', auto_close)
fig_2d.canvas.mpl_connect('key_press_event', toggle_pro_mode)
fig_2d.canvas.mpl_connect('pick_event', on_pick)
fig_2d.canvas.mpl_connect('button_press_event', on_button_press)
fig_2d.canvas.mpl_connect('button_release_event', on_button_release)
# Plot properties
ax_2d.set_xlim(-0.1, WIDTH + 0.1)
ax_2d.set_ylim(-1.5, HEIGHT + 0.1)
ax_2d.set_xlabel('x (Exponents: 2 to 11B)')
ax_2d.set_ylabel('y')
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
ax_2d.grid(True)
ax_2d.set_aspect('equal')
# Display default pod surface and draw default pod
display_pod_surface()
draw_default_pod(ax_2d)
plt.show()

# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import cm
from matplotlib.widgets import Slider, Button
import hashlib
from decimal import Decimal, getcontext
import warnings
from matplotlib import MatplotlibDeprecationWarning
import struct
import base64
# Import mpld3 if available for HTML export
try:
    import mpld3
    MPLD3_AVAILABLE = True
except ImportError:
    print("mpld3 not installed. HTML export will be skipped. Install mpld3 with 'pip install mpld3' to enable.")
    MPLD3_AVAILABLE = False
from temperature_salt import secure_hash_two
from kappawise import kappa_coord
from nurks_surface import bspline_basis, bspline_basis_periodic, custom_interoperations_green_curve
# Set precision for Decimal
getcontext().prec = 28
# Suppress warnings
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)
# A3 landscape dimensions (normalized: width long side, height short side)
WIDTH = 420 / 297 # A3 landscape: 420mm width, 297mm height, normalized height=1.0
HEIGHT = 1.0
PURPLE_LINES = [1/3, 2/3] # Dividers on the width
unit_per_mm = 1.0 / 297 # Normalize to A3 short side
scale_label = f"Scale: 1mm = {unit_per_mm:.5f} units (A3 short side = 297mm)"
# Dreyfuss human factors: Optimal eye distance ~20 inches (508mm)
EYE_DISTANCE = 500 * unit_per_mm # Normalized eye distance to viewport
HORIZON_HEIGHT = HEIGHT * 0.5 # Default horizon line at half height
EYE_LINE = HORIZON_HEIGHT # Eye line coincides with horizon
# Golden spiral parameters
PHI = (1 + np.sqrt(5)) / 2
kappa = 1 / PHI
A_SPIRAL = 0.001 # Scaled down slightly from 0.01 to fit better
B_SPIRAL = np.log(PHI) / (np.pi / 2)
# Define κθπ for the green segment
theta_max = kappa * np.pi**2 / PHI
# Compute the full spiral
theta_full = np.linspace(0, 10 * np.pi, 1000)
r_full = A_SPIRAL * np.exp(B_SPIRAL * theta_full)
x_full = r_full * np.cos(theta_full)
y_full = r_full * np.sin(theta_full)
# Compute the green segment (θ from π to 2π)
theta_green = np.linspace(np.pi, 2 * np.pi, 200)
r_green = A_SPIRAL * np.exp(B_SPIRAL * theta_green)
x_green = r_green * np.cos(theta_green)
y_green = r_green * np.sin(theta_green)
# Compute the chord and shift
x1, y1 = x_green[0], y_green[0]
x2, y2 = x_green[-1], y_green[-1]
chord_length = np.abs(x2 - x1)
# Shift so the segment starts at x=0
x_green_shifted = x_green - x1
x_green_final = x_green_shifted
# Scale to match the target chord length (between purple lines)
target_chord = PURPLE_LINES[1] - PURPLE_LINES[0]
scale_factor = target_chord / chord_length if chord_length != 0 else 1.0
x_green_scaled = x_green_final * scale_factor
y_green_scaled = y_green * scale_factor
# Shift to start at the first purple line
x_green_final = x_green_scaled + PURPLE_LINES[0]
# Compute κ at 2πR for the green segment
r_max = A_SPIRAL * np.exp(B_SPIRAL * theta_max)
two_pi_r = 2 * np.pi * r_max
kappa_at_2piR = two_pi_r / PHI
# Define the 52 Mersenne prime exponents (updated with the latest known as of 2025)
mersenne_exponents = [
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
    3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
    110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
    6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
    37156667, 42643801, 43112609, 57885161, 74207281, 77232917, 82589933,
    136279841 # Latest known Mersenne prime exponent as of 2025 (52nd)
]
# Map exponents to x-positions (0 to width)
min_exponent = 2
max_exponent_at_x1 = 1_100_000_000
exponent_range_per_x = (max_exponent_at_x1 - min_exponent) / 1.0
x_positions = [(exponent - min_exponent) / exponent_range_per_x * WIDTH for exponent in mersenne_exponents] # Scale to full WIDTH
# Create the 52 curves data
curves = []
curve_lines = []
for i, (exponent, x_pos) in enumerate(zip(mersenne_exponents, x_positions)):
    scale = x_pos / chord_length if chord_length != 0 else 1.0
    x_new = x_green * scale
    y_new = y_green * scale
    x_new_shifted = x_new - x_new[0]
    curves.append((x_new_shifted, y_new, f"M{exponent}"))
    curve_lines.append(None)
# A3 divisions (297 parts on short side)
division_step = HEIGHT / 297
division_positions = np.arange(0, HEIGHT + division_step, division_step)
# Scale key for the title
scale_key_positions = division_positions[::30] # Every 30mm
scale_key_exponents = [int(min_exponent + (max_exponent_at_x1 - min_exponent) * (y / HEIGHT)) for y in scale_key_positions]
scale_key_text = "Scale (y=0 to 1): " + ", ".join([f"{y:.2f}: {exp:,}" for y, exp in zip(scale_key_positions, scale_key_exponents)])
# Flags for Mersenne primes
flag_length = 0.5
start_y = -0.1
wedge_angles = np.linspace(90, 360, len(curves))
flag_positions = []
annotation_objects = []
harmonic_frequencies = []
circle_markers = []
min_exp = min(mersenne_exponents)
max_exp = max(mersenne_exponents)
log_min = np.log(min_exp)
log_max = np.log(max_exp)
min_freq_exp = -4.459
max_freq_exp = 5.506
exponent_range = max_freq_exp - min_freq_exp
log_range = log_max - log_min
for i, (x_new, y_new, label) in enumerate(curves):
    x_end = x_new[-1]
    y_end = y_new[-1]
    x_start = x_end
    y_start = start_y
    angle = wedge_angles[i]
    flag_x = x_end
    flag_y = start_y - flag_length * (i % 2 + 1) / 2
    flag_positions.append((flag_x, flag_y))
    annotation_objects.append(None)
    # Harmonic frequency mapping
    exp = mersenne_exponents[i]
    log_exp = np.log(exp)
    normalized_log = (log_exp - log_min) / log_range if log_range != 0 else 0
    freq_exp = min_freq_exp + normalized_log * exponent_range
    frequency = np.exp(freq_exp)
    harmonic_frequencies.append(frequency)
    circle_markers.append(None)
# Multi-window setup
# Window 1: 2D Plotter
fig_2d = plt.figure(figsize=(12, 8), num="2D Plotter")
ax_2d = fig_2d.add_subplot(111)
# Window 2: 3D Polyhedron Model
fig_3d = plt.figure(figsize=(10, 6), num="3D Polyhedron Model")
ax_3d = fig_3d.add_subplot(111, projection='3d')
# Window 3: Controls
fig_controls = plt.figure(figsize=(4, 6), num="Controls")
ax_scale = fig_controls.add_axes([0.2, 0.8, 0.6, 0.03])
scale_slider = Slider(ax_scale, 'Scale', 0.5, 2.0, valinit=1.0)
ax_kappa = fig_controls.add_axes([0.2, 0.7, 0.6, 0.03])
kappa_slider = Slider(ax_kappa, 'Kappa', 0.1, 2.0, valinit=kappa)
ax_decay = fig_controls.add_axes([0.2, 0.6, 0.6, 0.03])
decay_slider = Slider(ax_decay, 'Decay', 0.1, 1.0, valinit=0.5)
ax_meta = fig_controls.add_axes([0.2, 0.5, 0.6, 0.03])
meta_textbox = TextBox(ax_meta, 'Meta Value', initial="1")
ax_grid_density = fig_controls.add_axes([0.2, 0.4, 0.6, 0.03])
grid_density_slider = Slider(ax_grid_density, 'Grid Density', 50, 200, valinit=110, valstep=1)
# Add Render Model button
ax_render = fig_controls.add_axes([0.2, 0.3, 0.6, 0.05])
render_button = Button(ax_render, 'Render Model')
# Plot setup for 2D Plotter
max_dimension = max(WIDTH, HEIGHT + 1.5)
padding = 0.5
ax_2d.set_xlim(-padding, max_dimension + padding)
ax_2d.set_ylim(-padding, max_dimension + padding)
# A3 page
ax_2d.plot([0, WIDTH, WIDTH, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k-', label='A3 Page')
ax_2d.plot([0, 1.0, 1.0, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 1')
ax_2d.plot([1.0, 2.0, 2.0, 1.0, 1.0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 2')
for x in PURPLE_LINES:
    ax_2d.plot([x, x], [0, HEIGHT], 'm-', label='Projection Space Dividers' if x == PURPLE_LINES[0] else "")
ax_2d.plot([0, WIDTH], [0, 0], 'r-')
# Function to generate a kappa curve between two points
def generate_kappa_curve(x1, y1, x2, y2, kappa_val, ds=0.02):
    # Compute chord length and initial/final directions
    chord = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    if chord == 0:
        return [x1], [y1]
    # Initial direction (assume tangent at start is along the chord)
    theta0 = np.arctan2(y2 - y1, x2 - x1)
    # Arc length (approximate as chord length for simplicity)
    s_total = chord
    s = np.arange(0, s_total + ds, ds)
    # Constant kappa scaled by chord length
    kappa_s = kappa_val / chord
    # Integrate curvature to get tangent angle
    theta = theta0 + kappa_s * s
    # Integrate to get x, y coordinates
    x = np.zeros_like(s)
    y = np.zeros_like(s)
    x[0], y[0] = x1, y1
    for i in range(1, len(s)):
        x[i] = x[i-1] + ds * np.cos(theta[i-1])
        y[i] = y[i-1] + ds * np.sin(theta[i-1])
    # Scale and shift to match endpoint
    x_end, y_end = x[-1], y[-1]
    scale_x = (x2 - x1) / (x_end - x1) if (x_end - x1) != 0 else 1
    scale_y = (y2 - y1) / (y_end - y1) if (y_end - y1) != 0 else 1
    scale = min(scale_x, scale_y)
    x = x1 + (x - x1) * scale
    y = y1 + (y - y1) * scale
    return x, y
# Single continuous green kappa curve
def compute_green_kappa_curve(T=1.0, kappa_val=kappa):
    nodes = [
        (1/3, 0),
        (1/3 + 1/9, 0.1 * T),
        (1/3 + 2/9, 0.1 * T),
        (2/3, 0)
    ]
    x_all, y_all = [], []
    chord_lengths = []
    x_all.append(nodes[0][0])
    y_all.append(nodes[0][1])
    for i in range(len(nodes) - 1):
        x1, y1 = nodes[i]
        x2, y2 = nodes[i+1]
        chord = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        chord_lengths.append(chord)
        x_seg, y_seg = generate_kappa_curve(x1, y1, x2, y2, kappa_val)
        x_all.extend(x_seg[1:])
        y_all.extend(y_seg[1:])
    return np.array(x_all), np.array(y_all), chord_lengths
# Initial green kappa curve
T = 1.0
x_green, y_green, chord_lengths = compute_green_kappa_curve(T)
green_spiral, = ax_2d.plot(x_green, y_green, 'g-', label='Green Kappa Curve')
green_nodes = [ax_2d.plot([node[0]], [node[1]], 'go', markersize=6)[0] for node in [(1/3, 0), (1/3 + 1/9, 0.1), (1/3 + 2/9, 0.1), (2/3, 0)]]
# Protractor elements
protractor_line, = ax_2d.plot([], [], 'c-', label='Protractor Line')
protractor_arc, = ax_2d.plot([], [], 'c--', label='Protractor Arc')
protractor_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
protractor_spiral_2, = ax_2d.plot([], [], 'm-', label='Protractor Spiral 2')
ghost_curves = [ax_2d.plot([], [], 'b--', alpha=0.5)[0] for _ in range(4)]
# Cursor elements
cursor, = ax_2d.plot([], [], 'rx', markersize=10, label='Cursor')
cursor_text = ax_2d.text(0, 0, '', ha='left', va='bottom', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
# Ruler elements
ruler_line, = ax_2d.plot([], [], 'y-', label='Ruler Line')
ruler_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
# Toggle flags
show_protractor = False
show_ruler = False
show_harmonics = False
show_draw = False
show_dimension = False
show_pro_mode = False
# Drawing elements
kappa_nodes = []
kappa_curves = []
ghost_handles = []
selected_node = None
drag_start = None
# Grid lines (toggleable and programmable)
grid_lines = []
show_grid = True
def update_grid(density):
    global grid_lines
    for line in grid_lines:
        line.remove()
    grid_lines = []
    step_x = WIDTH / density
    step_y = HEIGHT / density
    for i in range(density + 1):
        x = i * step_x
        y = i * step_y
        vline, = ax_2d.plot([x, x], [0, HEIGHT], 'k--', alpha=0.3)
        hline, = ax_2d.plot([0, WIDTH], [y, y], 'k--', alpha=0.3)
        grid_lines.extend([vline, hline])
    fig_2d.canvas.draw()
# Initial grid
update_grid(110)
# Toggle grid with 'g'
def toggle_grid(event):
    global show_grid
    if event.key == 'g':
        show_grid = not show_grid
        for line in grid_lines:
            line.set_visible(show_grid)
        fig_2d.canvas.draw()
# Connect toggle grid
fig_2d.canvas.mpl_connect('key_press_event', toggle_grid)
# Update grid with slider
def on_grid_density_change(val):
    update_grid(int(val))
grid_density_slider.on_changed(on_grid_density_change)
# Move legend outside viewport
handles, labels = ax_2d.get_legend_handles_labels()
fig_2d.legend(handles, labels, loc='upper left', bbox_to_anchor=(1.05, 1), borderaxespad=0.)
# Maximize windows
fig_2d.canvas.manager.window.showMaximized()
fig_3d.canvas.manager.window.showMaximized()
fig_controls.canvas.manager.window.showMaximized()
# Add Navigation Toolbar (assuming Tk backend; may need adjustment for other backends)
from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
toolbar_2d = NavigationToolbar2Tk(fig_2d.canvas, fig_2d.canvas.manager.window)
toolbar_3d = NavigationToolbar2Tk(fig_3d.canvas, fig_3d.canvas.manager.window)
# Render button callback (assuming update_3d_model exists; replace with actual function if different)
def on_render_button(event):
    update_3d_model()  # Call your 3D rendering function here; e.g., display_pod_surface() or equivalent
render_button.on_clicked(on_render_button)
# ... (The rest of the original code remains unchanged, including event connections, plot properties, and plt.show())
# Pick event for Mersenne primes
def on_pick_mersenne(event):
    if isinstance(event.artist, plt.Line2D):
        thisline = event.artist
        ind = event.ind
        if ind is not None and len(ind) > 0:
            i = ind[0]
            exponent = mersenne_exponents[i]
            print(f"Selected Mersenne prime: 2^{exponent} - 1")
            for j, line in enumerate(curve_lines):
                if line is not None:
                    line.set_linewidth(1.0 if j != i else 3.0)
            fig_2d.canvas.draw()
# Click to deselect
def on_click_deselect(event):
    if event.button == 3:  # Right click
        for line in curve_lines:
            if line is not None:
                line.set_linewidth(1.0)
        fig_2d.canvas.draw()
# Toggle protractor
def toggle_protractor(event):
    global show_protractor
    if event.key == 'p':
        show_protractor = not show_protractor
        protractor_line.set_visible(show_protractor)
        protractor_arc.set_visible(show_protractor)
        protractor_text.set_visible(show_protractor)
        protractor_spiral_2.set_visible(show_protractor)
        for ghost in ghost_curves:
            ghost.set_visible(show_protractor)
        print(f"Protractor {'shown' if show_protractor else 'hidden'}")
        fig_2d.canvas.draw()
# Toggle ruler
def toggle_ruler(event):
    global show_ruler
    if event.key == 'r':
        show_ruler = not show_ruler
        ruler_line.set_visible(show_ruler)
        ruler_text.set_visible(show_ruler)
        print(f"Ruler {'shown' if show_ruler else 'hidden'}")
        fig_2d.canvas.draw()
# Click for ruler start
def on_click_ruler(event):
    if show_ruler and event.inaxes == ax_2d and event.button == 1:
        global ruler_start
        ruler_start = (event.xdata, event.ydata)
# Motion for protractor and cursor
def on_motion_protractor(event):
    if event.inaxes != ax_2d:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    # Update cursor
    cursor.set_data([x], [y])
    # Update protractor if shown
    if show_protractor:
        anchor_x, anchor_y = 0.0, 0.0
        protractor_line.set_data([anchor_x, x], [anchor_y, y])
        dx = x - anchor_x
        dy = y - anchor_y
        angle = np.arctan2(dy, dx) * 180 / np.pi
        mid_x = (anchor_x + x) / 2
        mid_y = (anchor_y + y) / 2
        radius_arc = np.sqrt(dx**2 + dy**2) / 4
        start_angle = 0
        end_angle = angle
        num_points = 100
        theta_arc = np.linspace(np.deg2rad(start_angle), np.deg2rad(end_angle), num_points)
        x_arc = mid_x + radius_arc * np.cos(theta_arc)
        y_arc = mid_y + radius_arc * np.sin(theta_arc)
        protractor_arc.set_data(x_arc, y_arc)
        offsets = [-10, -5, 5, 10]
        for i, offset in enumerate(offsets):
            angle_offset = angle + offset
            x_ghost, y_ghost = compute_curve_points(np.pi, 2 * np.pi, num_points // 2, 1.0, angle_offset)
            ghost_curves[i].set_data(anchor_x + x_ghost, anchor_y + y_ghost)
        line_vec = np.array([x - anchor_x, y - anchor_y])
        line_len = np.sqrt(dx**2 + dy**2)
        if line_len == 0:
            line_len = 1e-10
        normal_vec = np.array([-(y - anchor_y), x - anchor_x]) / line_len
        x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
        x_mirrored = []
        y_mirrored = []
        for xs, ys in zip(x_spiral, y_spiral):
            point = np.array([xs, ys])
            v = point - np.array([anchor_x, anchor_y])
            projection = np.dot(v, normal_vec) * normal_vec
            mirrored_point = point - 2 * projection
            x_mirrored.append(mirrored_point[0])
            y_mirrored.append(mirrored_point[1])
        protractor_spiral_2.set_data(x + x_mirrored, y + y_mirrored)
        protractor_text.set_position((mid_x, mid_y))
        protractor_text.set_text(f'Angle: {angle:.2f}°\nκ at 2πR: {kappa_at_2piR:.4f}')
    # Update ruler if shown
    if show_ruler and 'ruler_start' in globals():
        ruler_line.set_data([ruler_start[0], x], [ruler_start[1], y])
        dist = np.sqrt((x - ruler_start[0])**2 + (y - ruler_start[1])**2)
        mid_x_r = (ruler_start[0] + x) / 2
        mid_y_r = (ruler_start[1] + y) / 2
        ruler_text.set_position((mid_x_r, mid_y_r))
        ruler_text.set_text(f'Dist: {dist:.4f}')
    # Update cursor text
    height_factor = y / HEIGHT if HEIGHT != 0 else 0
    baseline_spiral_1 = compute_curve_points(0, np.pi, 100, height_factor)
    x_base_spiral_1, y_base_spiral_1 = baseline_spiral_1
    baseline_chord = np.sqrt((x_base_spiral_1[-1] - x_base_spiral_1[0])**2 + (y_base_spiral_1[-1] - y_base_spiral_1[0])**2)
    baseline_spiral_2 = compute_curve_points(np.pi, 2 * np.pi, 100, height_factor)
    x_base_spiral_2, y_base_spiral_2 = baseline_spiral_2
    baseline_chord_2 = np.sqrt((x_base_spiral_2[-1] - x_base_spiral_2[0])**2 + (y_base_spiral_2[-1] - y_base_spiral_2[0])**2)
    x_start_green = x_green_final[0]
    y_start_green = y_green_scaled[0]
    chord_to_green = np.sqrt((x - x_start_green)**2 + (y - y_start_green)**2)
    text_str = (f'κ: {scale_factor:.4f}\n'
                f'Height Factor: {height_factor:.4f}\n'
                f'Cursor: ({x:.4f}, {y:.4f})\n'
                f'Chord to Green: {chord_to_green:.4f}\n'
                f'Baseline Chord (x=0): {baseline_chord:.4f}\n'
                f'Baseline Chord (x=1): {baseline_chord_2:.4f}')
    cursor_text.set_text(text_str)
    cursor_text.set_position((x + 0.05, y + 0.05))
    fig_2d.canvas.draw_idle()
# Display default pod surface
def display_pod_surface():
    # Placeholder for pod surface display; implement as per original
    pass
# Draw default pod
def draw_default_pod(ax):
    # Placeholder for default pod drawing; implement as per original
    pass
# Plot properties
ax_2d.set_xlim(-0.1, WIDTH + 0.1)
ax_2d.set_ylim(-1.5, HEIGHT + 0.1)
ax_2d.set_xlabel('x (Exponents: 2 to 11B)')
ax_2d.set_ylabel('y')
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
ax_2d.grid(True)
ax_2d.set_aspect('equal')
# Display default pod surface and draw default pod
display_pod_surface()
draw_default_pod(ax_2d)
plt.show()

# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import cm
from matplotlib.widgets import Slider, Button
import hashlib
from decimal import Decimal, getcontext
import warnings
from matplotlib import MatplotlibDeprecationWarning
import struct
import base64
# Import mpld3 if available for HTML export
try:
    import mpld3
    MPLD3_AVAILABLE = True
except ImportError:
    print("mpld3 not installed. HTML export will be skipped. Install mpld3 with 'pip install mpld3' to enable.")
    MPLD3_AVAILABLE = False
from temperature_salt import secure_hash_two
from kappawise import kappa_coord
from nurks_surface import bspline_basis, bspline_basis_periodic, custom_interoperations_green_curve
# Set precision for Decimal
getcontext().prec = 28
# Suppress warnings
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)
# A3 landscape dimensions (normalized: width long side, height short side)
WIDTH = 420 / 297 # A3 landscape: 420mm width, 297mm height, normalized height=1.0
HEIGHT = 1.0
PURPLE_LINES = [1/3, 2/3] # Dividers on the width
unit_per_mm = 1.0 / 297 # Normalize to A3 short side
scale_label = f"Scale: 1mm = {unit_per_mm:.5f} units (A3 short side = 297mm)"
# Dreyfuss human factors: Optimal eye distance ~20 inches (508mm)
EYE_DISTANCE = 500 * unit_per_mm # Normalized eye distance to viewport
HORIZON_HEIGHT = HEIGHT * 0.5 # Default horizon line at half height
EYE_LINE = HORIZON_HEIGHT # Eye line coincides with horizon
# Golden spiral parameters
PHI = (1 + np.sqrt(5)) / 2
kappa = 1 / PHI
A_SPIRAL = 0.001 # Scaled down slightly from 0.01 to fit better
B_SPIRAL = np.log(PHI) / (np.pi / 2)
# Define κθπ for the green segment
theta_max = kappa * np.pi**2 / PHI
# Compute the full spiral
theta_full = np.linspace(0, 10 * np.pi, 1000)
r_full = A_SPIRAL * np.exp(B_SPIRAL * theta_full)
x_full = r_full * np.cos(theta_full)
y_full = r_full * np.sin(theta_full)
# Compute the green segment (θ from π to 2π)
theta_green = np.linspace(np.pi, 2 * np.pi, 200)
r_green = A_SPIRAL * np.exp(B_SPIRAL * theta_green)
x_green = r_green * np.cos(theta_green)
y_green = r_green * np.sin(theta_green)
# Compute the chord and shift
x1, y1 = x_green[0], y_green[0]
x2, y2 = x_green[-1], y_green[-1]
chord_length = np.abs(x2 - x1)
# Shift so the segment starts at x=0
x_green_shifted = x_green - x1
x_green_final = x_green_shifted
# Scale to match the target chord length (between purple lines)
target_chord = PURPLE_LINES[1] - PURPLE_LINES[0]
scale_factor = target_chord / chord_length if chord_length != 0 else 1.0
x_green_scaled = x_green_final * scale_factor
y_green_scaled = y_green * scale_factor
# Shift to start at the first purple line
x_green_final = x_green_scaled + PURPLE_LINES[0]
# Compute κ at 2πR for the green segment
r_max = A_SPIRAL * np.exp(B_SPIRAL * theta_max)
two_pi_r = 2 * np.pi * r_max
kappa_at_2piR = two_pi_r / PHI
# Define the 52 Mersenne prime exponents (updated with the latest known as of 2025)
mersenne_exponents = [
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
    3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
    110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
    6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
    37156667, 42643801, 43112609, 57885161, 74207281, 77232917, 82589933,
    136279841 # Latest known Mersenne prime exponent as of 2025 (52nd)
]
# Map exponents to x-positions (0 to width)
min_exponent = 2
max_exponent_at_x1 = 1_100_000_000
exponent_range_per_x = (max_exponent_at_x1 - min_exponent) / 1.0
x_positions = [(exponent - min_exponent) / exponent_range_per_x * WIDTH for exponent in mersenne_exponents] # Scale to full WIDTH
# Create the 52 curves data
curves = []
curve_lines = []
for i, (exponent, x_pos) in enumerate(zip(mersenne_exponents, x_positions)):
    scale = x_pos / chord_length if chord_length != 0 else 1.0
    x_new = x_green * scale
    y_new = y_green * scale
    x_new_shifted = x_new - x_new[0]
    curves.append((x_new_shifted, y_new, f"M{exponent}"))
    curve_lines.append(None)
# A3 divisions (297 parts on short side)
division_step = HEIGHT / 297
division_positions = np.arange(0, HEIGHT + division_step, division_step)
# Scale key for the title
scale_key_positions = division_positions[::30] # Every 30mm
scale_key_exponents = [int(min_exponent + (max_exponent_at_x1 - min_exponent) * (y / HEIGHT)) for y in scale_key_positions]
scale_key_text = "Scale (y=0 to 1): " + ", ".join([f"{y:.2f}: {exp:,}" for y, exp in zip(scale_key_positions, scale_key_exponents)])
# Flags for Mersenne primes
flag_length = 0.5
start_y = -0.1
wedge_angles = np.linspace(90, 360, len(curves))
flag_positions = []
annotation_objects = []
harmonic_frequencies = []
circle_markers = []
min_exp = min(mersenne_exponents)
max_exp = max(mersenne_exponents)
log_min = np.log(min_exp)
log_max = np.log(max_exp)
min_freq_exp = -4.459
max_freq_exp = 5.506
exponent_range = max_freq_exp - min_freq_exp
log_range = log_max - log_min
for i, (x_new, y_new, label) in enumerate(curves):
    x_end = x_new[-1]
    y_end = y_new[-1]
    x_start = x_end
    y_start = start_y
    angle = wedge_angles[i]
    flag_x = x_end
    flag_y = start_y - flag_length * (i % 2 + 1) / 2
    flag_positions.append((flag_x, flag_y))
    annotation_objects.append(None)
    # Harmonic frequency mapping
    exp = mersenne_exponents[i]
    log_exp = np.log(exp)
    normalized_log = (log_exp - log_min) / log_range if log_range != 0 else 0
    freq_exp = min_freq_exp + normalized_log * exponent_range
    frequency = np.exp(freq_exp)
    harmonic_frequencies.append(frequency)
    circle_markers.append(None)
# Multi-window setup
# Window 1: 2D Plotter
fig_2d = plt.figure(figsize=(12, 8), num="2D Plotter")
ax_2d = fig_2d.add_subplot(111)
# Window 2: 3D Polyhedron Model
fig_3d = plt.figure(figsize=(10, 6), num="3D Polyhedron Model")
ax_3d = fig_3d.add_subplot(111, projection='3d')
# Window 3: Controls
fig_controls = plt.figure(figsize=(4, 6), num="Controls")
ax_scale = fig_controls.add_axes([0.2, 0.8, 0.6, 0.03])
scale_slider = Slider(ax_scale, 'Scale', 0.5, 2.0, valinit=1.0)
ax_kappa = fig_controls.add_axes([0.2, 0.7, 0.6, 0.03])
kappa_slider = Slider(ax_kappa, 'Kappa', 0.1, 2.0, valinit=kappa)
ax_decay = fig_controls.add_axes([0.2, 0.6, 0.6, 0.03])
decay_slider = Slider(ax_decay, 'Decay', 0.1, 1.0, valinit=0.5)
ax_meta = fig_controls.add_axes([0.2, 0.5, 0.6, 0.03])
meta_textbox = TextBox(ax_meta, 'Meta Value', initial="1")
ax_grid_density = fig_controls.add_axes([0.2, 0.4, 0.6, 0.03])
grid_density_slider = Slider(ax_grid_density, 'Grid Density', 50, 200, valinit=110, valstep=1)
# Add Render Model button
ax_render = fig_controls.add_axes([0.2, 0.3, 0.6, 0.05])
render_button = Button(ax_render, 'Render Model')
# Plot setup for 2D Plotter
max_dimension = max(WIDTH, HEIGHT + 1.5)
padding = 0.5
ax_2d.set_xlim(-padding, max_dimension + padding)
ax_2d.set_ylim(-padding, max_dimension + padding)
# A3 page
ax_2d.plot([0, WIDTH, WIDTH, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k-', label='A3 Page')
ax_2d.plot([0, 1.0, 1.0, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 1')
ax_2d.plot([1.0, 2.0, 2.0, 1.0, 1.0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 2')
for x in PURPLE_LINES:
    ax_2d.plot([x, x], [0, HEIGHT], 'm-', label='Projection Space Dividers' if x == PURPLE_LINES[0] else "")
ax_2d.plot([0, WIDTH], [0, 0], 'r-')
# Function to generate a kappa curve between two points
def generate_kappa_curve(x1, y1, x2, y2, kappa_val, ds=0.02):
    # Compute chord length and initial/final directions
    chord = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    if chord == 0:
        return [x1], [y1]
    # Initial direction (assume tangent at start is along the chord)
    theta0 = np.arctan2(y2 - y1, x2 - x1)
    # Arc length (approximate as chord length for simplicity)
    s_total = chord
    s = np.arange(0, s_total + ds, ds)
    # Constant kappa scaled by chord length
    kappa_s = kappa_val / chord
    # Integrate curvature to get tangent angle
    theta = theta0 + kappa_s * s
    # Integrate to get x, y coordinates
    x = np.zeros_like(s)
    y = np.zeros_like(s)
    x[0], y[0] = x1, y1
    for i in range(1, len(s)):
        x[i] = x[i-1] + ds * np.cos(theta[i-1])
        y[i] = y[i-1] + ds * np.sin(theta[i-1])
    # Scale and shift to match endpoint
    x_end, y_end = x[-1], y[-1]
    scale_x = (x2 - x1) / (x_end - x1) if (x_end - x1) != 0 else 1
    scale_y = (y2 - y1) / (y_end - y1) if (y_end - y1) != 0 else 1
    scale = min(scale_x, scale_y)
    x = x1 + (x - x1) * scale
    y = y1 + (y - y1) * scale
    return x, y
# Single continuous green kappa curve
def compute_green_kappa_curve(T=1.0, kappa_val=kappa):
    nodes = [
        (1/3, 0),
        (1/3 + 1/9, 0.1 * T),
        (1/3 + 2/9, 0.1 * T),
        (2/3, 0)
    ]
    x_all, y_all = [], []
    chord_lengths = []
    x_all.append(nodes[0][0])
    y_all.append(nodes[0][1])
    for i in range(len(nodes) - 1):
        x1, y1 = nodes[i]
        x2, y2 = nodes[i+1]
        chord = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        chord_lengths.append(chord)
        x_seg, y_seg = generate_kappa_curve(x1, y1, x2, y2, kappa_val)
        x_all.extend(x_seg[1:])
        y_all.extend(y_seg[1:])
    return np.array(x_all), np.array(y_all), chord_lengths
# Initial green kappa curve
T = 1.0
x_green, y_green, chord_lengths = compute_green_kappa_curve(T)
green_spiral, = ax_2d.plot(x_green, y_green, 'g-', label='Green Kappa Curve')
green_nodes = [ax_2d.plot([node[0]], [node[1]], 'go', markersize=6)[0] for node in [(1/3, 0), (1/3 + 1/9, 0.1), (1/3 + 2/9, 0.1), (2/3, 0)]]
# Protractor elements
protractor_line, = ax_2d.plot([], [], 'c-', label='Protractor Line')
protractor_arc, = ax_2d.plot([], [], 'c--', label='Protractor Arc')
protractor_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
protractor_spiral_2, = ax_2d.plot([], [], 'm-', label='Protractor Spiral 2')
ghost_curves = [ax_2d.plot([], [], 'b--', alpha=0.5)[0] for _ in range(4)]
# Cursor elements
cursor, = ax_2d.plot([], [], 'rx', markersize=10, label='Cursor')
cursor_text = ax_2d.text(0, 0, '', ha='left', va='bottom', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
# Ruler elements
ruler_line, = ax_2d.plot([], [], 'y-', label='Ruler Line')
ruler_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
# Toggle flags
show_protractor = False
show_ruler = False
show_harmonics = False
show_draw = False
show_dimension = False
show_pro_mode = False
# Drawing elements
kappa_nodes = []
kappa_curves = []
ghost_handles = []
selected_node = None
drag_start = None
# Grid lines (toggleable and programmable)
grid_lines = []
show_grid = True
def update_grid(density):
    global grid_lines
    for line in grid_lines:
        line.remove()
    grid_lines = []
    step_x = WIDTH / density
    step_y = HEIGHT / density
    for i in range(density + 1):
        x = i * step_x
        y = i * step_y
        vline, = ax_2d.plot([x, x], [0, HEIGHT], 'k--', alpha=0.3)
        hline, = ax_2d.plot([0, WIDTH], [y, y], 'k--', alpha=0.3)
        grid_lines.extend([vline, hline])
    fig_2d.canvas.draw()
# Initial grid
update_grid(110)
# Toggle grid with 'g'
def toggle_grid(event):
    global show_grid
    if event.key == 'g':
        show_grid = not show_grid
        for line in grid_lines:
            line.set_visible(show_grid)
        fig_2d.canvas.draw()
# Connect toggle grid
fig_2d.canvas.mpl_connect('key_press_event', toggle_grid)
# Update grid with slider
def on_grid_density_change(val):
    update_grid(int(val))
grid_density_slider.on_changed(on_grid_density_change)
# Move legend outside viewport
handles, labels = ax_2d.get_legend_handles_labels()
fig_2d.legend(handles, labels, loc='upper left', bbox_to_anchor=(1.05, 1), borderaxespad=0.)
# Maximize windows
fig_2d.canvas.manager.window.showMaximized()
fig_3d.canvas.manager.window.showMaximized()
fig_controls.canvas.manager.window.showMaximized()
# Add Navigation Toolbar (assuming Tk backend; may need adjustment for other backends)
from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
toolbar_2d = NavigationToolbar2Tk(fig_2d.canvas, fig_2d.canvas.manager.window)
toolbar_3d = NavigationToolbar2Tk(fig_3d.canvas, fig_3d.canvas.manager.window)
# Render button callback (assuming update_3d_model exists; replace with actual function if different)
def on_render_button(event):
    update_3d_model()  # Call your 3D rendering function here; e.g., display_pod_surface() or equivalent
render_button.on_clicked(on_render_button)
# ... (The rest of the original code remains unchanged, including event connections, plot properties, and plt.show())
# Pick event for Mersenne primes
def on_pick_mersenne(event):
    if isinstance(event.artist, plt.Line2D):
        thisline = event.artist
        ind = event.ind
        if ind is not None and len(ind) > 0:
            i = ind[0]
            exponent = mersenne_exponents[i]
            print(f"Selected Mersenne prime: 2^{exponent} - 1")
            for j, line in enumerate(curve_lines):
                if line is not None:
                    line.set_linewidth(1.0 if j != i else 3.0)
            fig_2d.canvas.draw()
# Click to deselect
def on_click_deselect(event):
    if event.button == 3:  # Right click
        for line in curve_lines:
            if line is not None:
                line.set_linewidth(1.0)
        fig_2d.canvas.draw()
# Toggle protractor
def toggle_protractor(event):
    global show_protractor
    if event.key == 'p':
        show_protractor = not show_protractor
        protractor_line.set_visible(show_protractor)
        protractor_arc.set_visible(show_protractor)
        protractor_text.set_visible(show_protractor)
        protractor_spiral_2.set_visible(show_protractor)
        for ghost in ghost_curves:
            ghost.set_visible(show_protractor)
        print(f"Protractor {'shown' if show_protractor else 'hidden'}")
        fig_2d.canvas.draw()
# Toggle ruler
def toggle_ruler(event):
    global show_ruler
    if event.key == 'r':
        show_ruler = not show_ruler
        ruler_line.set_visible(show_ruler)
        ruler_text.set_visible(show_ruler)
        print(f"Ruler {'shown' if show_ruler else 'hidden'}")
        fig_2d.canvas.draw()
# Click for ruler start
def on_click_ruler(event):
    if show_ruler and event.inaxes == ax_2d and event.button == 1:
        global ruler_start
        ruler_start = (event.xdata, event.ydata)
# Motion for protractor and cursor
def on_motion_protractor(event):
    if event.inaxes != ax_2d:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    # Update cursor
    cursor.set_data([x], [y])
    # Update protractor if shown
    if show_protractor:
        anchor_x, anchor_y = 0.0, 0.0
        protractor_line.set_data([anchor_x, x], [anchor_y, y])
        dx = x - anchor_x
        dy = y - anchor_y
        angle = np.arctan2(dy, dx) * 180 / np.pi
        mid_x = (anchor_x + x) / 2
        mid_y = (anchor_y + y) / 2
        radius_arc = np.sqrt(dx**2 + dy**2) / 4
        start_angle = 0
        end_angle = angle
        num_points = 100
        theta_arc = np.linspace(np.deg2rad(start_angle), np.deg2rad(end_angle), num_points)
        x_arc = mid_x + radius_arc * np.cos(theta_arc)
        y_arc = mid_y + radius_arc * np.sin(theta_arc)
        protractor_arc.set_data(x_arc, y_arc)
        offsets = [-10, -5, 5, 10]
        for i, offset in enumerate(offsets):
            angle_offset = angle + offset
            x_ghost, y_ghost = compute_curve_points(np.pi, 2 * np.pi, num_points // 2, 1.0, angle_offset)
            ghost_curves[i].set_data(anchor_x + x_ghost, anchor_y + y_ghost)
        line_vec = np.array([x - anchor_x, y - anchor_y])
        line_len = np.sqrt(dx**2 + dy**2)
        if line_len == 0:
            line_len = 1e-10
        normal_vec = np.array([-(y - anchor_y), x - anchor_x]) / line_len
        x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
        x_mirrored = []
        y_mirrored = []
        for xs, ys in zip(x_spiral, y_spiral):
            point = np.array([xs, ys])
            v = point - np.array([anchor_x, anchor_y])
            projection = np.dot(v, normal_vec) * normal_vec
            mirrored_point = point - 2 * projection
            x_mirrored.append(mirrored_point[0])
            y_mirrored.append(mirrored_point[1])
        protractor_spiral_2.set_data(x + x_mirrored, y + y_mirrored)
        protractor_text.set_position((mid_x, mid_y))
        protractor_text.set_text(f'Angle: {angle:.2f}°\nκ at 2πR: {kappa_at_2piR:.4f}')
    # Update ruler if shown
    if show_ruler and 'ruler_start' in globals():
        ruler_line.set_data([ruler_start[0], x], [ruler_start[1], y])
        dist = np.sqrt((x - ruler_start[0])**2 + (y - ruler_start[1])**2)
        mid_x_r = (ruler_start[0] + x) / 2
        mid_y_r = (ruler_start[1] + y) / 2
        ruler_text.set_position((mid_x_r, mid_y_r))
        ruler_text.set_text(f'Dist: {dist:.4f}')
    # Update cursor text
    height_factor = y / HEIGHT if HEIGHT != 0 else 0
    baseline_spiral_1 = compute_curve_points(0, np.pi, 100, height_factor)
    x_base_spiral_1, y_base_spiral_1 = baseline_spiral_1
    baseline_chord = np.sqrt((x_base_spiral_1[-1] - x_base_spiral_1[0])**2 + (y_base_spiral_1[-1] - y_base_spiral_1[0])**2)
    baseline_spiral_2 = compute_curve_points(np.pi, 2 * np.pi, 100, height_factor)
    x_base_spiral_2, y_base_spiral_2 = baseline_spiral_2
    baseline_chord_2 = np.sqrt((x_base_spiral_2[-1] - x_base_spiral_2[0])**2 + (y_base_spiral_2[-1] - y_base_spiral_2[0])**2)
    x_start_green = x_green_final[0]
    y_start_green = y_green_scaled[0]
    chord_to_green = np.sqrt((x - x_start_green)**2 + (y - y_start_green)**2)
    text_str = (f'κ: {scale_factor:.4f}\n'
                f'Height Factor: {height_factor:.4f}\n'
                f'Cursor: ({x:.4f}, {y:.4f})\n'
                f'Chord to Green: {chord_to_green:.4f}\n'
                f'Baseline Chord (x=0): {baseline_chord:.4f}\n'
                f'Baseline Chord (x=1): {baseline_chord_2:.4f}')
    cursor_text.set_text(text_str)
    cursor_text.set_position((x + 0.05, y + 0.05))
    fig_2d.canvas.draw_idle()
# Toggle harmonics
def toggle_harmonics(event):
    global show_harmonics
    if event.key == 'h':
        show_harmonics = not show_harmonics
        for text in harmonic_texts:
            text.set_visible(show_harmonics)
        print(f"Harmonic frequencies {'shown' if show_harmonics else 'hidden'}")
        fig_2d.canvas.draw()
# Save plot
def save_plot(event):
    if event.key == 'w':
        plt.savefig("nu_curve.png", dpi=300, bbox_inches='tight')
        print("Plot saved as nu_curve.png")
        if MPLD3_AVAILABLE:
            mpld3.save_html(fig_2d, "nu_curve.html")
            print("Interactive plot saved as nu_curve.html")
        else:
            print("Skipping HTML export because mpld3 is not installed.")
# Connect events
fig_2d.canvas.mpl_connect('pick_event', on_pick_mersenne)
fig_2d.canvas.mpl_connect('button_press_event', on_click_deselect)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_harmonics)
fig_2d.canvas.mpl_connect('key_press_event', save_plot)
fig_2d.canvas.mpl_connect('key_press_event', toggle_draw)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('key_press_event', toggle_dimension)
fig_2d.canvas.mpl_connect('key_press_event', to_construction)
fig_2d.canvas.mpl_connect('key_press_event', hide_show)
fig_2d.canvas.mpl_connect('key_press_event', reset_canvas)
fig_2d.canvas.mpl_connect('key_press_event', save_stl)
fig_2d.canvas.mpl_connect('button_press_event', on_click_protractor)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_dimension)
fig_2d.canvas.mpl_connect('button_press_event', on_click_draw)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion)
fig_2d.canvas.mpl_connect('key_press_event', auto_close)
fig_2d.canvas.mpl_connect('key_press_event', toggle_pro_mode)
fig_2d.canvas.mpl_connect('pick_event', on_pick)
fig_2d.canvas.mpl_connect('button_press_event', on_button_press)
fig_2d.canvas.mpl_connect('button_release_event', on_button_release)
# Plot properties
ax_2d.set_xlim(-0.1, WIDTH + 0.1)
ax_2d.set_ylim(-1.5, HEIGHT + 0.1)
ax_2d.set_xlabel('x (Exponents: 2 to 11B)')
ax_2d.set_ylabel('y')
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
ax_2d.grid(True)
ax_2d.set_aspect('equal')
# Display default pod surface and draw default pod
def display_pod_surface():
    # Implement pod surface generation using NURKS or similar
    vertices, faces, face_colors, control_x, control_y, control_z, res = compute_nurks_surface()
    mesh = Poly3DCollection([vertices[face] for face in faces], facecolors=face_colors, edgecolors='k', alpha=0.8)
    ax_3d.add_collection3d(mesh)
    ax_3d.scatter(control_x, control_y, control_z, c='r', s=20)
    ax_3d.set_xlim([-2, 2])
    ax_3d.set_ylim([-2, 2])
    ax_3d.set_zlim([-2, 2])
    fig_3d.canvas.draw()
def draw_default_pod(ax):
    # Draw a default pod shape in 2D
    theta = np.linspace(0, 2*np.pi, 100)
    r = 0.5 + 0.2 * np.sin(6 * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta) + 0.5
    ax.plot(x, y, 'b-', label='Default Pod')
    fig_2d.canvas.draw()
display_pod_surface()
draw_default_pod(ax_2d)
# Update green kappa curve with sliders
def update_green_kappa_curve(val):
    global T, x_green, y_green, chord_lengths
    kappa_val = kappa_slider.val
    decay = decay_slider.val
    x_green_new, y_green_new, chord_lengths_new = compute_green_kappa_curve(T, kappa_val)
    for i in range(len(chord_lengths)):
        chord_lengths[i] = chord_lengths[i] * (1 - decay) + chord_lengths_new[i] * decay
    green_spiral.set_data(x_green_new, y_green_new)
    x_green, y_green, chord_lengths = x_green_new, y_green_new, chord_lengths_new
    nodes = [(1/3, 0), (1/3 + 1/9, 0.1 * T), (1/3 + 2/9, 0.1 * T), (2/3, 0)]
    for i, node in enumerate(nodes):
        green_nodes[i].set_data([node[0]], [node[1]])
    fig_2d.canvas.draw()
kappa_slider.on_changed(update_green_kappa_curve)
decay_slider.on_changed(update_green_kappa_curve)
# Define compute_curve_points (placeholder; implement as needed)
def compute_curve_points(start_theta, end_theta, num_points, scale, angle_offset=0):
    theta = np.linspace(start_theta, end_theta, num_points) + np.deg2rad(angle_offset)
    r = A_SPIRAL * np.exp(B_SPIRAL * theta) * scale
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    return x, y
# Toggle draw mode
def toggle_draw(event):
    global show_draw
    if event.key == 'd':
        show_draw = not show_draw
        print(f"Draw mode {'enabled' if show_draw else 'disabled'}")
# Click for draw
def on_click_draw(event):
    if show_draw and event.inaxes == ax_2d and event.button == 1:
        x, y = event.xdata, event.ydata
        kappa_nodes.append((x, y))
        ax_2d.plot(x, y, 'ro')
        if len(kappa_nodes) > 1:
            x1, y1 = kappa_nodes[-2]
            x2, y2 = kappa_nodes[-1]
            x_curve, y_curve = generate_kappa_curve(x1, y1, x2, y2, kappa_slider.val)
            curve, = ax_2d.plot(x_curve, y_curve, 'g-')
            kappa_curves.append(curve)
        fig_2d.canvas.draw()
# Toggle dimension
def toggle_dimension(event):
    global show_dimension
    if event.key == 'm':
        show_dimension = not show_dimension
        print(f"Dimension mode {'enabled' if show_dimension else 'disabled'}")
# Click for dimension
def on_click_dimension(event):
    if show_dimension and event.inaxes == ax_2d and event.button == 1:
        # Placeholder for adding dimension labels
        pass
# To construction
def to_construction(event):
    if event.key == 'c':
        # Placeholder for converting to construction geometry
        pass
# Hide show
def hide_show(event):
    if event.key == 'h':
        # Placeholder for hide/show elements
        pass
# Reset canvas
def reset_canvas(event):
    if event.key == 'r':
        # Placeholder for resetting canvas
        pass
# Save STL
def save_stl(event):
    if event.key == 's':
        # Placeholder for saving STL
        pass
# Click protractor
def on_click_protractor(event):
    if show_protractor and event.inaxes == ax_2d and event.button == 1:
        # Placeholder for protractor interaction
        pass
# Motion general
def on_motion(event):
    # Placeholder for general motion events
    pass
# Auto close
def auto_close(event):
    if event.key == 'a':
        # Placeholder for auto closing curves
        pass
# Toggle pro mode
def toggle_pro_mode(event):
    global show_pro_mode
    if event.key == 'p':
        show_pro_mode = not show_pro_mode
        print(f"Pro mode {'enabled' if show_pro_mode else 'disabled'}")
# Pick general
def on_pick(event):
    # Placeholder for general pick events
    pass
# Button press
def on_button_press(event):
    # Placeholder for button press
    pass
# Button release
def on_button_release(event):
    # Placeholder for button release
    pass
# Update 3D model (placeholder; implement as needed)
def update_3d_model():
    ax_3d.cla()
    display_pod_surface()
    fig_3d.canvas.draw()
# Run the application
plt.show()

# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import cm
from matplotlib.widgets import Slider, Button, TextBox
import hashlib
from decimal import Decimal, getcontext
import warnings
from matplotlib import MatplotlibDeprecationWarning
import struct
import base64
# Import mpld3 if available for HTML export
try:
    import mpld3
    MPLD3_AVAILABLE = True
except ImportError:
    print("mpld3 not installed. HTML export will be skipped. Install mpld3 with 'pip install mpld3' to enable.")
    MPLD3_AVAILABLE = False
# Placeholder imports for custom modules; implement or replace as needed
# from temperature_salt import secure_hash_two
# from kappawise import kappa_coord
# from nurks_surface import bspline_basis, bspline_basis_periodic, custom_interoperations_green_curve
def bspline_basis(u, i, p, knots):
    """
    Recursive B-spline basis function.
    """
    if p == 0:
        return 1.0 if knots[i] <= u <= knots[i + 1] else 0.0
    den1 = knots[i + p] - knots[i]
    den2 = knots[i + p + 1] - knots[i + 1]
    term1 = ((u - knots[i]) / den1 * bspline_basis(u, i, p - 1, knots)) if den1 > 0 else 0.0
    term2 = ((knots[i + p + 1] - u) / den2 * bspline_basis(u, i + 1, p - 1, knots)) if den2 > 0 else 0.0
    return term1 + term2

def custom_interoperations_green_curve(points, kappas, is_closed=False):
    """
    Custom Non-Uniform Rational Kappa Spline (NURKS) approximation for green curve with closure adjustments.
    """
    points = np.array(points)
    kappas = np.array(kappas)
    degree = 3  # Fixed degree for continuity
    num_output_points = 1000
    
    if is_closed and len(points) > degree:
        points = np.concatenate((points, points[0:degree]))
        kappas = np.concatenate((kappas, kappas[0:degree]))
    
    n = len(points) - 1
    # Uniform knot vector for simplicity; adjust for non-uniform if needed
    knots = np.linspace(0, 1, n - degree + 2)
    knots = np.concatenate((np.zeros(degree), knots, np.ones(degree)))
    
    u = np.linspace(0, 1, num_output_points)
    curve = np.zeros((num_output_points, 2))
    for idx, uu in enumerate(u):
        for i in range(n + 1):
            basis = bspline_basis(uu, i, degree, knots)
            curve[idx] += basis * points[i] * kappas[i]  # Weighted by kappa for rational approx
    
    return curve[:, 0], curve[:, 1]

# Set precision for Decimal
getcontext().prec = 28
# Suppress warnings
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)
# A3 landscape dimensions (normalized: width long side, height short side)
WIDTH = 420 / 297 # A3 landscape: 420mm width, 297mm height, normalized height=1.0
HEIGHT = 1.0
PURPLE_LINES = [1/3, 2/3] # Dividers on the width
unit_per_mm = 1.0 / 297 # Normalize to A3 short side
scale_label = f"Scale: 1mm = {unit_per_mm:.5f} units (A3 short side = 297mm)"
# Dreyfuss human factors: Optimal eye distance ~20 inches (508mm)
EYE_DISTANCE = 500 * unit_per_mm # Normalized eye distance to viewport
HORIZON_HEIGHT = HEIGHT * 0.5 # Default horizon line at half height
EYE_LINE = HORIZON_HEIGHT # Eye line coincides with horizon
# Golden spiral parameters
PHI = (1 + np.sqrt(5)) / 2
kappa = 1 / PHI
A_SPIRAL = 0.001 # Scaled down slightly from 0.01 to fit better
B_SPIRAL = np.log(PHI) / (np.pi / 2)
# Define κθπ for the green segment
theta_max = kappa * np.pi**2 / PHI
# Compute the full spiral
theta_full = np.linspace(0, 10 * np.pi, 1000)
r_full = A_SPIRAL * np.exp(B_SPIRAL * theta_full)
x_full = r_full * np.cos(theta_full)
y_full = r_full * np.sin(theta_full)
# Compute the green segment (θ from π to 2π)
theta_green = np.linspace(np.pi, 2 * np.pi, 200)
r_green = A_SPIRAL * np.exp(B_SPIRAL * theta_green)
x_green = r_green * np.cos(theta_green)
y_green = r_green * np.sin(theta_green)
# Compute the chord and shift
x1, y1 = x_green[0], y_green[0]
x2, y2 = x_green[-1], y_green[-1]
chord_length = np.abs(x2 - x1)
# Shift so the segment starts at x=0
x_green_shifted = x_green - x1
x_green_final = x_green_shifted
# Scale to match the target chord length (between purple lines)
target_chord = PURPLE_LINES[1] - PURPLE_LINES[0]
scale_factor = target_chord / chord_length if chord_length != 0 else 1.0
x_green_scaled = x_green_final * scale_factor
y_green_scaled = y_green * scale_factor
# Shift to start at the first purple line
x_green_final = x_green_scaled + PURPLE_LINES[0]
# Compute κ at 2πR for the green segment
r_max = A_SPIRAL * np.exp(B_SPIRAL * theta_max)
two_pi_r = 2 * np.pi * r_max
kappa_at_2piR = two_pi_r / PHI
# Define the 52 Mersenne prime exponents (updated with the latest known as of 2025)
mersenne_exponents = [
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
    3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
    110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
    6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
    37156667, 42643801, 43112609, 57885161, 74207281, 77232917, 82589933,
    136279841 # Latest known Mersenne prime exponent as of 2025 (52nd)
]
# Map exponents to x-positions (0 to width)
min_exponent = 2
max_exponent_at_x1 = 1_100_000_000
exponent_range_per_x = (max_exponent_at_x1 - min_exponent) / 1.0
x_positions = [(exponent - min_exponent) / exponent_range_per_x * WIDTH for exponent in mersenne_exponents] # Scale to full WIDTH
# Create the 52 curves data
curves = []
curve_lines = []
for i, (exponent, x_pos) in enumerate(zip(mersenne_exponents, x_positions)):
    scale = x_pos / chord_length if chord_length != 0 else 1.0
    x_new = x_green * scale
    y_new = y_green * scale
    x_new_shifted = x_new - x_new[0]
    curves.append((x_new_shifted, y_new, f"M{exponent}"))
    curve_lines.append(None)
# A3 divisions (297 parts on short side)
division_step = HEIGHT / 297
division_positions = np.arange(0, HEIGHT + division_step, division_step)
# Scale key for the title
scale_key_positions = division_positions[::30] # Every 30mm
scale_key_exponents = [int(min_exponent + (max_exponent_at_x1 - min_exponent) * (y / HEIGHT)) for y in scale_key_positions]
scale_key_text = "Scale (y=0 to 1): " + ", ".join([f"{y:.2f}: {exp:,}" for y, exp in zip(scale_key_positions, scale_key_exponents)])
# Flags for Mersenne primes
flag_length = 0.5
start_y = -0.1
wedge_angles = np.linspace(90, 360, len(curves))
flag_positions = []
annotation_objects = []
harmonic_frequencies = []
circle_markers = []
min_exp = min(mersenne_exponents)
max_exp = max(mersenne_exponents)
log_min = np.log(min_exp)
log_max = np.log(max_exp)
min_freq_exp = -4.459
max_freq_exp = 5.506
exponent_range = max_freq_exp - min_freq_exp
log_range = log_max - log_min
for i, (x_new, y_new, label) in enumerate(curves):
    x_end = x_new[-1]
    y_end = y_new[-1]
    x_start = x_end
    y_start = start_y
    angle = wedge_angles[i]
    flag_x = x_end
    flag_y = start_y - flag_length * (i % 2 + 1) / 2
    flag_positions.append((flag_x, flag_y))
    annotation_objects.append(None)
    # Harmonic frequency mapping
    exp = mersenne_exponents[i]
    log_exp = np.log(exp)
    normalized_log = (log_exp - log_min) / log_range if log_range != 0 else 0
    freq_exp = min_freq_exp + normalized_log * exponent_range
    frequency = np.exp(freq_exp)
    harmonic_frequencies.append(frequency)
    circle_markers.append(None)
# Multi-window setup
# Window 1: 2D Plotter
fig_2d = plt.figure(figsize=(12, 8), num="2D Plotter")
ax_2d = fig_2d.add_subplot(111)
# Window 2: 3D Polyhedron Model
fig_3d = plt.figure(figsize=(10, 6), num="3D Polyhedron Model")
ax_3d = fig_3d.add_subplot(111, projection='3d')
# Window 3: Controls
fig_controls = plt.figure(figsize=(4, 6), num="Controls")
ax_scale = fig_controls.add_axes([0.2, 0.8, 0.6, 0.03])
scale_slider = Slider(ax_scale, 'Scale', 0.5, 2.0, valinit=1.0)
ax_kappa = fig_controls.add_axes([0.2, 0.7, 0.6, 0.03])
kappa_slider = Slider(ax_kappa, 'Kappa', 0.1, 2.0, valinit=kappa)
ax_decay = fig_controls.add_axes([0.2, 0.6, 0.6, 0.03])
decay_slider = Slider(ax_decay, 'Decay', 0.1, 1.0, valinit=0.5)
ax_meta = fig_controls.add_axes([0.2, 0.5, 0.6, 0.03])
meta_textbox = TextBox(ax_meta, 'Meta Value', initial="1")
ax_grid_density = fig_controls.add_axes([0.2, 0.4, 0.6, 0.03])
grid_density_slider = Slider(ax_grid_density, 'Grid Density', 50, 200, valinit=110, valstep=1)
# Add Render Model button
ax_render = fig_controls.add_axes([0.2, 0.3, 0.6, 0.05])
render_button = Button(ax_render, 'Render Model')
# Plot setup for 2D Plotter
max_dimension = max(WIDTH, HEIGHT + 1.5)
padding = 0.5
ax_2d.set_xlim(-padding, max_dimension + padding)
ax_2d.set_ylim(-padding, max_dimension + padding)
# A3 page
ax_2d.plot([0, WIDTH, WIDTH, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k-', label='A3 Page')
ax_2d.plot([0, 1.0, 1.0, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 1')
ax_2d.plot([1.0, 2.0, 2.0, 1.0, 1.0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 2')
for x in PURPLE_LINES:
    ax_2d.plot([x, x], [0, HEIGHT], 'm-', label='Projection Space Dividers' if x == PURPLE_LINES[0] else "")
ax_2d.plot([0, WIDTH], [0, 0], 'r-')
# Function to generate a kappa curve between two points
def generate_kappa_curve(x1, y1, x2, y2, kappa_val, ds=0.02):
    # Compute chord length and initial/final directions
    chord = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    if chord == 0:
        return [x1], [y1]
    # Initial direction (assume tangent at start is along the chord)
    theta0 = np.arctan2(y2 - y1, x2 - x1)
    # Arc length (approximate as chord length for simplicity)
    s_total = chord
    s = np.arange(0, s_total + ds, ds)
    # Constant kappa scaled by chord length
    kappa_s = kappa_val / chord
    # Integrate curvature to get tangent angle
    theta = theta0 + kappa_s * s
    # Integrate to get x, y coordinates
    x = np.zeros_like(s)
    y = np.zeros_like(s)
    x[0], y[0] = x1, y1
    for i in range(1, len(s)):
        x[i] = x[i-1] + ds * np.cos(theta[i-1])
        y[i] = y[i-1] + ds * np.sin(theta[i-1])
    # Scale and shift to match endpoint
    x_end, y_end = x[-1], y[-1]
    scale_x = (x2 - x1) / (x_end - x1) if (x_end - x1) != 0 else 1
    scale_y = (y2 - y1) / (y_end - y1) if (y_end - y1) != 0 else 1
    scale = min(scale_x, scale_y)
    x = x1 + (x - x1) * scale
    y = y1 + (y - y1) * scale
    return x, y
# Single continuous green kappa curve
def compute_green_kappa_curve(T=1.0, kappa_val=kappa):
    nodes = [
        (1/3, 0),
        (1/3 + 1/9, 0.1 * T),
        (1/3 + 2/9, 0.1 * T),
        (2/3, 0)
    ]
    x_all, y_all = [], []
    chord_lengths = []
    x_all.append(nodes[0][0])
    y_all.append(nodes[0][1])
    for i in range(len(nodes) - 1):
        x1, y1 = nodes[i]
        x2, y2 = nodes[i+1]
        chord = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        chord_lengths.append(chord)
        x_seg, y_seg = generate_kappa_curve(x1, y1, x2, y2, kappa_val)
        x_all.extend(x_seg[1:])
        y_all.extend(y_seg[1:])
    return np.array(x_all), np.array(y_all), chord_lengths
# Initial green kappa curve
T = 1.0
x_green, y_green, chord_lengths = compute_green_kappa_curve(T)
green_spiral, = ax_2d.plot(x_green, y_green, 'g-', label='Green Kappa Curve')
green_nodes = [ax_2d.plot([node[0]], [node[1]], 'go', markersize=6)[0] for node in [(1/3, 0), (1/3 + 1/9, 0.1), (1/3 + 2/9, 0.1), (2/3, 0)]]
# Protractor elements
protractor_line, = ax_2d.plot([], [], 'c-', label='Protractor Line')
protractor_arc, = ax_2d.plot([], [], 'c--', label='Protractor Arc')
protractor_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
protractor_spiral_2, = ax_2d.plot([], [], 'm-', label='Protractor Spiral 2')
ghost_curves = [ax_2d.plot([], [], 'b--', alpha=0.5)[0] for _ in range(4)]
# Cursor elements
cursor, = ax_2d.plot([], [], 'rx', markersize=10, label='Cursor')
cursor_text = ax_2d.text(0, 0, '', ha='left', va='bottom', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
# Ruler elements
ruler_line, = ax_2d.plot([], [], 'y-', label='Ruler Line')
ruler_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
# Toggle flags
show_protractor = False
show_ruler = False
show_harmonics = False
show_draw = False
show_dimension = False
show_pro_mode = False
# Drawing elements
kappa_nodes = []
kappa_curves = []
ghost_handles = []
selected_node = None
drag_start = None
# Grid lines (toggleable and programmable)
grid_lines = []
show_grid = True
def update_grid(density):
    global grid_lines
    for line in grid_lines:
        line.remove()
    grid_lines = []
    step_x = WIDTH / density
    step_y = HEIGHT / density
    for i in range(int(density) + 1):
        x = i * step_x
        y = i * step_y
        vline, = ax_2d.plot([x, x], [0, HEIGHT], 'k--', alpha=0.3)
        hline, = ax_2d.plot([0, WIDTH], [y, y], 'k--', alpha=0.3)
        grid_lines.extend([vline, hline])
    fig_2d.canvas.draw()
# Initial grid
update_grid(110)
# Toggle grid with 'g'
def toggle_grid(event):
    global show_grid
    if event.key == 'g':
        show_grid = not show_grid
        for line in grid_lines:
            line.set_visible(show_grid)
        fig_2d.canvas.draw()
# Connect toggle grid
fig_2d.canvas.mpl_connect('key_press_event', toggle_grid)
# Update grid with slider
def on_grid_density_change(val):
    update_grid(int(val))
grid_density_slider.on_changed(on_grid_density_change)
# Move legend outside viewport
handles, labels = ax_2d.get_legend_handles_labels()
fig_2d.legend(handles, labels, loc='upper left', bbox_to_anchor=(1.05, 1), borderaxespad=0.)
# Maximize windows
try:
    fig_2d.canvas.manager.window.showMaximized()
    fig_3d.canvas.manager.window.showMaximized()
    fig_controls.canvas.manager.window.showMaximized()
except AttributeError:
    print("Window maximization not supported in this backend.")
# Add Navigation Toolbar (assuming Tk backend; may need adjustment for other backends)
try:
    from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
    toolbar_2d = NavigationToolbar2Tk(fig_2d.canvas, fig_2d.canvas.manager.window)
    toolbar_3d = NavigationToolbar2Tk(fig_3d.canvas, fig_3d.canvas.manager.window)
except ImportError:
    print("NavigationToolbar2Tk not available; skipping toolbar addition.")
# Render button callback
def on_render_button(event):
    update_3d_model()  # Call the 3D rendering function
render_button.on_clicked(on_render_button)
# Pick event for Mersenne primes
def on_pick_mersenne(event):
    if isinstance(event.artist, plt.Line2D):
        thisline = event.artist
        ind = event.ind
        if ind is not None and len(ind) > 0:
            i = ind[0]
            exponent = mersenne_exponents[i]
            print(f"Selected Mersenne prime: 2^{exponent} - 1")
            for j, line in enumerate(curve_lines):
                if line is not None:
                    line.set_linewidth(1.0 if j != i else 3.0)
            fig_2d.canvas.draw()
# Click to deselect
def on_click_deselect(event):
    if event.button == 3:  # Right click
        for line in curve_lines:
            if line is not None:
                line.set_linewidth(1.0)
        fig_2d.canvas.draw()
# Toggle protractor
def toggle_protractor(event):
    global show_protractor
    if event.key == 'p':
        show_protractor = not show_protractor
        protractor_line.set_visible(show_protractor)
        protractor_arc.set_visible(show_protractor)
        protractor_text.set_visible(show_protractor)
        protractor_spiral_2.set_visible(show_protractor)
        for ghost in ghost_curves:
            ghost.set_visible(show_protractor)
        print(f"Protractor {'shown' if show_protractor else 'hidden'}")
        fig_2d.canvas.draw()
# Toggle ruler
def toggle_ruler(event):
    global show_ruler
    if event.key == 'r':
        show_ruler = not show_ruler
        ruler_line.set_visible(show_ruler)
        ruler_text.set_visible(show_ruler)
        print(f"Ruler {'shown' if show_ruler else 'hidden'}")
        fig_2d.canvas.draw()
# Click for ruler start
def on_click_ruler(event):
    if show_ruler and event.inaxes == ax_2d and event.button == 1:
        global ruler_start
        ruler_start = (event.xdata, event.ydata)
# Motion for protractor and cursor
def on_motion_protractor(event):
    if event.inaxes != ax_2d:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    # Update cursor
    cursor.set_data([x], [y])
    # Update protractor if shown
    if show_protractor:
        anchor_x, anchor_y = 0.0, 0.0
        protractor_line.set_data([anchor_x, x], [anchor_y, y])
        dx = x - anchor_x
        dy = y - anchor_y
        angle = np.arctan2(dy, dx) * 180 / np.pi
        mid_x = (anchor_x + x) / 2
        mid_y = (anchor_y + y) / 2
        radius_arc = np.sqrt(dx**2 + dy**2) / 4
        start_angle = 0
        end_angle = angle
        num_points = 100
        theta_arc = np.linspace(np.deg2rad(start_angle), np.deg2rad(end_angle), num_points)
        x_arc = mid_x + radius_arc * np.cos(theta_arc)
        y_arc = mid_y + radius_arc * np.sin(theta_arc)
        protractor_arc.set_data(x_arc, y_arc)
        offsets = [-10, -5, 5, 10]
        for i, offset in enumerate(offsets):
            angle_offset = angle + offset
            x_ghost, y_ghost = compute_curve_points(np.pi, 2 * np.pi, num_points // 2, 1.0, angle_offset)
            ghost_curves[i].set_data(anchor_x + x_ghost, anchor_y + y_ghost)
        line_vec = np.array([x - anchor_x, y - anchor_y])
        line_len = np.sqrt(dx**2 + dy**2)
        if line_len == 0:
            line_len = 1e-10
        normal_vec = np.array([-(y - anchor_y), x - anchor_x]) / line_len
        x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
        x_mirrored = []
        y_mirrored = []
        for xs, ys in zip(x_spiral, y_spiral):
            point = np.array([xs, ys])
            v = point - np.array([anchor_x, anchor_y])
            projection = np.dot(v, normal_vec) * normal_vec
            mirrored_point = point - 2 * projection
            x_mirrored.append(mirrored_point[0])
            y_mirrored.append(mirrored_point[1])
        protractor_spiral_2.set_data(x + x_mirrored, y + y_mirrored)
        protractor_text.set_position((mid_x, mid_y))
        protractor_text.set_text(f'Angle: {angle:.2f}°\nκ at 2πR: {kappa_at_2piR:.4f}')
    # Update ruler if shown
    if show_ruler and 'ruler_start' in globals():
        ruler_line.set_data([ruler_start[0], x], [ruler_start[1], y])
        dist = np.sqrt((x - ruler_start[0])**2 + (y - ruler_start[1])**2)
        mid_x_r = (ruler_start[0] + x) / 2
        mid_y_r = (ruler_start[1] + y) / 2
        ruler_text.set_position((mid_x_r, mid_y_r))
        ruler_text.set_text(f'Dist: {dist:.4f}')
    # Update cursor text
    height_factor = y / HEIGHT if HEIGHT != 0 else 0
    baseline_spiral_1 = compute_curve_points(0, np.pi, 100, height_factor)
    x_base_spiral_1, y_base_spiral_1 = baseline_spiral_1
    baseline_chord = np.sqrt((x_base_spiral_1[-1] - x_base_spiral_1[0])**2 + (y_base_spiral_1[-1] - y_base_spiral_1[0])**2)
    baseline_spiral_2 = compute_curve_points(np.pi, 2 * np.pi, 100, height_factor)
    x_base_spiral_2, y_base_spiral_2 = baseline_spiral_2
    baseline_chord_2 = np.sqrt((x_base_spiral_2[-1] - x_base_spiral_2[0])**2 + (y_base_spiral_2[-1] - y_base_spiral_2[0])**2)
    x_start_green = x_green_final[0]
    y_start_green = y_green_scaled[0]
    chord_to_green = np.sqrt((x - x_start_green)**2 + (y - y_start_green)**2)
    text_str = (f'κ: {scale_factor:.4f}\n'
                f'Height Factor: {height_factor:.4f}\n'
                f'Cursor: ({x:.4f}, {y:.4f})\n'
                f'Chord to Green: {chord_to_green:.4f}\n'
                f'Baseline Chord (x=0): {baseline_chord:.4f}\n'
                f'Baseline Chord (x=1): {baseline_chord_2:.4f}')
    cursor_text.set_text(text_str)
    cursor_text.set_position((x + 0.05, y + 0.05))
    fig_2d.canvas.draw_idle()
# Toggle harmonics
def toggle_harmonics(event):
    global show_harmonics
    if event.key == 'h':
        show_harmonics = not show_harmonics
        for text in harmonic_texts:
            text.set_visible(show_harmonics)
        print(f"Harmonic frequencies {'shown' if show_harmonics else 'hidden'}")
        fig_2d.canvas.draw()
# Save plot
def save_plot(event):
    if event.key == 'w':
        plt.savefig("nu_curve.png", dpi=300, bbox_inches='tight')
        print("Plot saved as nu_curve.png")
        if MPLD3_AVAILABLE:
            mpld3.save_html(fig_2d, "nu_curve.html")
            print("Interactive plot saved as nu_curve.html")
        else:
            print("Skipping HTML export because mpld3 is not installed.")
# Connect events
fig_2d.canvas.mpl_connect('pick_event', on_pick_mersenne)
fig_2d.canvas.mpl_connect('button_press_event', on_click_deselect)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_harmonics)
fig_2d.canvas.mpl_connect('key_press_event', save_plot)
fig_2d.canvas.mpl_connect('key_press_event', toggle_draw)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('key_press_event', toggle_dimension)
fig_2d.canvas.mpl_connect('key_press_event', to_construction)
fig_2d.canvas.mpl_connect('key_press_event', hide_show)
fig_2d.canvas.mpl_connect('key_press_event', reset_canvas)
fig_2d.canvas.mpl_connect('key_press_event', save_stl)
fig_2d.canvas.mpl_connect('button_press_event', on_click_protractor)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_dimension)
fig_2d.canvas.mpl_connect('button_press_event', on_click_draw)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion)
fig_2d.canvas.mpl_connect('key_press_event', auto_close)
fig_2d.canvas.mpl_connect('key_press_event', toggle_pro_mode)
fig_2d.canvas.mpl_connect('pick_event', on_pick)
fig_2d.canvas.mpl_connect('button_press_event', on_button_press)
fig_2d.canvas.mpl_connect('button_release_event', on_button_release)
# Plot properties
ax_2d.set_xlim(-0.1, WIDTH + 0.1)
ax_2d.set_ylim(-1.5, HEIGHT + 0.1)
ax_2d.set_xlabel('x (Exponents: 2 to 11B)')
ax_2d.set_ylabel('y')
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
ax_2d.grid(True)
ax_2d.set_aspect('equal')
# Display default pod surface and draw default pod
def display_pod_surface():
    # Implement pod surface generation using NURKS or similar
    # Example placeholder: Generate a simple sphere mesh
    u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
    x = np.cos(u)*np.sin(v)
    y = np.sin(u)*np.sin(v)
    z = np.cos(v)
    ax_3d.plot_wireframe(x, y, z, color="r")
    fig_3d.canvas.draw()
def draw_default_pod(ax):
    # Draw a default pod shape in 2D
    theta = np.linspace(0, 2*np.pi, 100)
    r = 0.5 + 0.2 * np.sin(6 * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta) + 0.5
    ax.plot(x, y, 'b-', label='Default Pod')
    fig_2d.canvas.draw()
display_pod_surface()
draw_default_pod(ax_2d)
# Update green kappa curve with sliders
def update_green_kappa_curve(val):
    global T, x_green, y_green, chord_lengths
    kappa_val = kappa_slider.val
    decay = decay_slider.val
    x_green_new, y_green_new, chord_lengths_new = compute_green_kappa_curve(T, kappa_val)
    for i in range(len(chord_lengths)):
        chord_lengths[i] = chord_lengths[i] * (1 - decay) + chord_lengths_new[i] * decay
    green_spiral.set_data(x_green_new, y_green_new)
    x_green, y_green, chord_lengths = x_green_new, y_green_new, chord_lengths_new
    nodes = [(1/3, 0), (1/3 + 1/9, 0.1 * T), (1/3 + 2/9, 0.1 * T), (2/3, 0)]
    for i, node in enumerate(nodes):
        green_nodes[i].set_data([node[0]], [node[1]])
    fig_2d.canvas.draw()
kappa_slider.on_changed(update_green_kappa_curve)
decay_slider.on_changed(update_green_kappa_curve)
# Define compute_curve_points (placeholder; implement as needed)
def compute_curve_points(start_theta, end_theta, num_points, scale, angle_offset=0):
    theta = np.linspace(start_theta, end_theta, num_points) + np.deg2rad(angle_offset)
    r = A_SPIRAL * np.exp(B_SPIRAL * theta) * scale
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    return x, y
# Toggle draw mode
def toggle_draw(event):
    global show_draw
    if event.key == 'd':
        show_draw = not show_draw
        print(f"Draw mode {'enabled' if show_draw else 'disabled'}")
# Click for draw
def on_click_draw(event):
    if show_draw and event.inaxes == ax_2d and event.button == 1:
        x, y = event.xdata, event.ydata
        kappa_nodes.append((x, y))
        ax_2d.plot(x, y, 'ro')
        if len(kappa_nodes) > 1:
            x1, y1 = kappa_nodes[-2]
            x2, y2 = kappa_nodes[-1]
            x_curve, y_curve = generate_kappa_curve(x1, y1, x2, y2, kappa_slider.val)
            curve, = ax_2d.plot(x_curve, y_curve, 'g-')
            kappa_curves.append(curve)
        fig_2d.canvas.draw()
# Toggle dimension
def toggle_dimension(event):
    global show_dimension
    if event.key == 'm':
        show_dimension = not show_dimension
        print(f"Dimension mode {'enabled' if show_dimension else 'disabled'}")
# Click for dimension
def on_click_dimension(event):
    if show_dimension and event.inaxes == ax_2d and event.button == 1:
        # Placeholder for adding dimension labels
        pass
# To construction
def to_construction(event):
    if event.key == 'c':
        # Placeholder for converting to construction geometry
        pass
# Hide show
def hide_show(event):
    if event.key == 'h':
        # Placeholder for hide/show elements
        pass
# Reset canvas
def reset_canvas(event):
    if event.key == 'e':
        # Clear drawings and reset
        kappa_nodes.clear()
        for curve in kappa_curves:
            curve.remove()
        kappa_curves.clear()
        fig_2d.canvas.draw()
# Save STL
def save_stl(event):
    if event.key == 's':
        # Placeholder for saving STL
        print("STL export not implemented.")
# Click protractor
def on_click_protractor(event):
    if show_protractor and event.inaxes == ax_2d and event.button == 1:
        # Placeholder for protractor interaction
        pass
# Motion general
def on_motion(event):
    # Placeholder for general motion events
    pass
# Auto close
def auto_close(event):
    if event.key == 'a':
        # Placeholder for auto closing curves
        pass
# Toggle pro mode
def toggle_pro_mode(event):
    global show_pro_mode
    if event.key == 'x':
        show_pro_mode = not show_pro_mode
        print(f"Pro mode {'enabled' if show_pro_mode else 'disabled'}")
# Pick general
def on_pick(event):
    # Placeholder for general pick events
    pass
# Button press
def on_button_press(event):
    # Placeholder for button press
    pass
# Button release
def on_button_release(event):
    # Placeholder for button release
    pass
# Update 3D model
def update_3d_model():
    ax_3d.cla()
    display_pod_surface()
    fig_3d.canvas.draw()
# Run the application
plt.show()


# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import cm
from matplotlib.widgets import Slider, Button
import hashlib
from decimal import Decimal, getcontext
import warnings
from matplotlib import MatplotlibDeprecationWarning
import struct
import base64
# Import mpld3 if available for HTML export
try:
    import mpld3
    MPLD3_AVAILABLE = True
except ImportError:
    print("mpld3 not installed. HTML export will be skipped. Install mpld3 with 'pip install mpld3' to enable.")
    MPLD3_AVAILABLE = False
from temperature_salt import secure_hash_two
from kappawise import kappa_coord
from nurks_surface import bspline_basis, bspline_basis_periodic, custom_interoperations_green_curve
# Set precision for Decimal
getcontext().prec = 28
# Suppress warnings
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)
# A3 landscape dimensions (normalized: width long side, height short side)
WIDTH = 420 / 297 # A3 landscape: 420mm width, 297mm height, normalized height=1.0
HEIGHT = 1.0
PURPLE_LINES = [1/3, 2/3] # Dividers on the width
unit_per_mm = 1.0 / 297 # Normalize to A3 short side
scale_label = f"Scale: 1mm = {unit_per_mm:.5f} units (A3 short side = 297mm)"
# Dreyfuss human factors: Optimal eye distance ~20 inches (508mm)
EYE_DISTANCE = 500 * unit_per_mm # Normalized eye distance to viewport
HORIZON_HEIGHT = HEIGHT * 0.5 # Default horizon line at half height
EYE_LINE = HORIZON_HEIGHT # Eye line coincides with horizon
# Golden spiral parameters
PHI = (1 + np.sqrt(5)) / 2
kappa = 1 / PHI
A_SPIRAL = 0.001 # Scaled down slightly from 0.01 to fit better
B_SPIRAL = np.log(PHI) / (np.pi / 2)
# Define κθπ for the green segment
theta_max = kappa * np.pi**2 / PHI
# Compute the full spiral
theta_full = np.linspace(0, 10 * np.pi, 1000)
r_full = A_SPIRAL * np.exp(B_SPIRAL * theta_full)
x_full = r_full * np.cos(theta_full)
y_full = r_full * np.sin(theta_full)
# Compute the green segment (θ from π to 2π)
theta_green = np.linspace(np.pi, 2 * np.pi, 200)
r_green = A_SPIRAL * np.exp(B_SPIRAL * theta_green)
x_green = r_green * np.cos(theta_green)
y_green = r_green * np.sin(theta_green)
# Compute the chord and shift
x1, y1 = x_green[0], y_green[0]
x2, y2 = x_green[-1], y_green[-1]
chord_length = np.abs(x2 - x1)
# Shift so the segment starts at x=0
x_green_shifted = x_green - x1
x_green_final = x_green_shifted
# Scale to match the target chord length (between purple lines)
target_chord = PURPLE_LINES[1] - PURPLE_LINES[0]
scale_factor = target_chord / chord_length if chord_length != 0 else 1.0
x_green_scaled = x_green_final * scale_factor
y_green_scaled = y_green * scale_factor
# Shift to start at the first purple line
x_green_final = x_green_scaled + PURPLE_LINES[0]
# Compute κ at 2πR for the green segment
r_max = A_SPIRAL * np.exp(B_SPIRAL * theta_max)
two_pi_r = 2 * np.pi * r_max
kappa_at_2piR = two_pi_r / PHI
# Define the 52 Mersenne prime exponents (updated with the latest known as of 2025)
mersenne_exponents = [
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
    3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
    110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
    6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
    37156667, 42643801, 43112609, 57885161, 74207281, 77232917, 82589933,
    136279841 # Latest known Mersenne prime exponent as of 2025 (52nd)
]
# Map exponents to x-positions (0 to width)
min_exponent = 2
max_exponent_at_x1 = 1_100_000_000
exponent_range_per_x = (max_exponent_at_x1 - min_exponent) / 1.0
x_positions = [(exponent - min_exponent) / exponent_range_per_x * WIDTH for exponent in mersenne_exponents] # Scale to full WIDTH
# Create the 52 curves data
curves = []
curve_lines = []
for i, (exponent, x_pos) in enumerate(zip(mersenne_exponents, x_positions)):
    scale = x_pos / chord_length if chord_length != 0 else 1.0
    x_new = x_green * scale
    y_new = y_green * scale
    x_new_shifted = x_new - x_new[0]
    curves.append((x_new_shifted, y_new, f"M{exponent}"))
    curve_lines.append(None)
# A3 divisions (297 parts on short side)
division_step = HEIGHT / 297
division_positions = np.arange(0, HEIGHT + division_step, division_step)
# Scale key for the title
scale_key_positions = division_positions[::30] # Every 30mm
scale_key_exponents = [int(min_exponent + (max_exponent_at_x1 - min_exponent) * (y / HEIGHT)) for y in scale_key_positions]
scale_key_text = "Scale (y=0 to 1): " + ", ".join([f"{y:.2f}: {exp:,}" for y, exp in zip(scale_key_positions, scale_key_exponents)])
# Flags for Mersenne primes
flag_length = 0.5
start_y = -0.1
wedge_angles = np.linspace(90, 360, len(curves))
flag_positions = []
annotation_objects = []
harmonic_frequencies = []
circle_markers = []
min_exp = min(mersenne_exponents)
max_exp = max(mersenne_exponents)
log_min = np.log(min_exp)
log_max = np.log(max_exp)
min_freq_exp = -4.459
max_freq_exp = 5.506
exponent_range = max_freq_exp - min_freq_exp
log_range = log_max - log_min
for i, (x_new, y_new, label) in enumerate(curves):
    x_end = x_new[-1]
    y_end = y_new[-1]
    x_start = x_end
    y_start = start_y
    angle = wedge_angles[i]
    flag_x = x_end
    flag_y = start_y - flag_length * (i % 2 + 1) / 2
    flag_positions.append((flag_x, flag_y))
    annotation_objects.append(None)
    # Harmonic frequency mapping
    exp = mersenne_exponents[i]
    log_exp = np.log(exp)
    normalized_log = (log_exp - log_min) / log_range if log_range != 0 else 0
    freq_exp = min_freq_exp + normalized_log * exponent_range
    frequency = np.exp(freq_exp)
    harmonic_frequencies.append(frequency)
    circle_markers.append(None)
# Multi-window setup
# Window 1: 2D Plotter
fig_2d = plt.figure(figsize=(12, 8), num="2D Plotter")
ax_2d = fig_2d.add_subplot(111)
# Window 2: 3D Polyhedron Model
fig_3d = plt.figure(figsize=(10, 6), num="3D Polyhedron Model")
ax_3d = fig_3d.add_subplot(111, projection='3d')
# Window 3: Controls
fig_controls = plt.figure(figsize=(4, 6), num="Controls")
ax_scale = fig_controls.add_axes([0.2, 0.8, 0.6, 0.03])
scale_slider = Slider(ax_scale, 'Scale', 0.5, 2.0, valinit=1.0)
ax_kappa = fig_controls.add_axes([0.2, 0.7, 0.6, 0.03])
kappa_slider = Slider(ax_kappa, 'Kappa', 0.1, 2.0, valinit=kappa)
ax_decay = fig_controls.add_axes([0.2, 0.6, 0.6, 0.03])
decay_slider = Slider(ax_decay, 'Decay', 0.1, 1.0, valinit=0.5)
ax_meta = fig_controls.add_axes([0.2, 0.5, 0.6, 0.03])
meta_textbox = TextBox(ax_meta, 'Meta Value', initial="1")
ax_grid_density = fig_controls.add_axes([0.2, 0.4, 0.6, 0.03])
grid_density_slider = Slider(ax_grid_density, 'Grid Density', 50, 200, valinit=110, valstep=1)
# Add Render Model button
ax_render = fig_controls.add_axes([0.2, 0.3, 0.6, 0.05])
render_button = Button(ax_render, 'Render Model')
# Plot setup for 2D Plotter
max_dimension = max(WIDTH, HEIGHT + 1.5)
padding = 0.5
ax_2d.set_xlim(-padding, max_dimension + padding)
ax_2d.set_ylim(-padding, max_dimension + padding)
# A3 page
ax_2d.plot([0, WIDTH, WIDTH, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k-', label='A3 Page')
ax_2d.plot([0, 1.0, 1.0, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 1')
ax_2d.plot([1.0, 2.0, 2.0, 1.0, 1.0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 2')
for x in PURPLE_LINES:
    ax_2d.plot([x, x], [0, HEIGHT], 'm-', label='Projection Space Dividers' if x == PURPLE_LINES[0] else "")
ax_2d.plot([0, WIDTH], [0, 0], 'r-')
# Function to generate a kappa curve between two points
def generate_kappa_curve(x1, y1, x2, y2, kappa_val, ds=0.02):
    # Compute chord length and initial/final directions
    chord = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    if chord == 0:
        return [x1], [y1]
    # Initial direction (assume tangent at start is along the chord)
    theta0 = np.arctan2(y2 - y1, x2 - x1)
    # Arc length (approximate as chord length for simplicity)
    s_total = chord
    s = np.arange(0, s_total + ds, ds)
    # Constant kappa scaled by chord length
    kappa_s = kappa_val / chord
    # Integrate curvature to get tangent angle
    theta = theta0 + kappa_s * s
    # Integrate to get x, y coordinates
    x = np.zeros_like(s)
    y = np.zeros_like(s)
    x[0], y[0] = x1, y1
    for i in range(1, len(s)):
        x[i] = x[i-1] + ds * np.cos(theta[i-1])
        y[i] = y[i-1] + ds * np.sin(theta[i-1])
    # Scale and shift to match endpoint
    x_end, y_end = x[-1], y[-1]
    scale_x = (x2 - x1) / (x_end - x1) if (x_end - x1) != 0 else 1
    scale_y = (y2 - y1) / (y_end - y1) if (y_end - y1) != 0 else 1
    scale = min(scale_x, scale_y)
    x = x1 + (x - x1) * scale
    y = y1 + (y - y1) * scale
    return x, y
# Single continuous green kappa curve
def compute_green_kappa_curve(T=1.0, kappa_val=kappa):
    nodes = [
        (1/3, 0),
        (1/3 + 1/9, 0.1 * T),
        (1/3 + 2/9, 0.1 * T),
        (2/3, 0)
    ]
    x_all, y_all = [], []
    chord_lengths = []
    x_all.append(nodes[0][0])
    y_all.append(nodes[0][1])
    for i in range(len(nodes) - 1):
        x1, y1 = nodes[i]
        x2, y2 = nodes[i+1]
        chord = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        chord_lengths.append(chord)
        x_seg, y_seg = generate_kappa_curve(x1, y1, x2, y2, kappa_val)
        x_all.extend(x_seg[1:])
        y_all.extend(y_seg[1:])
    return np.array(x_all), np.array(y_all), chord_lengths
# Initial green kappa curve
T = 1.0
x_green, y_green, chord_lengths = compute_green_kappa_curve(T)
green_spiral, = ax_2d.plot(x_green, y_green, 'g-', label='Green Kappa Curve')
green_nodes = [ax_2d.plot([node[0]], [node[1]], 'go', markersize=6)[0] for node in [(1/3, 0), (1/3 + 1/9, 0.1), (1/3 + 2/9, 0.1), (2/3, 0)]]
# Protractor elements
protractor_line, = ax_2d.plot([], [], 'c-', label='Protractor Line')
protractor_arc, = ax_2d.plot([], [], 'c--', label='Protractor Arc')
protractor_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
protractor_spiral_2, = ax_2d.plot([], [], 'm-', label='Protractor Spiral 2')
ghost_curves = [ax_2d.plot([], [], 'b--', alpha=0.5)[0] for _ in range(4)]
# Cursor elements
cursor, = ax_2d.plot([], [], 'rx', markersize=10, label='Cursor')
cursor_text = ax_2d.text(0, 0, '', ha='left', va='bottom', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
# Ruler elements
ruler_line, = ax_2d.plot([], [], 'y-', label='Ruler Line')
ruler_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
# Toggle flags
show_protractor = False
show_ruler = False
show_harmonics = False
show_draw = False
show_dimension = False
show_pro_mode = False
# Drawing elements
kappa_nodes = []
kappa_curves = []
ghost_handles = []
selected_node = None
drag_start = None
# Grid lines (toggleable and programmable)
grid_lines = []
show_grid = True
def update_grid(density):
    global grid_lines
    for line in grid_lines:
        line.remove()
    grid_lines = []
    step_x = WIDTH / density
    step_y = HEIGHT / density
    for i in range(density + 1):
        x = i * step_x
        y = i * step_y
        vline, = ax_2d.plot([x, x], [0, HEIGHT], 'k--', alpha=0.3)
        hline, = ax_2d.plot([0, WIDTH], [y, y], 'k--', alpha=0.3)
        grid_lines.extend([vline, hline])
    fig_2d.canvas.draw()
# Initial grid
update_grid(110)
# Toggle grid with 'g'
def toggle_grid(event):
    global show_grid
    if event.key == 'g':
        show_grid = not show_grid
        for line in grid_lines:
            line.set_visible(show_grid)
        fig_2d.canvas.draw()
# Connect toggle grid
fig_2d.canvas.mpl_connect('key_press_event', toggle_grid)
# Update grid with slider
def on_grid_density_change(val):
    update_grid(int(val))
grid_density_slider.on_changed(on_grid_density_change)
# Move legend outside viewport
handles, labels = ax_2d.get_legend_handles_labels()
fig_2d.legend(handles, labels, loc='upper left', bbox_to_anchor=(1.05, 1), borderaxespad=0.)
# Maximize windows
fig_2d.canvas.manager.window.showMaximized()
fig_3d.canvas.manager.window.showMaximized()
fig_controls.canvas.manager.window.showMaximized()
# Add Navigation Toolbar (assuming Tk backend; may need adjustment for other backends)
from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
toolbar_2d = NavigationToolbar2Tk(fig_2d.canvas, fig_2d.canvas.manager.window)
toolbar_3d = NavigationToolbar2Tk(fig_3d.canvas, fig_3d.canvas.manager.window)
# Render button callback (assuming update_3d_model exists; replace with actual function if different)
def on_render_button(event):
    update_3d_model()  # Call your 3D rendering function here; e.g., display_pod_surface() or equivalent
render_button.on_clicked(on_render_button)
# ... (The rest of the original code remains unchanged, including event connections, plot properties, and plt.show())
# Pick event for Mersenne primes
def on_pick_mersenne(event):
    if isinstance(event.artist, plt.Line2D):
        thisline = event.artist
        ind = event.ind
        if ind is not None and len(ind) > 0:
            i = ind[0]
            exponent = mersenne_exponents[i]
            print(f"Selected Mersenne prime: 2^{exponent} - 1")
            for j, line in enumerate(curve_lines):
                if line is not None:
                    line.set_linewidth(1.0 if j != i else 3.0)
            fig_2d.canvas.draw()
# Click to deselect
def on_click_deselect(event):
    if event.button == 3:  # Right click
        for line in curve_lines:
            if line is not None:
                line.set_linewidth(1.0)
        fig_2d.canvas.draw()
# Toggle protractor
def toggle_protractor(event):
    global show_protractor
    if event.key == 'p':
        show_protractor = not show_protractor
        protractor_line.set_visible(show_protractor)
        protractor_arc.set_visible(show_protractor)
        protractor_text.set_visible(show_protractor)
        protractor_spiral_2.set_visible(show_protractor)
        for ghost in ghost_curves:
            ghost.set_visible(show_protractor)
        print(f"Protractor {'shown' if show_protractor else 'hidden'}")
        fig_2d.canvas.draw()
# Toggle ruler
def toggle_ruler(event):
    global show_ruler
    if event.key == 'r':
        show_ruler = not show_ruler
        ruler_line.set_visible(show_ruler)
        ruler_text.set_visible(show_ruler)
        print(f"Ruler {'shown' if show_ruler else 'hidden'}")
        fig_2d.canvas.draw()
# Click for ruler start
def on_click_ruler(event):
    if show_ruler and event.inaxes == ax_2d and event.button == 1:
        global ruler_start
        ruler_start = (event.xdata, event.ydata)
# Motion for protractor and cursor
def on_motion_protractor(event):
    if event.inaxes != ax_2d:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    # Update cursor
    cursor.set_data([x], [y])
    # Update protractor if shown
    if show_protractor:
        anchor_x, anchor_y = 0.0, 0.0
        protractor_line.set_data([anchor_x, x], [anchor_y, y])
        dx = x - anchor_x
        dy = y - anchor_y
        angle = np.arctan2(dy, dx) * 180 / np.pi
        mid_x = (anchor_x + x) / 2
        mid_y = (anchor_y + y) / 2
        radius_arc = np.sqrt(dx**2 + dy**2) / 4
        start_angle = 0
        end_angle = angle
        num_points = 100
        theta_arc = np.linspace(np.deg2rad(start_angle), np.deg2rad(end_angle), num_points)
        x_arc = mid_x + radius_arc * np.cos(theta_arc)
        y_arc = mid_y + radius_arc * np.sin(theta_arc)
        protractor_arc.set_data(x_arc, y_arc)
        offsets = [-10, -5, 5, 10]
        for i, offset in enumerate(offsets):
            angle_offset = angle + offset
            x_ghost, y_ghost = compute_curve_points(np.pi, 2 * np.pi, num_points // 2, 1.0, angle_offset)
            ghost_curves[i].set_data(anchor_x + x_ghost, anchor_y + y_ghost)
        line_vec = np.array([x - anchor_x, y - anchor_y])
        line_len = np.sqrt(dx**2 + dy**2)
        if line_len == 0:
            line_len = 1e-10
        normal_vec = np.array([-(y - anchor_y), x - anchor_x]) / line_len
        x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
        x_mirrored = []
        y_mirrored = []
        for xs, ys in zip(x_spiral, y_spiral):
            point = np.array([xs, ys])
            v = point - np.array([anchor_x, anchor_y])
            projection = np.dot(v, normal_vec) * normal_vec
            mirrored_point = point - 2 * projection
            x_mirrored.append(mirrored_point[0])
            y_mirrored.append(mirrored_point[1])
        protractor_spiral_2.set_data(x + x_mirrored, y + y_mirrored)
        protractor_text.set_position((mid_x, mid_y))
        protractor_text.set_text(f'Angle: {angle:.2f}°\nκ at 2πR: {kappa_at_2piR:.4f}')
    # Update ruler if shown
    if show_ruler and 'ruler_start' in globals():
        ruler_line.set_data([ruler_start[0], x], [ruler_start[1], y])
        dist = np.sqrt((x - ruler_start[0])**2 + (y - ruler_start[1])**2)
        mid_x_r = (ruler_start[0] + x) / 2
        mid_y_r = (ruler_start[1] + y) / 2
        ruler_text.set_position((mid_x_r, mid_y_r))
        ruler_text.set_text(f'Dist: {dist:.4f}')
    # Update cursor text
    height_factor = y / HEIGHT if HEIGHT != 0 else 0
    baseline_spiral_1 = compute_curve_points(0, np.pi, 100, height_factor)
    x_base_spiral_1, y_base_spiral_1 = baseline_spiral_1
    baseline_chord = np.sqrt((x_base_spiral_1[-1] - x_base_spiral_1[0])**2 + (y_base_spiral_1[-1] - y_base_spiral_1[0])**2)
    baseline_spiral_2 = compute_curve_points(np.pi, 2 * np.pi, 100, height_factor)
    x_base_spiral_2, y_base_spiral_2 = baseline_spiral_2
    baseline_chord_2 = np.sqrt((x_base_spiral_2[-1] - x_base_spiral_2[0])**2 + (y_base_spiral_2[-1] - y_base_spiral_2[0])**2)
    x_start_green = x_green_final[0]
    y_start_green = y_green_scaled[0]
    chord_to_green = np.sqrt((x - x_start_green)**2 + (y - y_start_green)**2)
    text_str = (f'κ: {scale_factor:.4f}\n'
                f'Height Factor: {height_factor:.4f}\n'
                f'Cursor: ({x:.4f}, {y:.4f})\n'
                f'Chord to Green: {chord_to_green:.4f}\n'
                f'Baseline Chord (x=0): {baseline_chord:.4f}\n'
                f'Baseline Chord (x=1): {baseline_chord_2:.4f}')
    cursor_text.set_text(text_str)
    cursor_text.set_position((x + 0.05, y + 0.05))
    fig_2d.canvas.draw_idle()
# Toggle harmonics
def toggle_harmonics(event):
    global show_harmonics
    if event.key == 'h':
        show_harmonics = not show_harmonics
        for text in harmonic_texts:
            text.set_visible(show_harmonics)
        print(f"Harmonic frequencies {'shown' if show_harmonics else 'hidden'}")
        fig_2d.canvas.draw()
# Save plot
def save_plot(event):
    if event.key == 'w':
        plt.savefig("nu_curve.png", dpi=300, bbox_inches='tight')
        print("Plot saved as nu_curve.png")
        if MPLD3_AVAILABLE:
            mpld3.save_html(fig_2d, "nu_curve.html")
            print("Interactive plot saved as nu_curve.html")
        else:
            print("Skipping HTML export because mpld3 is not installed.")
# Connect events
fig_2d.canvas.mpl_connect('pick_event', on_pick_mersenne)
fig_2d.canvas.mpl_connect('button_press_event', on_click_deselect)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_harmonics)
fig_2d.canvas.mpl_connect('key_press_event', save_plot)
fig_2d.canvas.mpl_connect('key_press_event', toggle_draw)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('key_press_event', toggle_dimension)
fig_2d.canvas.mpl_connect('key_press_event', to_construction)
fig_2d.canvas.mpl_connect('key_press_event', hide_show)
fig_2d.canvas.mpl_connect('key_press_event', reset_canvas)
fig_2d.canvas.mpl_connect('key_press_event', save_stl)
fig_2d.canvas.mpl_connect('button_press_event', on_click_protractor)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_dimension)
fig_2d.canvas.mpl_connect('button_press_event', on_click_draw)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion)
fig_2d.canvas.mpl_connect('key_press_event', auto_close)
fig_2d.canvas.mpl_connect('key_press_event', toggle_pro_mode)
fig_2d.canvas.mpl_connect('pick_event', on_pick)
fig_2d.canvas.mpl_connect('button_press_event', on_button_press)
fig_2d.canvas.mpl_connect('button_release_event', on_button_release)
# Plot properties
ax_2d.set_xlim(-0.1, WIDTH + 0.1)
ax_2d.set_ylim(-1.5, HEIGHT + 0.1)
ax_2d.set_xlabel('x (Exponents: 2 to 11B)')
ax_2d.set_ylabel('y')
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
ax_2d.grid(True)
ax_2d.set_aspect('equal')
# Display default pod surface and draw default pod
def display_pod_surface():
    # Implement pod surface generation using NURKS or similar
    vertices, faces, face_colors, control_x, control_y, control_z, res = compute_nurks_surface()
    mesh = Poly3DCollection([vertices[face] for face in faces], facecolors=face_colors, edgecolors='k', alpha=0.8)
    ax_3d.add_collection3d(mesh)
    ax_3d.scatter(control_x, control_y, control_z, c='r', s=20)
    ax_3d.set_xlim([-2, 2])
    ax_3d.set_ylim([-2, 2])
    ax_3d.set_zlim([-2, 2])
    fig_3d.canvas.draw()
def draw_default_pod(ax):
    # Draw a default pod shape in 2D
    theta = np.linspace(0, 2*np.pi, 100)
    r = 0.5 + 0.2 * np.sin(6 * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta) + 0.5
    ax.plot(x, y, 'b-', label='Default Pod')
    fig_2d.canvas.draw()
display_pod_surface()
draw_default_pod(ax_2d)
# Update green kappa curve with sliders
def update_green_kappa_curve(val):
    global T, x_green, y_green, chord_lengths
    kappa_val = kappa_slider.val
    decay = decay_slider.val
    x_green_new, y_green_new, chord_lengths_new = compute_green_kappa_curve(T, kappa_val)
    for i in range(len(chord_lengths)):
        chord_lengths[i] = chord_lengths[i] * (1 - decay) + chord_lengths_new[i] * decay
    green_spiral.set_data(x_green_new, y_green_new)
    x_green, y_green, chord_lengths = x_green_new, y_green_new, chord_lengths_new
    nodes = [(1/3, 0), (1/3 + 1/9, 0.1 * T), (1/3 + 2/9, 0.1 * T), (2/3, 0)]
    for i, node in enumerate(nodes):
        green_nodes[i].set_data([node[0]], [node[1]])
    fig_2d.canvas.draw()
kappa_slider.on_changed(update_green_kappa_curve)
decay_slider.on_changed(update_green_kappa_curve)
# Define compute_curve_points (placeholder; implement as needed)
def compute_curve_points(start_theta, end_theta, num_points, scale, angle_offset=0):
    theta = np.linspace(start_theta, end_theta, num_points) + np.deg2rad(angle_offset)
    r = A_SPIRAL * np.exp(B_SPIRAL * theta) * scale
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    return x, y
# Toggle draw mode
def toggle_draw(event):
    global show_draw
    if event.key == 'd':
        show_draw = not show_draw
        print(f"Draw mode {'enabled' if show_draw else 'disabled'}")
# Click for draw
def on_click_draw(event):
    if show_draw and event.inaxes == ax_2d and event.button == 1:
        x, y = event.xdata, event.ydata
        kappa_nodes.append((x, y))
        ax_2d.plot(x, y, 'ro')
        if len(kappa_nodes) > 1:
            x1, y1 = kappa_nodes[-2]
            x2, y2 = kappa_nodes[-1]
            x_curve, y_curve = generate_kappa_curve(x1, y1, x2, y2, kappa_slider.val)
            curve, = ax_2d.plot(x_curve, y_curve, 'g-')
            kappa_curves.append(curve)
        fig_2d.canvas.draw()
# Toggle dimension
def toggle_dimension(event):
    global show_dimension
    if event.key == 'm':
        show_dimension = not show_dimension
        print(f"Dimension mode {'enabled' if show_dimension else 'disabled'}")
# Click for dimension
def on_click_dimension(event):
    if show_dimension and event.inaxes == ax_2d and event.button == 1:
        # Placeholder for adding dimension labels
        pass
# To construction
def to_construction(event):
    if event.key == 'c':
        # Placeholder for converting to construction geometry
        pass
# Hide show
def hide_show(event):
    if event.key == 'h':
        # Placeholder for hide/show elements
        pass
# Reset canvas
def reset_canvas(event):
    if event.key == 'r':
        # Placeholder for resetting canvas
        pass
# Save STL
def save_stl(event):
    if event.key == 's':
        # Placeholder for saving STL
        pass
# Click protractor
def on_click_protractor(event):
    if show_protractor and event.inaxes == ax_2d and event.button == 1:
        # Placeholder for protractor interaction
        pass
# Motion general
def on_motion(event):
    # Placeholder for general motion events
    pass
# Auto close
def auto_close(event):
    if event.key == 'a':
        # Placeholder for auto closing curves
        pass
# Toggle pro mode
def toggle_pro_mode(event):
    global show_pro_mode
    if event.key == 'p':
        show_pro_mode = not show_pro_mode
        print(f"Pro mode {'enabled' if show_pro_mode else 'disabled'}")
# Pick general
def on_pick(event):
    # Placeholder for general pick events
    pass
# Button press
def on_button_press(event):
    # Placeholder for button press
    pass
# Button release
def on_button_release(event):
    # Placeholder for button release
    pass
# Update 3D model (placeholder; implement as needed)
def update_3d_model():
    ax_3d.cla()
    display_pod_surface()
    fig_3d.canvas.draw()
# Run the application
plt.show()

----- END tetra -----

----- tetra.py -----
# Copyright 2025 Todd Hutchinson, Anonymous
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import cm
from matplotlib.widgets import Slider
import hashlib
from decimal import Decimal, getcontext
import warnings
from matplotlib import MatplotlibDeprecationWarning
import struct
import base64
# Import mpld3 if available for HTML export
try:
    import mpld3
    MPLD3_AVAILABLE = True
except ImportError:
    print("mpld3 not installed. HTML export will be skipped. Install mpld3 with 'pip install mpld3' to enable.")
    MPLD3_AVAILABLE = False
from temperature_salt import secure_hash_two
from kappawise import kappa_coord
from nurks_surface import bspline_basis, bspline_basis_periodic, custom_interoperations_green_curve
# Set precision for Decimal
getcontext().prec = 28
# Suppress warnings
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)
# A3 landscape dimensions (normalized: width long side, height short side)
WIDTH = 420 / 297 # A3 landscape: 420mm width, 297mm height, normalized height=1.0
HEIGHT = 1.0
PURPLE_LINES = [1/3, 2/3] # Dividers on the width
unit_per_mm = 1.0 / 297 # Normalize to A3 short side
scale_label = f"Scale: 1mm = {unit_per_mm:.5f} units (A3 short side = 297mm)"
# Dreyfuss human factors: Optimal eye distance ~20 inches (508mm)
EYE_DISTANCE = 500 * unit_per_mm # Normalized eye distance to viewport
HORIZON_HEIGHT = HEIGHT * 0.5 # Default horizon line at half height
EYE_LINE = HORIZON_HEIGHT # Eye line coincides with horizon
# Golden spiral parameters
PHI = (1 + np.sqrt(5)) / 2
kappa = 1 / PHI
A_SPIRAL = 0.001 # Scaled down slightly from 0.01 to fit better
B_SPIRAL = np.log(PHI) / (np.pi / 2)
# Define κθπ for the green segment
theta_max = kappa * np.pi**2 / PHI
# Compute the full spiral
theta_full = np.linspace(0, 10 * np.pi, 1000)
r_full = A_SPIRAL * np.exp(B_SPIRAL * theta_full)
x_full = r_full * np.cos(theta_full)
y_full = r_full * np.sin(theta_full)
# Compute the green segment (θ from π to 2π)
theta_green = np.linspace(np.pi, 2 * np.pi, 200)
r_green = A_SPIRAL * np.exp(B_SPIRAL * theta_green)
x_green = r_green * np.cos(theta_green)
y_green = r_green * np.sin(theta_green)
# Compute the chord and shift
x1, y1 = x_green[0], y_green[0]
x2, y2 = x_green[-1], y_green[-1]
chord_length = np.abs(x2 - x1)
# Shift so the segment starts at x=0
x_green_shifted = x_green - x1
x_green_final = x_green_shifted
# Scale to match the target chord length (between purple lines)
target_chord = PURPLE_LINES[1] - PURPLE_LINES[0]
scale_factor = target_chord / chord_length if chord_length != 0 else 1.0
x_green_scaled = x_green_final * scale_factor
y_green_scaled = y_green * scale_factor
# Shift to start at the first purple line
x_green_final = x_green_scaled + PURPLE_LINES[0]
# Compute κ at 2πR for the green segment
r_max = A_SPIRAL * np.exp(B_SPIRAL * theta_max)
two_pi_r = 2 * np.pi * r_max
kappa_at_2piR = two_pi_r / PHI
# Define the 52 Mersenne prime exponents (updated with the latest known as of 2025)
mersenne_exponents = [
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
    3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
    110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
    6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
    37156667, 42643801, 43112609, 57885161, 74207281, 77232917, 82589933,
    136279841 # Latest known Mersenne prime exponent as of 2025 (52nd)
]
# Map exponents to x-positions (0 to width)
min_exponent = 2
max_exponent_at_x1 = 1_100_000_000
exponent_range_per_x = (max_exponent_at_x1 - min_exponent) / 1.0
x_positions = [(exponent - min_exponent) / exponent_range_per_x * WIDTH for exponent in mersenne_exponents] # Scale to full WIDTH
# Create the 52 curves data
curves = []
curve_lines = []
colors = plt.cm.viridis(np.linspace(0, 1, len(mersenne_exponents)))
for i, (exponent, x_pos) in enumerate(zip(mersenne_exponents, x_positions)):
    scale = x_pos / chord_length if chord_length != 0 else 1.0
    x_new = x_green * scale
    y_new = y_green * scale
    x_new_shifted = x_new - x_new[0]
    curves.append((x_new_shifted, y_new, f"M{exponent}"))
    curve_lines.append(None)
# A4 short edge divisions (110 parts, scaled to first part of WIDTH)
division_step = WIDTH / 2 / 110 # Assume first half is A4-like
division_positions = np.arange(0, WIDTH / 2 + division_step, division_step)
# Scale key for the title
scale_key_positions = division_positions[::10] / (WIDTH / 2) # Normalize to 0-1 for first half
scale_key_exponents = [int(2 + (1_100_000_000 - 2) * x) for x in scale_key_positions]
scale_key_text = "Scale (x=0 to WIDTH/2): " + ", ".join([f"{x:.2f}: {exp:,}" for x, exp in zip(scale_key_positions, scale_key_exponents)])
# Flags for Mersenne primes
flag_length = 0.5
start_y = -0.1
wedge_angles = np.linspace(90, 360, len(curves))
flag_positions = []
annotation_objects = []
harmonic_frequencies = []
circle_markers = []
min_exp = min(mersenne_exponents)
max_exp = max(mersenne_exponents)
log_min = np.log(min_exp)
log_max = np.log(max_exp)
min_freq_exp = -4.459
max_freq_exp = 5.506
exponent_range = max_freq_exp - min_freq_exp
log_range = log_max - log_min
for i, (x_new, y_new, label) in enumerate(curves):
    x_end = x_new[-1]
    y_end = y_new[-1]
    x_start = x_end
    y_start = start_y
    angle = np.deg2rad(wedge_angles[i])
    x_flag = x_start + flag_length * np.cos(angle)
    y_flag = y_start + flag_length * np.sin(angle)
    exponent = mersenne_exponents[i]
    scaled_exponent = min_freq_exp + (np.log(exponent) - log_min) / log_range * exponent_range
    freq = 440 * 2**scaled_exponent
    harmonic_frequencies.append(freq)
    flag_positions.append((x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq))
    angle_deg = wedge_angles[i]
    if (angle_deg - 90) % 5 == 0:
        angle_rad = np.deg2rad(angle_deg)
        x_marker = x_start + (flag_length * 0.5) * np.cos(angle_rad)
        y_marker = y_start + (flag_length * 0.5) * np.sin(angle_rad)
        circle_markers.append((x_marker, y_marker))
# Global variables for interactive modes
protractor_active = False
ruler_active = False
draw_mode = False
dimension_active = False
pro_mode = False
is_closed = False
selected_curve = None
hidden_elements = []
protractor_points = []
protractor_line = None
protractor_text = None
ruler_points = []
ruler_line = None
ruler_text = None
dimension_labels = []
drawing_points = [] # Kappa nodes (first endpoint of each greenchord)
kappas = [] # Kappa values at each node
node_scatter = [] # List of scatter objects for kappa nodes
original_colors = [] # List to store original colors of nodes
selected_node_index = -1
dragging = False
ghost_handles = [] # List for theta ghost handles
green_curve_line = None # Single plot object for the interoperated greencurve
CLOSE_THRESHOLD = 0.05 # Distance to first point to consider closing
SNAP_THRESHOLD = 0.05 # Threshold for snapping to dividers (UX improvement)
vanishing_points = [] # Vanishing points for each triangulation
previous_kappa = 1.0 # Initial kappa for decay
curvature = 1.0 # Initial curvature (kappa)
height = 0.5 # Initial height for 3D model
num_rings = 20 # Number of loft rings
fractal_level = 3 # Fractal level for flowers
radial_chord = 0.5 # Radial chord for flower
tangential_chord = 0.2 # Tangential chord for flower
height_chord = 0.1 # Height chord for flower
current_vertices = None
current_faces = None
last_angle = 0.0 # Last measured angle from protractor
show_harmonics = False
harmonic_texts = []
annotation_objects = []
# Pre-compute kappa grid
kappa_grid = kappa_coord(grid_size=100)
# Fractal Flower Mesh with guide curves using diameter logic
def fractal_flower(center, scale, level, all_polygons, all_guide_curves, rotation_angle=0.0):
    """
    Recursively generates flower-shaped polygons for the surface.
    Collects all base-level flower polygons in all_polygons (list of list of [x,y,z]).
    Uses 36 points for better flower resolution with curved petals.
    Applies rotation to the points.
    Adds guide curves from petal to petal control points using diameter logic (connecting opposite petals).
    Args:
        center: [x, y, z] center of the flower.
        scale: Scale factor for the flower size.
        level: Current recursion depth.
        all_polygons: List to collect all base flower polygons.
        all_guide_curves: List to collect guide curves (list of [p1, p2] pairs for lines).
        rotation_angle: Rotation angle in radians for the flower.
    """
    rot_cos = np.cos(rotation_angle)
    rot_sin = np.sin(rotation_angle)
    num_points = 37 # 36 points for higher resolution
    t = np.linspace(0, 2 * np.pi, num_points)[:-1]
    r = scale * (radial_chord + tangential_chord * np.sin(6 * t)) # 6 petals, use sin for symmetry if needed
    dx = r * np.cos(t)
    dy = r * np.sin(t)
    dz = scale * height_chord * np.cos(6 * t) # Curved z for surface
    # Apply rotation to dx, dy (around z)
    x_rot = center[0] + dx * rot_cos - dy * rot_sin
    y_rot = center[1] + dx * rot_sin + dy * rot_cos
    z_rot = center[2] + dz
    polygon = [[x_rot[j], y_rot[j], z_rot[j]] for j in range(len(t))]
    all_polygons.append(polygon)
    # Add guide curves using diameter logic (connect opposite points for each petal pair)
    num_petals = 6
    points_per_petal = len(t) // num_petals
    for p in range(num_petals // 2):  # Pair opposite petals (0-3, 1-4, 2-5)
        petal1_start = p * points_per_petal
        petal2_start = (p + num_petals // 2) * points_per_petal
        # Take midpoint control points of each petal
        petal1_mid = petal1_start + points_per_petal // 2
        petal2_mid = petal2_start + points_per_petal // 2
        p1 = polygon[petal1_mid]
        p2 = polygon[petal2_mid]
        all_guide_curves.append([p1, p2])  # Add line between control points
    if level == 0:
        return
    # Add smaller flowers at petal tips
    small_scale = scale / PHI # Golden ratio scale
    for i in range(6):
        theta = i * (2 * np.pi / 6)
        tip_r = scale * (radial_chord + tangential_chord) # Max r for tip
        tip_dx = tip_r * np.cos(theta)
        tip_dy = tip_r * np.sin(theta)
        tip_dz = scale * height_chord
        # Rotate tip offset
        tip_x = center[0] + tip_dx * rot_cos - tip_dy * rot_sin
        tip_y = center[1] + tip_dx * rot_sin + tip_dy * rot_cos
        tip_z = center[2] + tip_dz
        tip_center = [tip_x, tip_y, tip_z]
        fractal_flower(tip_center, small_scale, level - 1, all_polygons, all_guide_curves, rotation_angle + np.pi)
# Triangulate polygon for rendering (fan triangulation)
def triangulate_poly(poly):
    tris = []
    for i in range(1, len(poly) - 1):
        tris.append([poly[0], poly[i], poly[i+1]])
    return tris
# Hash entropy for lower surface
def hash_entropy(p):
    h_str = f"{p[0]:.6f}{p[1]:.6f}{p[2]:.6f}"
    h = int(hashlib.sha256(h_str.encode()).hexdigest(), 16) % 1000 / 1000.0 * 0.05 - 0.025
    return h
# Build mesh using fractal flower (ties to curve by scaling to curve length)
def build_mesh(x_curve, y_curve, z_curve=None, height=0.5, num_rings=20, num_points=None, fractal_level=3):
    """
    Builds two surfaces meeting at the 3D curve with vertical tangent, inheriting each other's curvature in transition.
    Integrates fractal flower for complex surface detail on caps, scaled by curve length.
    Uses flower modulation in loft rings for interlacing petals.
    Now collects guide curves from petal to petal and adds them as edges in the mesh.
    Args:
        x_curve, y_curve, z_curve: Curve coordinates.
        height: Height for lofting.
        num_rings: Number of rings for loft.
        num_points: Number of points to sample curve.
        fractal_level: Recursion level for fractal flower.
    Returns:
        vertices (np.array): Array of [x, y, z].
        faces (list): List of [idx1, idx2, idx3].
    """
    if num_points is not None:
        indices = np.linspace(0, len(x_curve) - 1, num_points, dtype=int)
        x_curve = x_curve[indices]
        y_curve = y_curve[indices]
        if z_curve is not None:
            z_curve = z_curve[indices]
    n = len(x_curve)
    if z_curve is None:
        z_curve = np.zeros(n) # Default to flat if no z provided
    # Use node 2 as datum when closed
    center_x = drawing_points[1][0] if is_closed and len(drawing_points) > 1 else drawing_points[0][0] if drawing_points else np.mean(x_curve)
    center_y = drawing_points[1][1] if is_closed and len(drawing_points) > 1 else drawing_points[0][1] if drawing_points else np.mean(y_curve)
    vertices = []
    faces = []
    # Parting line on 3D curve
    parting_base = len(vertices)
    for i in range(n):
        vertices.append([x_curve[i], y_curve[i], z_curve[i]])
    # Upper surface: rings inward with vertical tangent at edge and flower modulation
    upper_bases = [parting_base]
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2 # Vertical tangent at s=0 (dr/ds=0)
        g_val = (height / 2) * s**2 # Quadratic for constant curvature
        base = len(vertices)
        upper_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = 0.0 # Upper phase
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s # Modulation increases inward
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) + g_val + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_upper_idx = len(vertices)
    vertices.append([center_x, center_y, height / 2])
    # Lower surface: mirrored with phase offset for interlacing and entropy
    lower_bases = [parting_base] # Shared edge
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2
        g_val = (height / 2) * s**2 # Quadratic for constant curvature (sign same for inheritance magnitude)
        base = len(vertices)
        lower_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = np.pi / 6 # Lower phase offset for interlacing
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) - g_val + hash_entropy([x, y, z]) + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_lower_idx = len(vertices)
    vertices.append([center_x, center_y, -height / 2])
    # Faces for upper surface
    for ll in range(len(upper_bases) - 1):
        base = upper_bases[ll]
        next_base = upper_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, base + next_i, next_base + next_i])
            faces.append([base + i, next_base + next_i, next_base + i])
    # Faces for lower surface
    for ll in range(len(lower_bases) - 1):
        base = lower_bases[ll]
        next_base = lower_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, next_base + i, next_base + next_i])
            faces.append([base + i, next_base + next_i, base + next_i])
    # Integrate fractal flower for caps (no fan, use flower fractals)
    # Compute curve length for scale
    curve_length = np.sum(np.sqrt(np.diff(x_curve)**2 + np.diff(y_curve)**2))
    flower_scale = curve_length * 0.1 if curve_length > 0 else 0.5 # Scale to curve
    all_polygons = [] # List of list of [x,y,z] for each polygon
    all_guide_curves = []  # New: Collect guide curve pairs
    # Upper cap flower
    fractal_flower(vertices[center_upper_idx], flower_scale, fractal_level, all_polygons, all_guide_curves, rotation_angle=np.pi)
    # Lower cap flower
    fractal_flower(vertices[center_lower_idx], flower_scale, fractal_level, all_polygons, all_guide_curves, rotation_angle=np.pi)
    # Add polygons to mesh (triangulate for rendering)
    for poly in all_polygons:
        base_idx = len(vertices)
        vertices.extend(poly)
        for tri in triangulate_poly(range(len(poly))):
            faces.append([base_idx + tri[0], base_idx + tri[1], base_idx + tri[2]])
    # Add guide curves as edges (simple lines, add as degenerate faces or separate for visualization)
    for guide in all_guide_curves:
        base_idx = len(vertices)
        vertices.append(guide[0])
        vertices.append(guide[1])
        faces.append([base_idx, base_idx + 1, base_idx + 1])  # Degenerate tri for line (visual only)
    # Convert to numpy array
    vertices = np.array(vertices)
    # Snap to integers if hash ends with 0
    for i in range(len(vertices)):
        v = vertices[i]
        h_str = f"{v[0]:.6f}{v[1]:.6f}{v[2]:.4f}"
        h = hashlib.sha256(h_str.encode()).hexdigest()[-1]
        if h == '0':
            vertices[i] = np.round(vertices[i])
    # Add compound curvature modulation with angle and 3D kappa grid for smooth orthographic projections
    grid_size, _, num_angles = kappa_grid.shape
    angle_idx = int((last_angle / 360) * num_angles) % num_angles
    kappa_slice = kappa_grid[:, :, angle_idx]
    # Normalize vertices to -1 to 1 for grid mapping (assuming curve bounds approx [0, WIDTH] x [0, HEIGHT])
    max_dim = max(np.max(np.abs(vertices[:, 0])), np.max(np.abs(vertices[:, 1])))
    norm_x = np.clip(((vertices[:, 0] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    norm_y = np.clip(((vertices[:, 1] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    kappa_mod = kappa_slice[norm_y, norm_x]
    vertices[:, 2] += kappa_mod * 0.1 # Scale z modulation
    vertices[:, 0] += kappa_mod * 0.05 * np.sin(2 * np.pi * vertices[:, 2] / height) # Compound in x
    vertices[:, 1] += kappa_mod * 0.05 * np.cos(2 * np.pi * vertices[:, 2] / height) # Compound in y
    # Make flowers sacrificial: remove flower faces after modulation (assume last added are flowers)
    flower_face_start = len(faces) - len(all_polygons) * 35 # Adjusted for 36 points per flower (approx 35 triangles)
    faces = faces[:flower_face_start]
    return vertices, faces
# NURBS basis function
def nurbs_basis(u, i, p, knots):
    if p == 0:
        return 1.0 if knots[i] <= u <= knots[i+1] else 0.0 # Include = for end
    if knots[i+p] == knots[i]:
        c1 = 0.0
    else:
        c1 = (u - knots[i]) / (knots[i+p] - knots[i]) * nurbs_basis(u, i, p-1, knots)
    if knots[i+p+1] == knots[i+1]:
        c2 = 0.0
    else:
        c2 = (knots[i+p+1] - u) / (knots[i+p+1] - knots[i+1]) * nurbs_basis(u, i+1, p-1, knots)
    return c1 + c2
# Compute NURBS curve point
def nurbs_curve_point(u, control_points, weights, p, knots):
    n = len(control_points) - 1
    x = 0.0
    y = 0.0
    denom = 0.0
    for i in range(n + 1):
        b = nurbs_basis(u, i, p, knots)
        denom += b * weights[i]
        x += b * weights[i] * control_points[i][0]
        y += b * weights[i] * control_points[i][1]
    if denom == 0:
        return 0, 0
    return x / denom, y / denom
# Generate NURBS curve
def generate_nurbs_curve(points, weights, p, knots, num_points=1000):
    u_min, u_max = knots[p], knots[-p-1]
    u_values = np.linspace(u_min, u_max, num_points, endpoint=False)
    curve = [nurbs_curve_point(u, points, weights, p, knots) for u in u_values]
    curve.append(curve[0]) # Append first point for exact closure
    return np.array([list(pt) for pt in curve]) # Convert to np.array of shape (num_points+1, 2)
# Compute golden spiral
def compute_golden_spiral():
    theta = np.linspace(0, 10 * np.pi, 1000)
    r = A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Scale down to fit within page bounds
    scale_factor = min(WIDTH, HEIGHT) / (2 * np.max(np.abs([x, y]))) * 0.8 # 80% of max to fit comfortably
    x *= scale_factor
    y *= scale_factor
    return x, y
# Compute kappa for a segment, second endpoint influences next kappa
def compute_segment_kappa(p1, p2, base_kappa=1.0, prev_kappa=1.0):
    x1, y1 = p1
    x2, y2 = p2
    theta = np.sqrt((x2 - x1)**2 + (y2 - y1)**2) # Theta is distance
    if theta < 1e-10:
        return prev_kappa
    decay_factor = np.exp(-theta / WIDTH / 20.0) # Further reduced decay rate
    return prev_kappa * decay_factor * base_kappa
# Recalculate kappas after changes (e.g., closure or node move) for consistency
def recalculate_kappas():
    global previous_kappa
    previous_kappa = kappas[0] # Start with first kappa
    for i in range(1, len(drawing_points)):
        kappas[i] = compute_segment_kappa(drawing_points[i-1], drawing_points[i], curvature, previous_kappa)
        previous_kappa = kappas[i]
# Update 3D model on changes (e.g., height slider or curve update)
def update_3d_model():
    global current_vertices, current_faces
    if green_curve_line:
        x_curve, y_curve = green_curve_line.get_data()
        if is_closed and np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)), height=height)
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
# Golden window calculation
def compute_golden_window(x_spiral, y_spiral):
    idx_crossings = np.where(np.diff(np.sign(x_spiral - PURPLE_LINES[0] * WIDTH)))[0]
    if len(idx_crossings) >= 2:
        y1 = y_spiral[idx_crossings[0]]
        y2 = y_spiral[idx_crossings[1]]
        return np.abs(y2 - y1), min(y1, y2), max(y1, y2)
    return 0, 0, 0
# Compute vanishing point for a triangulation
def compute_vanishing_point(tri_points, eye_distance=EYE_DISTANCE):
    mid_x = np.mean([p[0] for p in tri_points])
    mid_y = np.mean([p[1] for p in tri_points])
    vx = mid_x
    vy = HORIZON_HEIGHT + eye_distance * (mid_y - EYE_LINE) / WIDTH
    return vx, vy
# Redraw green curve
def redraw_green_curve(is_closed=False):
    global green_curve_line
    if green_curve_line:
        green_curve_line.remove()
        green_curve_line = None
    if len(drawing_points) >= 2:
        adjusted_kappas = kappas.copy()
        if is_closed and len(adjusted_kappas) > 1:
            adjusted_kappas[1] = 1.5 * adjusted_kappas[1] # Local kappa adjustment for ellipse conditions
        x_green, y_green = custom_interoperations_green_curve(drawing_points, adjusted_kappas, is_closed=is_closed)
        green_curve_line, = ax_2d.plot(x_green, y_green, 'g-', label='Green Curve' if green_curve_line is None else None)
    fig_2d.canvas.draw()
# Setup figures
fig_2d = plt.figure(figsize=(14, 8))
ax_2d = fig_2d.add_subplot(111)
fig_3d = plt.figure(figsize=(10, 6))
ax_3d = fig_3d.add_subplot(111, projection='3d')
fig_controls = plt.figure(figsize=(4, 8))
ax_curvature = fig_controls.add_axes([0.2, 0.8, 0.6, 0.03])
curvature_slider = Slider(ax_curvature, 'Curvature (kappa)', 0.1, 2.0, valinit=curvature)
ax_height = fig_controls.add_axes([0.2, 0.7, 0.6, 0.03])
height_slider = Slider(ax_height, 'Height', 0.1, 2.0, valinit=height)
ax_rings = fig_controls.add_axes([0.2, 0.6, 0.6, 0.03])
rings_slider = Slider(ax_rings, 'Rings', 5, 50, valinit=num_rings, valstep=1)
ax_level = fig_controls.add_axes([0.2, 0.5, 0.6, 0.03])
level_slider = Slider(ax_level, 'Fractal Level', 0, 5, valinit=fractal_level, valstep=1)
ax_radial = fig_controls.add_axes([0.2, 0.4, 0.6, 0.03])
radial_slider = Slider(ax_radial, 'Radial Chord', 0.1, 1.0, valinit=radial_chord)
ax_tangential = fig_controls.add_axes([0.2, 0.3, 0.6, 0.03])
tangential_slider = Slider(ax_tangential, 'Tangential Chord', 0.0, 0.5, valinit=tangential_chord)
ax_height_chord = fig_controls.add_axes([0.2, 0.2, 0.6, 0.03])
height_chord_slider = Slider(ax_height_chord, 'Height Chord', 0.0, 0.5, valinit=height_chord)
# Plot A3 page
ax_2d.plot([0, WIDTH, WIDTH, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k-', label='A3 Landscape Page')
for x in PURPLE_LINES:
    ax_2d.plot([x * WIDTH, x * WIDTH], [0, HEIGHT], 'm-', label='Purple Dividers' if x == PURPLE_LINES[0] else None)
# Horizon line
horizon_line, = ax_2d.plot([0, WIDTH], [HORIZON_HEIGHT, HORIZON_HEIGHT], 'b:', label='Horizon/Eye Line')
# Golden spiral
x_spiral, y_spiral = compute_golden_spiral()
golden_spiral, = ax_2d.plot(x_spiral + WIDTH/2, y_spiral + HEIGHT/2, 'gold', label='Golden Spiral')
# Golden window
golden_window, y_min, y_max = compute_golden_window(x_spiral + WIDTH/2, y_spiral + HEIGHT/2)
ax_2d.fill_between([PURPLE_LINES[0] * WIDTH - 0.05, PURPLE_LINES[0] * WIDTH + 0.05], y_min, y_max, color='yellow', alpha=0.5, label='Golden Window')
# Ghost curve init
ghost_curve, = ax_2d.plot([], [], 'g--', label='Ghost Curve Preview')
# Control indicators in legend
ax_2d.plot([], [], ' ', label='R: Toggle draw mode')
ax_2d.plot([], [], 'b--', label='A: Toggle protractor')
ax_2d.plot([], [], 'c-', label='M: Toggle measure (ruler)')
ax_2d.plot([], [], ' ', label='D: Toggle dimension')
ax_2d.plot([], [], 'r-', label='C: Close polyhedron (manual)')
ax_2d.plot([], [], ' ', label='Click near first point to close')
ax_2d.plot([], [], ' ', label='Click to select curve')
ax_2d.plot([], [], ' ', label='G: To construction geom')
ax_2d.plot([], [], ' ', label='H: Hide/show')
ax_2d.plot([], [], ' ', label='E: Reset canvas')
ax_2d.plot([], [], ' ', label='S: Export STL')
ax_2d.plot([], [], 'k-', label='Curvature Slider (Controls window)')
# Update curvature
def update_curvature(val):
    global curvature
    curvature = val
    if len(drawing_points) >= 1:
        kappas[-1] = curvature
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
    fig_2d.canvas.draw()
curvature_slider.on_changed(update_curvature)
# Update height
def update_height(val):
    global height
    height = val
    if is_closed:
        update_3d_model()
height_slider.on_changed(update_height)
# Update rings
def update_rings(val):
    global num_rings
    num_rings = int(val)
    if is_closed:
        update_3d_model()
rings_slider.on_changed(update_rings)
# Update fractal level
def update_level(val):
    global fractal_level
    fractal_level = int(val)
    if is_closed:
        update_3d_model()
level_slider.on_changed(update_level)
# Update radial chord
def update_radial(val):
    global radial_chord
    radial_chord = val
    if is_closed:
        update_3d_model()
radial_slider.on_changed(update_radial)
# Update tangential chord
def update_tangential(val):
    global tangential_chord
    tangential_chord = val
    if is_closed:
        update_3d_model()
tangential_slider.on_changed(update_tangential)
# Update height chord
def update_height_chord(val):
    global height_chord
    height_chord = val
    if is_closed:
        update_3d_model()
height_chord_slider.on_changed(update_height_chord)
# Toggle draw mode
def toggle_draw(event):
    global draw_mode
    if event.key == 'r':
        draw_mode = not draw_mode
        print(f"Draw mode {'enabled' if draw_mode else 'disabled'}")
        fig_2d.canvas.draw()
# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        if not protractor_active:
            if protractor_line:
                protractor_line.remove()
                protractor_line = None
            if protractor_text:
                protractor_text.remove()
                protractor_text = None
            protractor_points.clear()
        fig_2d.canvas.draw()
# On click for protractor
def on_click_protractor(event):
    global protractor_line, protractor_text, last_angle
    if protractor_active and event.inaxes == ax_2d and event.button == 1:
        protractor_points.append((event.xdata, event.ydata))
        if len(protractor_points) == 2:
            x1, y1 = protractor_points[0]
            x2, y2 = protractor_points[1]
            if protractor_line:
                protractor_line.remove()
            protractor_line, = ax_2d.plot([x1, x2], [y1, y2], 'b--')
            dx = x2 - x1
            dy = y2 - y1
            angle = np.arctan2(dy, dx) * 180 / np.pi
            last_angle = angle
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if protractor_text:
                protractor_text.remove()
            protractor_text = ax_2d.text(mid_x, mid_y, f'Angle: {angle:.2f}°', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            protractor_points.clear()
            fig_2d.canvas.draw()
# Toggle ruler (measure)
def toggle_ruler(event):
    global ruler_active
    if event.key == 'm':
        ruler_active = not ruler_active
        print(f"Measure (ruler) tool {'enabled' if ruler_active else 'disabled'}")
        if not ruler_active:
            if ruler_line:
                ruler_line.remove()
                ruler_line = None
            if ruler_text:
                ruler_text.remove()
                ruler_text = None
            ruler_points.clear()
        fig_2d.canvas.draw()
# On click for ruler
def on_click_ruler(event):
    global ruler_line, ruler_text
    if ruler_active and event.inaxes == ax_2d and event.button == 1:
        ruler_points.append((event.xdata, event.ydata))
        if len(ruler_points) == 2:
            x1, y1 = ruler_points[0]
            x2, y2 = ruler_points[1]
            if ruler_line:
                ruler_line.remove()
            ruler_line, = ax_2d.plot([x1, x2], [y1, y2], 'c-')
            dx = x2 - x1
            dy = y2 - y1
            dist = np.sqrt(dx**2 + dy**2)
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if ruler_text:
                ruler_text.remove()
            ruler_text = ax_2d.text(mid_x, mid_y, f'Dist: {dist:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            ruler_points.clear()
            fig_2d.canvas.draw()
# Toggle dimension
def toggle_dimension(event):
    global dimension_active
    if event.key == 'd':
        dimension_active = not dimension_active
        print(f"Dimension tool {'enabled' if dimension_active else 'disabled'}")
        fig_2d.canvas.draw()
# On click for dimension
def on_click_dimension(event):
    if dimension_active and event.inaxes == ax_2d and event.button == 1:
        if ruler_active and ruler_text:
            dimension_labels.append(ruler_text)
        elif selected_curve:
            x, y = selected_curve.get_data()
            length = np.sum(np.sqrt(np.diff(x)**2 + np.diff(y)**2))
            mid_x = np.mean(x)
            mid_y = np.mean(y)
            dim_text = ax_2d.text(mid_x, mid_y + 0.05, f'Len: {length:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            dimension_labels.append(dim_text)
        fig_2d.canvas.draw()
# Toggle pro mode (lock/unlock)
def toggle_pro_mode(event):
    global pro_mode
    if event.key == 'x':
        pro_mode = not pro_mode
        print(f"Pro mode {'locked' if pro_mode else 'unlocked'}")
        fig_2d.canvas.draw()
# On pick event for nodes
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow') # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()
# Show ghost handles (theta points, midpoints between nodes)
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow') # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()
# Show ghost handles (theta points, midpoints between nodes)
def show_ghost_handles():
    global ghost_handles
    for handle in ghost_handles:
        handle.remove()
    ghost_handles = []
    num_points = len(drawing_points) if not is_closed else len(drawing_points) - 1 # Avoid double midpoint on close
    for i in range(num_points):
        next_i = (i + 1) % len(drawing_points) if is_closed else i + 1
        if next_i >= len(drawing_points):
            continue
        mid_x = (drawing_points[i][0] + drawing_points[next_i][0]) / 2
        mid_y = (drawing_points[i][1] + drawing_points[next_i][1]) / 2
        handle = ax_2d.scatter(mid_x, mid_y, color='yellow', s=30, marker='o')
        ghost_handles.append(handle)
    fig_2d.canvas.draw()
# On button press for dragging
def on_button_press(event):
    global dragging
    if pro_mode and selected_node_index != -1 and event.inaxes == ax_2d and event.button == 1:
        dragging = True
# On button release for dragging
def on_button_release(event):
    global dragging
    dragging = False
# On motion for dragging and preview
def on_motion(event):
    global previous_kappa, dragging, selected_node_index
    if dragging and pro_mode and selected_node_index != -1 and event.inaxes == ax_2d:
        drawing_points[selected_node_index] = (event.xdata, event.ydata)
        node_scatter[selected_node_index].set_offsets([[event.xdata, event.ydata]])
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
        fig_2d.canvas.draw()
        return
    if draw_mode and len(drawing_points) > 0 and event.inaxes == ax_2d and not (protractor_active or ruler_active or dimension_active):
        x, y = event.xdata, event.ydata
        preview_points = drawing_points + [(x, y)]
        preview_kappas = kappas + [curvature]
        close_preview = False
        if len(preview_points) > 2:
            dx_first = x - drawing_points[0][0]
            dy_first = y - drawing_points[0][1]
            dist_first = np.sqrt(dx_first**2 + dy_first**2)
            if dist_first < CLOSE_THRESHOLD:
                preview_points[-1] = drawing_points[0]
                preview_kappas[-1] = curvature
                # Preview kappa1 adjustment for closure
                last_theta = np.sqrt((drawing_points[-1][0] - preview_points[-1][0])**2 + (drawing_points[-1][1] - preview_points[-1][1])**2)
                if last_theta < 1e-10: # Manage '0' snap error in preview
                    last_theta = 1e-10
                decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                preview_kappas[0] = preview_kappas[-1] * decay_factor * curvature
                close_preview = True
        # Compute kappa for preview segment (cursor at theta)
        if len(preview_points) > 1:
            preview_kappa = compute_segment_kappa(preview_points[-2], preview_points[-1], curvature, previous_kappa)
            preview_kappas[-1] = preview_kappa
        x_ghost, y_ghost = custom_interoperations_green_curve(preview_points, preview_kappas, is_closed=close_preview)
        ghost_curve.set_data(x_ghost, y_ghost)
        fig_2d.canvas.draw()
# Generate G-code for the curve with variable speeds (for 2D plotting/CNC, scaled to mm)
def generate_gcode(x, y, speeds, scale=297):
    """
    Generates simple G-code for linear moves along the curve with variable feedrates.
    Args:
        x (array): X coordinates (normalized).
        y (array): Y coordinates (normalized).
        speeds (list): Normalized speeds (0-1) for each point.
        scale (float): Scale factor to convert normalized units to mm (based on A3 height=297mm).
    Returns:
        str: G-code string.
    """
    gcode = "G21 ; Set units to millimeters\n"
    gcode += "G90 ; Absolute positioning\n"
    # Move to start position (rapid)
    gcode += f"G0 X{x[0] * scale:.2f} Y{y[0] * scale:.2f}\n"
    # Linear moves with varying feedrate
    for i in range(1, len(x)):
        feedrate = speeds[i] * 900 + 100 # Scale speed to 100-1000 mm/min
        gcode += f"G1 X{x[i] * scale:.2f} Y{y[i] * scale:.2f} F{feedrate:.0f}\n"
    return gcode
# Drawing mode: Add kappa nodes and update continuous greencurve
def on_click_draw(event):
    global green_curve_line, selected_curve, previous_kappa, vanishing_points, current_vertices, current_faces, is_closed
    if event.inaxes == ax_2d and event.button == 1:
        x, y = event.xdata, event.ydata
        # Snap to dividers if close (UX improvement for precise alignment)
        for div in PURPLE_LINES:
            div_x = div * WIDTH
            if abs(x - div_x) < SNAP_THRESHOLD:
                x = div_x
                break
        if draw_mode and not (protractor_active or ruler_active or dimension_active):
            # Check if near first point to close
            if len(drawing_points) > 2:
                dx_first = x - drawing_points[0][0]
                dy_first = y - drawing_points[0][1]
                dist_first = np.sqrt(dx_first**2 + dy_first**2)
                if dist_first < CLOSE_THRESHOLD:
                    # Adjust kappa1 based on last theta and kappa
                    last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
                    if last_theta < 1e-10: # Manage '0' snap error
                        last_theta = 1e-10
                    decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                    kappas[0] = kappas[-1] * decay_factor * curvature # Affect kappa1 with last kappa and decay
                    drawing_points.append(drawing_points[0])
                    kappas.append(kappas[0]) # Last kappa inherits first kappa's theta (via same value)
                    recalculate_kappas() # Recalculate for closure consistency
                    is_closed = True
                    redraw_green_curve(is_closed=True) # Use closed NURKS for ellipse conditions
                    # Get closed curve
                    x_curve, y_curve = green_curve_line.get_data()
                    if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
                        x_curve = np.append(x_curve, x_curve[0])
                        y_curve = np.append(y_curve, y_curve[0])
                    ax_3d.cla()
                    current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
                    verts = [[current_vertices[i] for i in f] for f in current_faces]
                    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
                    ax_3d.set_xlabel('X')
                    ax_3d.set_ylabel('Y')
                    ax_3d.set_zlabel('Z')
                    ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
                    fig_3d.canvas.draw()
                    print("Polyhedron closed and 3D model generated")
                    # Compute and print speeds for user generated curve
                    print("User Generated Curve Speeds:")
                    speeds = []
                    for i in range(len(x_curve)):
                        speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
                        print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
                        speeds.append(speed)
                    # Generate G-Code
                    gcode = generate_gcode(x_curve, y_curve, speeds)
                    with open('model.gcode', 'w') as f:
                        f.write(gcode)
                    print("G-Code saved to model.gcode")
                    print(gcode)
                    fig_2d.canvas.draw()
                    return
            # Add new kappa node (first endpoint)
            roygbiv = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
            color = roygbiv[len(drawing_points) % 7]
            node = ax_2d.scatter(x, y, color=color, s=50, picker=True, label='Kappa Node' if len(drawing_points) == 0 else None)
            node_scatter.append(node)
            original_colors.append(color)
            drawing_points.append((x, y))
            kappas.append(curvature)
            if len(drawing_points) > 1:
                previous_kappa = compute_segment_kappa(drawing_points[-2], drawing_points[-1], curvature, previous_kappa)
                redraw_green_curve(is_closed=is_closed)
                if len(drawing_points) >= 2:
                    t = np.linspace(0, 1, 100)
                    x_green, y_green = green_curve_line.get_data()
                    curv = compute_curvature(x_green, y_green, t)
                    print(f"Green curve curvature: Max={curv.max():.4f}, Min={curv.min():.4f}")
            if len(drawing_points) >= 3:
                print("Third point added: Introducing depth and triangulation")
                tri_points = drawing_points[-3:]
                vp = compute_vanishing_point(tri_points)
                vanishing_points.append(vp)
                ax_2d.scatter(vp[0], vp[1], color='purple', s=30, label='Vanishing Point' if len(vanishing_points) == 1 else None)
            fig_2d.canvas.draw()
        elif not draw_mode and not (protractor_active or ruler_active or dimension_active):
            min_dist = float('inf')
            selected_curve = None
            if green_curve_line:
                x_curve, y_curve = green_curve_line.get_data()
                dist = np.min(np.sqrt((x_curve - x)**2 + (y_curve - y)**2))
                if dist < min_dist and dist < 0.05:
                    min_dist = dist
                    selected_curve = green_curve_line
            if selected_curve:
                selected_curve.set_linewidth(3.0)
                print("Green curve selected")
                fig_2d.canvas.draw()
# Close polyhedron (manual trigger)
def close_polyhedron(event):
    if event.key == 'c':
        print("Close via clicking near first point when ghosted")
# Auto close on 'c'
def auto_close(event):
    global is_closed, drawing_points, kappas, previous_kappa
    if event.key == 'c' and len(drawing_points) > 2:
        # Adjust kappa1 based on last theta and kappa
        last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
        if last_theta < 1e-10: # Manage '0' snap error
            last_theta = 1e-10
        decay_factor = np.exp(-last_theta / WIDTH / 20.0)
        kappas[0] = kappas[-1] * decay_factor * curvature # Affect kappa1 with last kappa and decay
        drawing_points.append(drawing_points[0])
        kappas.append(kappas[0]) # Last kappa inherits first kappa's theta (via same value)
        recalculate_kappas() # Recalculate for closure consistency
        is_closed = True
        redraw_green_curve(is_closed=True) # Use closed NURKS for ellipse conditions
        # Get closed curve
        x_curve, y_curve = green_curve_line.get_data()
        if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
        print("Polyhedron closed and 3D model generated")
        # Compute and print speeds for user generated curve
        print("User Generated Curve Speeds:")
        speeds = []
        for i in range(len(x_curve)):
            speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
            print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
            speeds.append(speed)
        # Generate G-Code
        gcode = generate_gcode(x_curve, y_curve, speeds)
        with open('model.gcode', 'w') as f:
            f.write(gcode)
        print("G-Code saved to model.gcode")
        print(gcode)
        fig_2d.canvas.draw()
# Change to construction geometry
def to_construction(event):
    global selected_curve
    if event.key == 'g' and selected_curve:
        selected_curve.set_linestyle('--')
        selected_curve.set_color('gray')
        print("Green curve changed to construction geometry")
        selected_curve = None
        fig_2d.canvas.draw()
# Hide/show
def hide_show(event):
    global hidden_elements, selected_curve
    if event.key == 'h':
        if selected_curve:
            if selected_curve.get_visible():
                selected_curve.set_visible(False)
                hidden_elements.append(selected_curve)
                print("Green curve hidden")
            else:
                selected_curve.set_visible(True)
                if selected_curve in hidden_elements:
                    hidden_elements.remove(selected_curve)
                print("Green curve shown")
            selected_curve = None
        else:
            for elem in hidden_elements:
                elem.set_visible(True)
            hidden_elements.clear()
            print("All hidden elements shown")
        fig_2d.canvas.draw()
# Reset canvas
def reset_canvas(event):
    global drawing_points, kappas, previous_kappa, green_curve_line, vanishing_points, selected_curve, current_vertices, current_faces, last_angle, node_scatter, ghost_handles, is_closed, original_colors
    if event.key == 'e':
        drawing_points = []
        kappas = []
        previous_kappa = 1.0
        if green_curve_line:
            green_curve_line.remove()
            green_curve_line = None
        for node in node_scatter:
            node.remove()
        node_scatter = []
        original_colors = []
        for handle in ghost_handles:
            handle.remove()
        ghost_handles = []
        vanishing_points = []
        selected_curve = None
        ax_3d.cla()
        current_vertices = None
        current_faces = None
        last_angle = 0.0
        is_closed = False
        display_pod_surface()
        print("Canvas reset")
        fig_2d.canvas.draw()
# Compute curvature for continuity check
def compute_curvature(x, y, t):
    dt = t[1] - t[0]
    dx_dt = np.gradient(x, dt)
    dy_dt = np.gradient(y, dt)
    d2x_dt2 = np.gradient(dx_dt, dt)
    d2y_dt2 = np.gradient(dy_dt, dt)
    numerator = np.abs(dx_dt * d2y_dt2 - dy_dt * d2x_dt2)
    denominator = (dx_dt**2 + dy_dt**2)**1.5
    denominator = np.where(denominator == 0, 1e-10, denominator)
    return numerator / denominator
# Generate base pod curve (closed for boundary surface, now 3D curve)
def generate_pod_curve_closed(num_points=200, phase=0.0): # Increased num_points for better resolution
    t = np.linspace(0, 2 * np.pi, num_points) # Full closed loop
    r = radial_chord + tangential_chord * np.cos(6 * t + phase) # Flower-like top profile
    x = r * np.cos(t)
    y = r * np.sin(t)
    z = height_chord * np.sin(6 * t + phase) # Add z variation for 3D curve
    return x, y, z
# Function to compute normals
def compute_normal(v1, v2, v3):
    vec1 = v2 - v1
    vec2 = v3 - v1
    normal = np.cross(vec1, vec2)
    norm = np.linalg.norm(normal)
    return normal / norm if norm != 0 else normal
# Export current model to STL
def export_stl():
    global current_vertices, current_faces
    if current_vertices is None or current_faces is None:
        print("No model to export")
        return
    stl_data = b'\x00' * 80 # Header
    stl_data += struct.pack('<I', len(current_faces)) # Number of triangles
    for face in current_faces:
        v1 = current_vertices[face[0]]
        v2 = current_vertices[face[1]]
        v3 = current_vertices[face[2]]
        normal = compute_normal(v1, v2, v3)
        stl_data += struct.pack('<3f', *normal)
        stl_data += struct.pack('<3f', *v1)
        stl_data += struct.pack('<3f', *v2)
        stl_data += struct.pack('<3f', *v3)
        stl_data += b'\x00\x00' # Attribute byte count
    filename = 'model.stl'
    with open(filename, 'wb') as f:
        f.write(stl_data)
    print(f"Saved to {filename}")
    stl_base64 = base64.b64encode(stl_data).decode('utf-8')
    print("Base64 STL:")
    print(stl_base64)
# Save STL on key press
def save_stl(event):
    if event.key == 's':
        export_stl()
# Display pod surface by default in 3D with curvature continuous end caps
def display_pod_surface():
    global current_vertices, current_faces
    x_curve, y_curve, z_curve = generate_pod_curve_closed(200) # Increased for resolution
    current_vertices, current_faces = build_mesh(x_curve, y_curve, z_curve)
    verts = [[current_vertices[i] for i in f] for f in current_faces]
    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
    ax_3d.set_xlabel('X')
    ax_3d.set_ylabel('Y')
    ax_3d.set_zlabel('Z')
    ax_3d.set_title('3D pod Projected Surface (Compound Curvature with End Caps)')
    fig_3d.canvas.draw()
# Draw default pod ellipse as green curve on 2D canvas
def draw_default_pod(ax, color='g'):
    x, y, _ = generate_pod_curve_closed(num_points=36) # Increased to 36 for better flower
    x_control = x[:-1]
    y_control = y[:-1]
    scale = 0.6 # Scale for large curve
    x_control *= scale
    y_control *= scale
    x_control += WIDTH / 2
    y_control += HEIGHT / 2
    points = list(zip(x_control, y_control))
    kappas_pod = [1.0] * len(points)
    x_interp, y_interp = custom_interoperations_green_curve(points, kappas_pod, is_closed=True)
    ax.plot(x_interp, y_interp, color=color, linewidth=3, linestyle='-')
    # Compute and print speeds for default curve
    print("Default Curve Speeds:")
    for i in range(len(x_interp)):
        speed = int(hashlib.sha256(f"{x_interp[i]}{y_interp[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
        print(f"Point {i}: ({x_interp[i]:.4f}, {y_interp[i]:.4f}), Speed: {speed:.4f}")
# Add Mersenne elements to the plot
# First A4 page (adjusted)
ax_2d.plot([0, WIDTH/2, WIDTH/2, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 1')
# Second A4 page
ax_2d.plot([WIDTH/2, WIDTH, WIDTH, WIDTH/2, WIDTH/2], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 2')
# Purple lines (in first A4)
for x in PURPLE_LINES:
    ax_2d.plot([x * (WIDTH/2), x * (WIDTH/2)], [0, HEIGHT], 'm-')
# Red datum line
ax_2d.plot([0, WIDTH], [0, 0], 'r-')
# A4 short edge divisions (first A4 only)
for x in division_positions:
    ax_2d.plot([x, x], [0, 0.02], 'k-', alpha=0.3)
# Plot circle division markers
for x_marker, y_marker in circle_markers:
    ax_2d.plot(x_marker, y_marker, 'k.', markersize=3)
# Full spiral
ax_2d.plot(x_full, y_full, 'k-')
# Green segment
ax_2d.plot(x_green_final, y_green_scaled, 'g-')
# 52 Mersenne prime curves
for i, (x_new, y_new, label) in enumerate(curves):
    line, = ax_2d.plot(x_new, y_new, color=colors[i])
    curve_lines[i] = line
# Flags and staggered labels
label_y_offset = 0.05
for i, (x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq) in enumerate(flag_positions):
    ax_2d.plot([x_end, x_start], [y_end, y_start], 'k--', alpha=0.3)
    ax_2d.plot([x_start, x_flag], [y_start, y_flag], 'k-', alpha=0.5)
    y_label = y_flag - (i % 5) * label_y_offset
    text = ax_2d.text(x_flag, y_label, label, ha='left', va='top', fontsize=6, rotation=45, picker=5)
    harmonic_text = ax_2d.text(x_flag, y_label - 0.1, f"{freq:.1f} Hz", ha='left', va='top', fontsize=6, rotation=45, visible=False)
    annotation_objects.append((text, i))
    harmonic_texts.append(harmonic_text)
# Golden window 1 (vertical at x = 1/3)
idx_crossings_x = np.where(np.diff(np.sign(x_full - PURPLE_LINES[0])))[0]
if len(idx_crossings_x) >= 2:
    y1 = y_full[idx_crossings_x[0]]
    y2 = y_full[idx_crossings_x[1]]
    golden_window_1 = np.abs(y2 - y1)
    print(f"Golden Window 1 at x={PURPLE_LINES[0]}: {golden_window_1:.4f}")
    ax_2d.fill_between([PURPLE_LINES[0] - 0.05, PURPLE_LINES[0] + 0.05], min(y1, y2), max(y1, y2), color='yellow', alpha=0.5)
# Golden window 2 (horizontal at y = 1/3)
idx_crossings_y = np.where(np.diff(np.sign(y_full - 1/3)))[0]
if len(idx_crossings_y) >= 2:
    x1 = x_full[idx_crossings_y[0]]
    x2 = x_full[idx_crossings_y[1]]
    golden_window_2 = np.abs(x2 - x1)
    print(f"Golden Window 2 at y=1/3: {golden_window_2:.4f}")
    ax_2d.fill_betweenx([1/3 - 0.05, 1/3 + 0.05], min(x1, x2), max(x1, x2), color='orange', alpha=0.5)
# Scale label
ax_2d.text(WIDTH, 1.10337, scale_label, ha='right', va='bottom', fontsize=8)
# Update title with scale key
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
# Highlighting functionality for Mersenne labels
highlighted = [None, None]
def on_pick_mersenne(event):
    global highlighted
    artist = event.artist
    for text, idx in annotation_objects:
        if artist == text:
            if highlighted[0] is not None:
                highlighted[0].set_color('black')
                highlighted[0].set_weight('normal')
                curve_lines[highlighted[1]].set_linewidth(1.0)
                curve_lines[highlighted[1]].set_color(colors[highlighted[1]])
            text.set_color('red')
            text.set_weight('bold')
            curve_lines[idx].set_linewidth(2.0)
            curve_lines[idx].set_color('red')
            highlighted = [text, idx]
            fig_2d.canvas.draw()
            break
def on_click_deselect(event):
    global highlighted
    if event.inaxes != ax_2d:
        return
    clicked_on_annotation = False
    for text, idx in annotation_objects:
        if text.contains(event)[0]:
            clicked_on_annotation = True
            break
    if not clicked_on_annotation and highlighted[0] is not None:
        highlighted[0].set_color('black')
        highlighted[0].set_weight('normal')
        curve_lines[highlighted[1]].set_linewidth(1.0)
        curve_lines[highlighted[1]].set_color(colors[highlighted[1]])
        highlighted = [None, None]
        fig_2d.canvas.draw()
# Curve cache for hashing
curve_cache = {}
def compute_curve_points(theta_start, theta_end, num_points, scale_factor, rotation_angle=0):
    # Create a hash key based on parameters
    key = f"{theta_start:.2f}:{theta_end:.2f}:{num_points}:{scale_factor:.4f}:{rotation_angle:.2f}"
    key_hash = hashlib.md5(key.encode()).hexdigest()
    if key_hash in curve_cache:
        return curve_cache[key_hash]
    theta = np.linspace(theta_start, theta_end, num_points)
    r = scale_factor * A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Apply rotation
    if rotation_angle != 0:
        angle_rad = np.deg2rad(rotation_angle)
        x_rot = x * np.cos(angle_rad) - y * np.sin(angle_rad)
        y_rot = x * np.sin(angle_rad) + y * np.cos(angle_rad)
        x, y = x_rot, y_rot
    curve_cache[key_hash] = (x, y)
    return x, y
# Dynamic LOD
def get_num_points_for_curve():
    xlim = ax_2d.get_xlim()
    ylim = ax_2d.get_ylim()
    view_width = xlim[1] - xlim[0]
    view_height = ylim[1] - ylim[0]
    # Base number of points when fully zoomed out
    base_points = 20
    max_points = 200
    # Zoom factor: smaller view range means more zoom
    full_range = WIDTH # Full x-range when zoomed out
    zoom_factor = full_range / view_width
    num_points = int(base_points + (max_points - base_points) * min(zoom_factor / 10, 1))
    return max(base_points, min(max_points, num_points))
# Cursor, spiral, and circumference setup
cursor, = ax_2d.plot([], [], 'ro', markersize=8, label='κ Spiral Cursor', visible=False)
cursor_spiral, = ax_2d.plot([], [], 'g-', alpha=0.5, visible=False)
cursor_circumference = plt.Circle((0, 0), 0, color='b', fill=False, linestyle='--', alpha=0.5, visible=False)
ax_2d.add_patch(cursor_circumference)
cursor_text = ax_2d.text(WIDTH / 2, 1.15, '', ha='center', va='bottom', fontsize=8, visible=False)
baseline_spiral, = ax_2d.plot([], [], 'g-', alpha=0.5, label='Baseline Spiral', visible=False)
baseline_spiral_2, = ax_2d.plot([], [], 'g-', alpha=0.5, label='Baseline Spiral 2', visible=False)
# Crosslines
vertical_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
horizontal_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
vertical_label = ax_2d.text(target_chord, HEIGHT + 0.05, f'Chord: {target_chord:.4f}', ha='center', va='bottom', fontsize=8, visible=False)
# Protractor elements
protractor_line, = ax_2d.plot([], [], 'b-', alpha=0.8, visible=False)
protractor_text = ax_2d.text(0, 0, '', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8), visible=False)
protractor_arc, = ax_2d.plot([], [], 'b-', alpha=0.5, visible=False)
protractor_spiral_2, = ax_2d.plot([], [], 'g-', alpha=0.5, visible=False)
# Baseline angle (grey ghost line)
baseline_angle_line, = ax_2d.plot([0, WIDTH], [0, 0], 'grey', alpha=0.3, linestyle='--', visible=False)
# Swinging ghost curves
ghost_curves = []
for _ in range(4): # ±5°, ±10° (4 curves total)
    line, = ax_2d.plot([], [], 'grey', alpha=0.2, visible=False)
    ghost_curves.append(line)
# Ruler elements
ruler_divisions = []
for _ in range(10): # Up to 10 division markers
    marker, = ax_2d.plot([], [], 'k|', markersize=10, markeredgewidth=2, visible=False)
    ruler_divisions.append(marker)
ruler_vanishing_line, = ax_2d.plot([], [], 'k--', alpha=0.5, visible=False)
# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        cursor.set_visible(protractor_active)
        cursor_spiral.set_visible(protractor_active)
        cursor_circumference.set_visible(protractor_active)
        cursor_text.set_visible(protractor_active)
        baseline_spiral.set_visible(protractor_active)
        baseline_spiral_2.set_visible(protractor_active)
        vertical_line.set_visible(protractor_active)
        horizontal_line.set_visible(protractor_active)
        vertical_label.set_visible(protractor_active)
        protractor_line.set_visible(protractor_active)
        protractor_text.set_visible(protractor_active)
        protractor_arc.set_visible(protractor_active)
        protractor_spiral_2.set_visible(protractor_active)
        baseline_angle_line.set_visible(protractor_active)
        for curve in ghost_curves:
            curve.set_visible(protractor_active)
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        fig_2d.canvas.draw()
# On motion for protractor
def on_motion_protractor(event):
    if not protractor_active or event.inaxes != ax_2d:
        return
    x, y = event.xdata, event.ydata
    if x is None or y is None:
        return
    # Update cursor position
    cursor.set_data([x], [y])
    # Update circumference
    radius = np.sqrt(x**2 + y**2)
    cursor_circumference.set_center((x, y))
    cursor_circumference.set_radius(radius)
    # Dynamic LOD: Adjust number of points based on zoom
    num_points = get_num_points_for_curve()
    # Update cursor spiral
    x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
    cursor_spiral.set_data(x + x_spiral, y + y_spiral)
    # Update baseline spiral (indexed at (0,0))
x_base = 0.0
scale_factor = (event.xdata / WIDTH) if event.xdata > 0 else 0.01
scaled_a = A_SPIRAL * scale_factor
height_factor = (event.ydata / HEIGHT) if event.ydata > 0 else 0.01
x_base_spiral, y_base_spiral = compute_curve_points(2 * np.pi, np.pi, num_points, scale_factor)
x_base_spiral = x_base + x_base_spiral * np.abs(np.cos(np.linspace(2 * np.pi, np.pi, num_points)))
y_base_spiral = y_base_spiral * height_factor
baseline_spiral.set_data(x_base_spiral, y_base_spiral)
# Compute the chord length of the baseline spiral
x_start = x_base_spiral[0]
y_start = y_base_spiral[0]
x_end = x_base_spiral[-1]
y_end = y_base_spiral[-1]
baseline_chord = np.sqrt((x_end - x_start)**2 + (y_end - y_start)**2)
# Update second baseline spiral (indexed at (1.0, 0))
x_base_2 = 1.0
x_base_spiral_2, y_base_spiral_2 = compute_curve_points(2 * np.pi, np.pi, num_points, scale_factor)
x_base_spiral_2 = x_base_2 + x_base_spiral_2 * np.abs(np.cos(np.linspace(2 * np.pi, np.pi, num_points)))
y_base_spiral_2 = y_base_spiral_2 * height_factor
baseline_spiral_2.set_data(x_base_spiral_2, y_base_spiral_2)
# Compute the chord length of the second baseline spiral
x_start_2 = x_base_spiral_2[0]
y_start_2 = y_base_spiral_2[0]
x_end_2 = x_base_spiral_2[-1]
y_end_2 = y_base_spiral_2[-1]
baseline_chord_2 = np.sqrt((x_end_2 - x_start_2)**2 + (y_end_2 - y_start_2)**2)
# Update crosslines
vertical_line.set_data([target_chord, target_chord], [0, HEIGHT])
vertical_label.set_position((target_chord, HEIGHT + 0.05))
if y > 0:
    horizontal_line.set_data([0, WIDTH], [y, y])
else:
    horizontal_line.set_data([], [])
# Update protractor line (from (0,0) to mouse position)
anchor_x, anchor_y = 0.0, 0.0
protractor_line.set_data([anchor_x, x], [anchor_y, y])
# Compute the angle relative to the baseline (y=0)
dx = x - anchor_x
dy = y - anchor_y
angle = np.arctan2(dy, dx) * 180 / np.pi
# Update protractor arc
mid_x = (anchor_x + x) / 2
mid_y = (anchor_y + y) / 2
radius_arc = np.sqrt(dx**2 + dy**2) / 4
start_angle = 0
end_angle = angle
theta_arc = np.linspace(np.deg2rad(start_angle), np.deg2rad(end_angle), num_points)
x_arc = mid_x + radius_arc * np.cos(theta_arc)
y_arc = mid_y + radius_arc * np.sin(theta_arc)
protractor_arc.set_data(x_arc, y_arc)
# Update swinging ghost curves
offsets = [-10, -5, 5, 10] # Degrees
for i, offset in enumerate(offsets):
    angle_offset = angle + offset
    x_ghost, y_ghost = compute_curve_points(np.pi, 2 * np.pi, num_points // 2, 1.0, angle_offset)
    ghost_curves[i].set_data(anchor_x + x_ghost, anchor_y + y_ghost)
# Update protractor spiral at the mouse position
line_vec = np.array([x - anchor_x, y - anchor_y])
line_len = np.sqrt(dx**2 + dy**2)
if line_len == 0:
    line_len = 1e-10
normal_vec = np.array([-(y - anchor_y), x - anchor_x]) / line_len
x_spiral, y_spiral = compute_curve_points(np.pi, 2 * np.pi, num_points, 1.0)
x_mirrored = []
y_mirrored = []
for xs, ys in zip(x_spiral, y_spiral):
    point = np.array([xs, ys])
    v = point - np.array([anchor_x, anchor_y])
    projection = np.dot(v, normal_vec) * normal_vec
    mirrored_point = point - 2 * projection
    x_mirrored.append(mirrored_point[0])
    y_mirrored.append(mirrored_point[1])
protractor_spiral_2.set_data(x + x_mirrored, y + y_mirrored)
# Update protractor text
protractor_text.set_position((mid_x, mid_y))
protractor_text.set_text(f'Angle: {angle:.2f}°\nκ at 2πR: {kappa_at_2piR:.4f}')
# Calculate chord length from cursor to the start of the green segment
x_start_green, y_start_green = x_green_final[0], y_green_scaled[0]
chord_to_green = np.sqrt((x - x_start_green)**2 + (y - y_start_green)**2)
# Update cursor text
text_str = (f'κ: {scale_factor:.4f}\n'
            f'Height Factor: {height_factor:.4f}\n'
            f'Cursor: ({x:.4f}, {y:.4f})\n'
            f'Chord to Green: {chord_to_green:.4f}\n'
            f'Baseline Chord (x=0): {baseline_chord:.4f}\n'
            f'Baseline Chord (x=1): {baseline_chord_2:.4f}')
cursor_text.set_text(text_str)
fig_2d.canvas.draw()

# Toggle harmonics
def toggle_harmonics(event):
    global show_harmonics
    if event.key == 'h':
        show_harmonics = not show_harmonics
        for text in harmonic_texts:
            text.set_visible(show_harmonics)
        print(f"Harmonic frequencies {'shown' if show_harmonics else 'hidden'}")
        fig_2d.canvas.draw()

# Save plot
def save_plot(event):
    if event.key == 'w':
        plt.savefig("nu_curve.png", dpi=300, bbox_inches='tight')
        print("Plot saved as nu_curve.png")
        if MPLD3_AVAILABLE:
            mpld3.save_html(fig_2d, "nu_curve.html")
            print("Interactive plot saved as nu_curve.html")
        else:
            print("Skipping HTML export because mpld3 is not installed.")

# Connect events
fig_2d.canvas.mpl_connect('pick_event', on_pick_mersenne)
fig_2d.canvas.mpl_connect('button_press_event', on_click_deselect)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_harmonics)
fig_2d.canvas.mpl_connect('key_press_event', save_plot)
fig_2d.canvas.mpl_connect('key_press_event', toggle_draw)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('key_press_event', toggle_dimension)
fig_2d.canvas.mpl_connect('key_press_event', to_construction)
fig_2d.canvas.mpl_connect('key_press_event', hide_show)
fig_2d.canvas.mpl_connect('key_press_event', reset_canvas)
fig_2d.canvas.mpl_connect('key_press_event', save_stl)
fig_2d.canvas.mpl_connect('button_press_event', on_click_protractor)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_dimension)
fig_2d.canvas.mpl_connect('button_press_event', on_click_draw)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion)
fig_2d.canvas.mpl_connect('key_press_event', auto_close)
fig_2d.canvas.mpl_connect('key_press_event', toggle_pro_mode)
fig_2d.canvas.mpl_connect('pick_event', on_pick)
fig_2d.canvas.mpl_connect('button_press_event', on_button_press)
fig_2d.canvas.mpl_connect('button_release_event', on_button_release)
# Plot properties
ax_2d.set_xlim(-0.1, WIDTH + 0.1)
ax_2d.set_ylim(-1.5, HEIGHT + 0.1)
ax_2d.set_xlabel('x (Exponents: 2 to 11B)')
ax_2d.set_ylabel('y')
ax_2d.set_title('Golden Spiral with 52 Mersenne Prime Curves on A3 Page\n' + scale_key_text, fontsize=10, pad=20)
ax_2d.grid(True)
ax_2d.set_aspect('equal')
# Display default pod surface and draw default pod
display_pod_surface()
draw_default_pod(ax_2d)
plt.show()

----- END tetra.py -----

----- tetras.py -----
# Copyright 2025 Todd Hutchinson
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# Copyright (C) 2025 Todd Hutchinson
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Todd Hutchinson.

import numpy as np

def fractal_tetra(original_vertices, level, all_triangles):
    """
    Recursively generates Sierpinski tetrahedron triangles for the surface.
    Collects all base-level triangular faces in all_triangles (list of [v1, v2, v3] where vi = [x,y,z]).
   
    Args:
        original_vertices: List of 4 [x,y,z] for the initial tetrahedron.
        level: Current recursion depth.
        all_triangles: List to collect all base triangles.
    """
    if level == 0:
        # Add the 4 faces of the base tetra
        faces = [
            [original_vertices[0], original_vertices[1], original_vertices[2]],
            [original_vertices[0], original_vertices[1], original_vertices[3]],
            [original_vertices[0], original_vertices[2], original_vertices[3]],
            [original_vertices[1], original_vertices[2], original_vertices[3]]
        ]
        all_triangles.extend(faces)
        return
   
    # Compute midpoints for subdivision
    mid01 = [(original_vertices[0][j] + original_vertices[1][j])/2 for j in range(3)]
    mid02 = [(original_vertices[0][j] + original_vertices[2][j])/2 for j in range(3)]
    mid03 = [(original_vertices[0][j] + original_vertices[3][j])/2 for j in range(3)]
    mid12 = [(original_vertices[1][j] + original_vertices[2][j])/2 for j in range(3)]
    mid13 = [(original_vertices[1][j] + original_vertices[3][j])/2 for j in range(3)]
    mid23 = [(original_vertices[2][j] + original_vertices[3][j])/2 for j in range(3)]
   
    # 4 sub-tetras at corners
    sub0 = [original_vertices[0], mid01, mid02, mid03]
    sub1 = [original_vertices[1], mid01, mid12, mid13]
    sub2 = [original_vertices[2], mid02, mid12, mid23]
    sub3 = [original_vertices[3], mid03, mid13, mid23]
   
    # Recurse
    for sub in [sub0, sub1, sub2, sub3]:
        fractal_tetra(sub, level - 1, all_triangles)

def build_mesh(x_curve, y_curve, num_points, fractal_level=3):
    """
    Builds 3D mesh using fractal tetrahedron, scaled by curve length.
    Returns vertices (list of [x,y,z]) and faces (list of [idx1, idx2, idx3]).
    Note: Vertices may have duplicates; for optimization, deduplicate if needed.
    """
    # Compute curve length for scale
    curve_length = np.sum(np.sqrt(np.diff(x_curve)**2 + np.diff(y_curve)**2))
    scale = curve_length if curve_length > 0 else 1.0
   
    # Initial regular tetrahedron vertices
    orig = np.array([
        [0, 0, 0],
        [1, 0, 0],
        [0.5, np.sqrt(3)/2, 0],
        [0.5, np.sqrt(3)/6, np.sqrt(6)/3]
    ]) * scale
   
    all_triangles = [] # List of [[x1,y1,z1], [x2,y2,z2], [x3,y3,z3]]
    fractal_tetra(orig.tolist(), fractal_level, all_triangles)
   
    # Flatten to global vertices and faces
    vertices = []
    faces = []
    for tri in all_triangles:
        base_idx = len(vertices)
        vertices.extend(tri)
        faces.append([base_idx, base_idx+1, base_idx+2])
   
    return vertices, faces

----- END tetras.py -----

----- END tetra -----

----- tetra.py -----
# tetra.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib import cm
from matplotlib.widgets import Slider
import hashlib
from decimal import Decimal, getcontext
import warnings
from matplotlib import MatplotlibDeprecationWarning
import struct
import base64

# Import mpld3 if available for HTML export
try:
    import mpld3
    MPLD3_AVAILABLE = True
except ImportError:
    print("mpld3 not installed. HTML export will be skipped. Install mpld3 with 'pip install mpld3' to enable.")
    MPLD3_AVAILABLE = False

from temperature_salt import secure_hash_two
from kappa_grid import kappa_grid
from green_curve import bspline_basis, custom_interoperations_green_curve

# Set precision for Decimal
getcontext().prec = 28

# Suppress warnings
warnings.filterwarnings("ignore", category=MatplotlibDeprecationWarning)

# A3 landscape dimensions (normalized: width long side, height short side)
WIDTH = 420 / 297  # A3 landscape: 420mm width, 297mm height, normalized height=1.0
HEIGHT = 1.0
PURPLE_LINES = [1/3, 2/3]  # Dividers on the width
unit_per_mm = 1.0 / 297  # Normalize to A3 short side
scale_label = f"Scale: 1mm = {unit_per_mm:.5f} units (A3 short side = 297mm)"

# Dreyfuss human factors: Optimal eye distance ~20 inches (508mm)
EYE_DISTANCE = 500 * unit_per_mm  # Normalized eye distance to viewport
HORIZON_HEIGHT = HEIGHT * 0.5  # Default horizon line at half height
EYE_LINE = HORIZON_HEIGHT  # Eye line coincides with horizon

# Golden spiral parameters
PHI = (1 + np.sqrt(5)) / 2
kappa = 1 / PHI
A_SPIRAL = 0.001  # Scaled down slightly from 0.01 to fit better
B_SPIRAL = np.log(PHI) / (np.pi / 2)

# Define κθπ for the green segment
theta_max = kappa * np.pi**2 / PHI

# Compute the full spiral
theta_full = np.linspace(0, 10 * np.pi, 1000)
r_full = A_SPIRAL * np.exp(B_SPIRAL * theta_full)
x_full = r_full * np.cos(theta_full)
y_full = r_full * np.sin(theta_full)

# Compute the green segment (θ from π to 2π)
theta_green = np.linspace(np.pi, 2 * np.pi, 200)
r_green = A_SPIRAL * np.exp(B_SPIRAL * theta_green)
x_green = r_green * np.cos(theta_green)
y_green = r_green * np.sin(theta_green)

# Compute the chord and shift
x1, y1 = x_green[0], y_green[0]
x2, y2 = x_green[-1], y_green[-1]
chord_length = np.abs(x2 - x1)

# Shift so the segment starts at x=0
x_green_shifted = x_green - x1
x_green_final = x_green_shifted

# Scale to match the target chord length (between purple lines)
target_chord = PURPLE_LINES[1] - PURPLE_LINES[0]
scale_factor = target_chord / chord_length if chord_length != 0 else 1.0
x_green_scaled = x_green_final * scale_factor
y_green_scaled = y_green * scale_factor

# Shift to start at the first purple line
x_green_final = x_green_scaled + PURPLE_LINES[0]

# Compute κ at 2πR for the green segment
r_max = A_SPIRAL * np.exp(B_SPIRAL * theta_max)
two_pi_r = 2 * np.pi * r_max
kappa_at_2piR = two_pi_r / PHI

# Define the 52 Mersenne prime exponents (updated with the latest known as of 2025)
mersenne_exponents = [
    2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281,
    3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243,
    110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377,
    6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657,
    37156667, 42643801, 43112609, 57885161, 74207281, 77232917, 82589933,
    136279841  # Latest known Mersenne prime exponent as of 2025 (52nd)
]

# Map exponents to x-positions (0 to width)
min_exponent = 2
max_exponent_at_x1 = 1_100_000_000
exponent_range_per_x = (max_exponent_at_x1 - min_exponent) / 1.0
x_positions = [(exponent - min_exponent) / exponent_range_per_x * WIDTH for exponent in mersenne_exponents]  # Scale to full WIDTH

# Create the 52 curves data
curves = []
curve_lines = []
colors = plt.cm.viridis(np.linspace(0, 1, len(mersenne_exponents)))
for i, (exponent, x_pos) in enumerate(zip(mersenne_exponents, x_positions)):
    scale = x_pos / chord_length if chord_length != 0 else 1.0
    x_new = x_green * scale
    y_new = y_green * scale
    x_new_shifted = x_new - x_new[0]
    curves.append((x_new_shifted, y_new, f"M{exponent}"))
    curve_lines.append(None)

# A4 short edge divisions (110 parts, scaled to first part of WIDTH)
division_step = WIDTH / 2 / 110  # Assume first half is A4-like
division_positions = np.arange(0, WIDTH / 2 + division_step, division_step)

# Scale key for the title
scale_key_positions = division_positions[::10] / (WIDTH / 2)  # Normalize to 0-1 for first half
scale_key_exponents = [int(2 + (1_100_000_000 - 2) * x) for x in scale_key_positions]
scale_key_text = "Scale (x=0 to WIDTH/2): " + ", ".join([f"{x:.2f}: {exp:,}" for x, exp in zip(scale_key_positions, scale_key_exponents)])

# Flags for Mersenne primes
flag_length = 0.5
start_y = -0.1
wedge_angles = np.linspace(90, 360, len(curves))
flag_positions = []
annotation_objects = []
harmonic_frequencies = []
circle_markers = []
min_exp = min(mersenne_exponents)
max_exp = max(mersenne_exponents)
log_min = np.log(min_exp)
log_max = np.log(max_exp)
min_freq_exp = -4.459
max_freq_exp = 5.506
exponent_range = max_freq_exp - min_freq_exp
log_range = log_max - log_min

for i, (x_new, y_new, label) in enumerate(curves):
    x_end = x_new[-1]
    y_end = y_new[-1]
    x_start = x_end
    y_start = start_y
    angle = np.deg2rad(wedge_angles[i])
    x_flag = x_start + flag_length * np.cos(angle)
    y_flag = y_start + flag_length * np.sin(angle)
    exponent = mersenne_exponents[i]
    scaled_exponent = min_freq_exp + (np.log(exponent) - log_min) / log_range * exponent_range
    freq = 440 * 2**scaled_exponent
    harmonic_frequencies.append(freq)
    flag_positions.append((x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq))
    angle_deg = wedge_angles[i]
    if (angle_deg - 90) % 5 == 0:
        angle_rad = np.deg2rad(angle_deg)
        x_marker = x_start + (flag_length * 0.5) * np.cos(angle_rad)
        y_marker = y_start + (flag_length * 0.5) * np.sin(angle_rad)
        circle_markers.append((x_marker, y_marker))

# Global variables for interactive modes
protractor_active = False
ruler_active = False
draw_mode = False
dimension_active = False
pro_mode = False
is_closed = False
selected_curve = None
hidden_elements = []
protractor_points = []
protractor_line = None
protractor_text = None
ruler_points = []
ruler_line = None
ruler_text = None
dimension_labels = []
drawing_points = []  # Kappa nodes (first endpoint of each greenchord)
kappas = []  # Kappa values at each node
node_scatter = []  # List of scatter objects for kappa nodes
original_colors = []  # List to store original colors of nodes
selected_node_index = -1
dragging = False
ghost_handles = []  # List for theta ghost handles
green_curve_line = None  # Single plot object for the interoperated greencurve
CLOSE_THRESHOLD = 0.05  # Distance to first point to consider closing
SNAP_THRESHOLD = 0.05  # Threshold for snapping to dividers (UX improvement)
vanishing_points = []  # Vanishing points for each triangulation
previous_kappa = 1.0  # Initial kappa for decay
curvature = 1.0  # Initial curvature (kappa)
height = 0.5  # Initial height for 3D model
num_rings = 20  # Number of loft rings
fractal_level = 3  # Fractal level for flowers
radial_chord = 0.5  # Radial chord for flower
tangential_chord = 0.2  # Tangential chord for flower
height_chord = 0.1  # Height chord for flower
current_vertices = None
current_faces = None
last_angle = 0.0  # Last measured angle from protractor
show_harmonics = False
harmonic_texts = []
annotation_objects = []

# Pre-compute kappa grid
kappa_grid = kappa_grid(grid_size=100)  # Pre-compute kappa grid for curvature modulation

# Fractal Flower Mesh with guide curves using diameter logic
def fractal_flower(center, scale, level, all_polygons, all_guide_curves, rotation_angle=0.0):
    """
    Recursively generates flower-shaped polygons for the surface.
    Collects all base-level flower polygons in all_polygons (list of list of [x,y,z]).
    Uses 36 points for better flower resolution with curved petals.
    Applies rotation to the points.
    Adds guide curves from petal to petal control points using diameter logic (connecting opposite petals).
    Args:
        center: [x, y, z] center of the flower.
        scale: Scale factor for the flower size.
        level: Current recursion depth.
        all_polygons: List to collect all base flower polygons.
        all_guide_curves: List to collect guide curves (list of [p1, p2] pairs for lines).
        rotation_angle: Rotation angle in radians for the flower.
    """
    rot_cos = np.cos(rotation_angle)
    rot_sin = np.sin(rotation_angle)
    num_points = 37  # 36 points for higher resolution
    t = np.linspace(0, 2 * np.pi, num_points)[:-1]
    r = scale * (radial_chord + tangential_chord * np.sin(6 * t))  # 6 petals, use sin for symmetry if needed
    dx = r * np.cos(t)
    dy = r * np.sin(t)
    dz = scale * height_chord * np.cos(6 * t)  # Curved z for surface
    # Apply rotation to dx, dy (around z)
    x_rot = center[0] + dx * rot_cos - dy * rot_sin
    y_rot = center[1] + dx * rot_sin + dy * rot_cos
    z_rot = center[2] + dz
    polygon = [[x_rot[j], y_rot[j], z_rot[j]] for j in range(len(t))]
    all_polygons.append(polygon)
    # Add guide curves using diameter logic (connect opposite points for each petal pair)
    num_petals = 6
    points_per_petal = len(t) // num_petals
    for p in range(num_petals // 2):  # Pair opposite petals (0-3, 1-4, 2-5)
        petal1_start = p * points_per_petal
        petal2_start = (p + num_petals // 2) * points_per_petal
        # Take midpoint control points of each petal
        petal1_mid = petal1_start + points_per_petal // 2
        petal2_mid = petal2_start + points_per_petal // 2
        p1 = polygon[petal1_mid]
        p2 = polygon[petal2_mid]
        all_guide_curves.append([p1, p2])  # Add line between control points
    if level == 0:
        return
    # Add smaller flowers at petal tips
    small_scale = scale / PHI  # Golden ratio scale
    for i in range(6):
        theta = i * (2 * np.pi / 6)
        tip_r = scale * (radial_chord + tangential_chord)  # Max r for tip
        tip_dx = tip_r * np.cos(theta)
        tip_dy = tip_r * np.sin(theta)
        tip_dz = scale * height_chord
        # Rotate tip offset
        tip_x = center[0] + tip_dx * rot_cos - tip_dy * rot_sin
        tip_y = center[1] + tip_dx * rot_sin + tip_dy * rot_cos
        tip_z = center[2] + tip_dz
        tip_center = [tip_x, tip_y, tip_z]
        fractal_flower(tip_center, small_scale, level - 1, all_polygons, all_guide_curves, rotation_angle + np.pi)

# Triangulate polygon for rendering (fan triangulation)
def triangulate_poly(poly):
    tris = []
    for i in range(1, len(poly) - 1):
        tris.append([poly[0], poly[i], poly[i + 1]])
    return tris

# Hash entropy for lower surface
def hash_entropy(p):
    h_str = f"{p[0]:.6f}{p[1]:.6f}{p[2]:.6f}"
    h = int(hashlib.sha256(h_str.encode()).hexdigest(), 16) % 1000 / 1000.0 * 0.05 - 0.025
    return h

# Build mesh using fractal flower (ties to curve by scaling to curve length)
def build_mesh(x_curve, y_curve, z_curve=None, height=0.5, num_rings=20, num_points=None, fractal_level=3):
    """
    Builds two surfaces meeting at the 3D curve with vertical tangent, inheriting each other's curvature in transition.
    Integrates fractal flower for complex surface detail on caps, scaled by curve length.
    Uses flower modulation in loft rings for interlacing petals.
    Now collects guide curves from petal to petal and adds them as edges in the mesh.
    Args:
        x_curve, y_curve, z_curve: Curve coordinates.
        height: Height for lofting.
        num_rings: Number of rings for loft.
        num_points: Number of points to sample curve.
        fractal_level: Recursion level for fractal flower.
    Returns:
        vertices (np.array): Array of [x, y, z].
        faces (list): List of [idx1, idx2, idx3].
    """
    if num_points is not None:
        indices = np.linspace(0, len(x_curve) - 1, num_points, dtype=int)
        x_curve = x_curve[indices]
        y_curve = y_curve[indices]
        if z_curve is not None:
            z_curve = z_curve[indices]
    n = len(x_curve)
    if z_curve is None:
        z_curve = np.zeros(n)  # Default to flat if no z provided
    # Use node 2 as datum when closed
    center_x = drawing_points[1][0] if is_closed and len(drawing_points) > 1 else drawing_points[0][0] if drawing_points else np.mean(x_curve)
    center_y = drawing_points[1][1] if is_closed and len(drawing_points) > 1 else drawing_points[0][1] if drawing_points else np.mean(y_curve)
    vertices = []
    faces = []
    # Parting line on 3D curve
    parting_base = len(vertices)
    for i in range(n):
        vertices.append([x_curve[i], y_curve[i], z_curve[i]])
    # Upper surface: rings inward with vertical tangent at edge and flower modulation
    upper_bases = [parting_base]
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2  # Vertical tangent at s=0 (dr/ds=0)
        g_val = (height / 2) * s**2  # Quadratic for constant curvature
        base = len(vertices)
        upper_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = 0.0  # Upper phase
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s  # Modulation increases inward
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) + g_val + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_upper_idx = len(vertices)
    vertices.append([center_x, center_y, height / 2])
    # Lower surface: mirrored with phase offset for interlacing and entropy
    lower_bases = [parting_base]  # Shared edge
    for l in range(1, num_rings):
        s = l / (num_rings - 1.0)
        scale = 1 - s**2
        g_val = (height / 2) * s**2  # Quadratic for constant curvature (sign same for inheritance magnitude)
        base = len(vertices)
        lower_bases.append(base)
        for i in range(n):
            vec_x = x_curve[i] - center_x
            vec_y = y_curve[i] - center_y
            norm = np.sqrt(vec_x**2 + vec_y**2)
            if norm > 0:
                dir_x = vec_x / norm
                dir_y = vec_y / norm
            else:
                dir_x = 1.0
                dir_y = 0.0
            theta = np.arctan2(vec_y, vec_x)
            phase = np.pi / 6  # Lower phase offset for interlacing
            flower_mod = tangential_chord * np.cos(6 * theta + phase) * s
            r = norm * scale * (radial_chord + flower_mod)
            x = center_x + r * dir_x
            y = center_y + r * dir_y
            z = z_curve[i] * (1 - s) - g_val + hash_entropy([x, y, z]) + height_chord * np.sin(6 * theta + phase)
            vertices.append([x, y, z])
    center_lower_idx = len(vertices)
    vertices.append([center_x, center_y, -height / 2])
    # Faces for upper surface
    for ll in range(len(upper_bases) - 1):
        base = upper_bases[ll]
        next_base = upper_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, base + next_i, next_base + next_i])
            faces.append([base + i, next_base + next_i, next_base + i])
    # Faces for lower surface
    for ll in range(len(lower_bases) - 1):
        base = lower_bases[ll]
        next_base = lower_bases[ll + 1]
        for i in range(n):
            next_i = (i + 1) % n
            faces.append([base + i, next_base + i, next_base + next_i])
            faces.append([base + i, next_base + next_i, base + next_i])
    # Integrate fractal flower for caps (no fan, use flower fractals)
    # Compute curve length for scale
    curve_length = np.sum(np.sqrt(np.diff(x_curve)**2 + np.diff(y_curve)**2))
    flower_scale = curve_length * 0.1 if curve_length > 0 else 0.5  # Scale to curve
    all_polygons = []  # List of list of [x,y,z] for each polygon
    all_guide_curves = []  # New: Collect guide curve pairs
    # Upper cap flower
    fractal_flower(vertices[center_upper_idx], flower_scale, fractal_level, all_polygons, all_guide_curves, rotation_angle=np.pi)
    # Lower cap flower
    fractal_flower(vertices[center_lower_idx], flower_scale, fractal_level, all_polygons, all_guide_curves, rotation_angle=np.pi)
    # Add polygons to mesh (triangulate for rendering)
    for poly in all_polygons:
        base_idx = len(vertices)
        vertices.extend(poly)
        for tri in triangulate_poly(range(len(poly))):
            faces.append([base_idx + tri[0], base_idx + tri[1], base_idx + tri[2]])
    # Add guide curves as edges (simple lines, add as degenerate faces or separate for visualization)
    for guide in all_guide_curves:
        base_idx = len(vertices)
        vertices.append(guide[0])
        vertices.append(guide[1])
        faces.append([base_idx, base_idx + 1, base_idx + 1])  # Degenerate tri for line (visual only)
    # Convert to numpy array
    vertices = np.array(vertices)
    # Snap to integers if hash ends with 0
    for i in range(len(vertices)):
        v = vertices[i]
        h_str = f"{v[0]:.6f}{v[1]:.6f}{v[2]:.4f}"
        h = hashlib.sha256(h_str.encode()).hexdigest()[-1]
        if h == '0':
            vertices[i] = np.round(vertices[i])
    # Add compound curvature modulation with angle and 3D kappa grid for smooth orthographic projections
    grid_size, _, num_angles = kappa_grid.shape
    angle_idx = int((last_angle / 360) * num_angles) % num_angles
    kappa_slice = kappa_grid[:, :, angle_idx]
    # Normalize vertices to -1 to 1 for grid mapping (assuming curve bounds approx [0, WIDTH] x [0, HEIGHT])
    max_dim = max(np.max(np.abs(vertices[:, 0])), np.max(np.abs(vertices[:, 1])))
    norm_x = np.clip(((vertices[:, 0] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    norm_y = np.clip(((vertices[:, 1] / max_dim) + 1) / 2 * (grid_size - 1), 0, grid_size - 1).astype(int)
    kappa_mod = kappa_slice[norm_y, norm_x]
    vertices[:, 2] += kappa_mod * 0.1  # Scale z modulation
    vertices[:, 0] += kappa_mod * 0.05 * np.sin(2 * np.pi * vertices[:, 2] / height)  # Compound in x
    vertices[:, 1] += kappa_mod * 0.05 * np.cos(2 * np.pi * vertices[:, 2] / height)  # Compound in y
    # Make flowers sacrificial: remove flower faces after modulation (assume last added are flowers)
    flower_face_start = len(faces) - len(all_polygons) * 35  # Adjusted for 36 points per flower (approx 35 triangles)
    faces = faces[:flower_face_start]
    return vertices, faces

# NURBS basis function
def nurbs_basis(u, i, p, knots):
    if p == 0:
        return 1.0 if knots[i] <= u <= knots[i + 1] else 0.0  # Include = for end
    if knots[i + p] == knots[i]:
        c1 = 0.0
    else:
        c1 = (u - knots[i]) / (knots[i + p] - knots[i]) * nurbs_basis(u, i, p - 1, knots)
    if knots[i + p + 1] == knots[i + 1]:
        c2 = 0.0
    else:
        c2 = (knots[i + p + 1] - u) / (knots[i + p + 1] - knots[i + 1]) * nurbs_basis(u, i + 1, p - 1, knots)
    return c1 + c2

# Compute NURBS curve point
def nurbs_curve_point(u, control_points, weights, p, knots):
    n = len(control_points) - 1
    x = 0.0
    y = 0.0
    denom = 0.0
    for i in range(n + 1):
        b = nurbs_basis(u, i, p, knots)
        denom += b * weights[i]
        x += b * weights[i] * control_points[i][0]
        y += b * weights[i] * control_points[i][1]
    if denom == 0:
        return 0, 0
    return x / denom, y / denom

# Generate NURBS curve
def generate_nurbs_curve(points, weights, p, knots, num_points=1000):
    u_min, u_max = knots[p], knots[-p - 1]
    u_values = np.linspace(u_min, u_max, num_points, endpoint=False)
    curve = [nurbs_curve_point(u, points, weights, p, knots) for u in u_values]
    curve.append(curve[0])  # Append first point for exact closure
    return np.array([list(pt) for pt in curve])  # Convert to np.array of shape (num_points+1, 2)

# Compute golden spiral
def compute_golden_spiral():
    theta = np.linspace(0, 10 * np.pi, 1000)
    r = A_SPIRAL * np.exp(B_SPIRAL * theta)
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    # Scale down to fit within page bounds
    scale_factor = min(WIDTH, HEIGHT) / (2 * np.max(np.abs([x, y]))) * 0.8  # 80% of max to fit comfortably
    x *= scale_factor
    y *= scale_factor
    return x, y

# Compute kappa for a segment, second endpoint influences next kappa
def compute_segment_kappa(p1, p2, base_kappa=1.0, prev_kappa=1.0):
    x1, y1 = p1
    x2, y2 = p2
    theta = np.sqrt((x2 - x1)**2 + (y2 - y1)**2)  # Theta is distance
    if theta < 1e-10:
        return prev_kappa
    decay_factor = np.exp(-theta / WIDTH / 20.0)  # Further reduced decay rate
    return prev_kappa * decay_factor * base_kappa

# Recalculate kappas after changes (e.g., closure or node move) for consistency
def recalculate_kappas():
    global previous_kappa
    previous_kappa = kappas[0]  # Start with first kappa
    for i in range(1, len(drawing_points)):
        kappas[i] = compute_segment_kappa(drawing_points[i - 1], drawing_points[i], curvature, previous_kappa)
        previous_kappa = kappas[i]

# Update 3D model on changes (e.g., height slider or curve update)
def update_3d_model():
    global current_vertices, current_faces
    if green_curve_line:
        x_curve, y_curve = green_curve_line.get_data()
        if is_closed and np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)), height=height)
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()

# Golden window calculation
def compute_golden_window(x_spiral, y_spiral):
    idx_crossings = np.where(np.diff(np.sign(x_spiral - PURPLE_LINES[0] * WIDTH)))[0]
    if len(idx_crossings) >= 2:
        y1 = y_spiral[idx_crossings[0]]
        y2 = y_spiral[idx_crossings[1]]
        return np.abs(y2 - y1), min(y1, y2), max(y1, y2)
    return 0, 0, 0

# Redraw green curve
def redraw_green_curve(is_closed=False):
    global green_curve_line
    if green_curve_line:
        green_curve_line.remove()
        green_curve_line = None
    if len(drawing_points) >= 2:
        adjusted_kappas = kappas.copy()
        if is_closed and len(adjusted_kappas) > 1:
            adjusted_kappas[1] = 1.5 * adjusted_kappas[1]  # Local kappa adjustment for ellipse conditions
        x_green, y_green = custom_interoperations_green_curve(drawing_points, adjusted_kappas, is_closed=is_closed)
        green_curve_line, = ax_2d.plot(x_green, y_green, 'g-', label='Green Curve' if green_curve_line is None else None)
    fig_2d.canvas.draw()

# Setup figures
fig_2d = plt.figure(figsize=(14, 8))
ax_2d = fig_2d.add_subplot(111)
fig_3d = plt.figure(figsize=(10, 6))
ax_3d = fig_3d.add_subplot(111, projection='3d')
fig_controls = plt.figure(figsize=(4, 8))
ax_curvature = fig_controls.add_axes([0.2, 0.8, 0.6, 0.03])
curvature_slider = Slider(ax_curvature, 'Curvature (kappa)', 0.1, 2.0, valinit=curvature)
ax_height = fig_controls.add_axes([0.2, 0.7, 0.6, 0.03])
height_slider = Slider(ax_height, 'Height', 0.1, 2.0, valinit=height)
ax_rings = fig_controls.add_axes([0.2, 0.6, 0.6, 0.03])
rings_slider = Slider(ax_rings, 'Rings', 5, 50, valinit=num_rings, valstep=1)
ax_level = fig_controls.add_axes([0.2, 0.5, 0.6, 0.03])
level_slider = Slider(ax_level, 'Fractal Level', 0, 5, valinit=fractal_level, valstep=1)
ax_radial = fig_controls.add_axes([0.2, 0.4, 0.6, 0.03])
radial_slider = Slider(ax_radial, 'Radial Chord', 0.1, 1.0, valinit=radial_chord)
ax_tangential = fig_controls.add_axes([0.2, 0.3, 0.6, 0.03])
tangential_slider = Slider(ax_tangential, 'Tangential Chord', 0.0, 0.5, valinit=tangential_chord)
ax_height_chord = fig_controls.add_axes([0.2, 0.2, 0.6, 0.03])
height_chord_slider = Slider(ax_height_chord, 'Height Chord', 0.0, 0.5, valinit=height_chord)

# Plot A3 page
ax_2d.plot([0, WIDTH, WIDTH, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k-', label='A3 Landscape Page')
for x in PURPLE_LINES:
    ax_2d.plot([x * WIDTH, x * WIDTH], [0, HEIGHT], 'm-', label='Purple Dividers' if x == PURPLE_LINES[0] else None)

# Horizon line
horizon_line, = ax_2d.plot([0, WIDTH], [HORIZON_HEIGHT, HORIZON_HEIGHT], 'b:', label='Horizon/Eye Line')

# Golden spiral
x_spiral, y_spiral = compute_golden_spiral()
golden_spiral, = ax_2d.plot(x_spiral + WIDTH/2, y_spiral + HEIGHT/2, 'gold', label='Golden Spiral')

# Golden window
golden_window, y_min, y_max = compute_golden_window(x_spiral + WIDTH/2, y_spiral + HEIGHT/2)
ax_2d.fill_between([PURPLE_LINES[0] * WIDTH - 0.05, PURPLE_LINES[0] * WIDTH + 0.05], y_min, y_max, color='yellow', alpha=0.5, label='Golden Window')

# Ghost curve init
ghost_curve, = ax_2d.plot([], [], 'g--', label='Ghost Curve Preview')

# Control indicators in legend
ax_2d.plot([], [], ' ', label='R: Toggle draw mode')
ax_2d.plot([], [], 'b--', label='A: Toggle protractor')
ax_2d.plot([], [], 'c-', label='M: Toggle measure (ruler)')
ax_2d.plot([], [], ' ', label='D: Toggle dimension')
ax_2d.plot([], [], 'r-', label='C: Close polyhedron (manual)')
ax_2d.plot([], [], ' ', label='Click near first point to close')
ax_2d.plot([], [], ' ', label='Click to select curve')
ax_2d.plot([], [], ' ', label='G: To construction geom')
ax_2d.plot([], [], ' ', label='H: Hide/show')
ax_2d.plot([], [], ' ', label='E: Reset canvas')
ax_2d.plot([], [], ' ', label='S: Export STL')
ax_2d.plot([], [], 'k-', label='Curvature Slider (Controls window)')

# Update curvature
def update_curvature(val):
    global curvature
    curvature = val
    if len(drawing_points) >= 1:
        kappas[-1] = curvature
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
    fig_2d.canvas.draw()

curvature_slider.on_changed(update_curvature)

# Update height
def update_height(val):
    global height
    height = val
    if is_closed:
        update_3d_model()

height_slider.on_changed(update_height)

# Update rings
def update_rings(val):
    global num_rings
    num_rings = int(val)
    if is_closed:
        update_3d_model()

rings_slider.on_changed(update_rings)

# Update fractal level
def update_level(val):
    global fractal_level
    fractal_level = int(val)
    if is_closed:
        update_3d_model()

level_slider.on_changed(update_level)

# Update radial chord
def update_radial(val):
    global radial_chord
    radial_chord = val
    if is_closed:
        update_3d_model()

radial_slider.on_changed(update_radial)

# Update tangential chord
def update_tangential(val):
    global tangential_chord
    tangential_chord = val
    if is_closed:
        update_3d_model()

tangential_slider.on_changed(update_tangential)

# Update height chord
def update_height_chord(val):
    global height_chord
    height_chord = val
    if is_closed:
        update_3d_model()

height_chord_slider.on_changed(update_height_chord)

# Toggle draw mode
def toggle_draw(event):
    global draw_mode
    if event.key == 'r':
        draw_mode = not draw_mode
        print(f"Draw mode {'enabled' if draw_mode else 'disabled'}")
        fig_2d.canvas.draw()

# Toggle protractor
def toggle_protractor(event):
    global protractor_active
    if event.key == 'a':
        protractor_active = not protractor_active
        print(f"Protractor tool {'enabled' if protractor_active else 'disabled'}")
        if not protractor_active:
            if protractor_line:
                protractor_line.remove()
                protractor_line = None
            if protractor_text:
                protractor_text.remove()
                protractor_text = None
            protractor_points.clear()
        fig_2d.canvas.draw()

# On click for protractor
def on_click_protractor(event):
    global protractor_line, protractor_text, last_angle
    if protractor_active and event.inaxes == ax_2d and event.button == 1:
        protractor_points.append((event.xdata, event.ydata))
        if len(protractor_points) == 2:
            x1, y1 = protractor_points[0]
            x2, y2 = protractor_points[1]
            if protractor_line:
                protractor_line.remove()
            protractor_line, = ax_2d.plot([x1, x2], [y1, y2], 'b--')
            dx = x2 - x1
            dy = y2 - y1
            angle = np.arctan2(dy, dx) * 180 / np.pi
            last_angle = angle
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if protractor_text:
                protractor_text.remove()
            protractor_text = ax_2d.text(mid_x, mid_y, f'Angle: {angle:.2f}°', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            protractor_points.clear()
            fig_2d.canvas.draw()

# Toggle ruler (measure)
def toggle_ruler(event):
    global ruler_active
    if event.key == 'm':
        ruler_active = not ruler_active
        print(f"Measure (ruler) tool {'enabled' if ruler_active else 'disabled'}")
        if not ruler_active:
            if ruler_line:
                ruler_line.remove()
                ruler_line = None
            if ruler_text:
                ruler_text.remove()
                ruler_text = None
            ruler_points.clear()
        fig_2d.canvas.draw()

# On click for ruler
def on_click_ruler(event):
    global ruler_line, ruler_text
    if ruler_active and event.inaxes == ax_2d and event.button == 1:
        ruler_points.append((event.xdata, event.ydata))
        if len(ruler_points) == 2:
            x1, y1 = ruler_points[0]
            x2, y2 = ruler_points[1]
            if ruler_line:
                ruler_line.remove()
            ruler_line, = ax_2d.plot([x1, x2], [y1, y2], 'c-')
            dx = x2 - x1
            dy = y2 - y1
            dist = np.sqrt(dx**2 + dy**2)
            mid_x = (x1 + x2) / 2
            mid_y = (y1 + y2) / 2
            if ruler_text:
                ruler_text.remove()
            ruler_text = ax_2d.text(mid_x, mid_y, f'Dist: {dist:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            ruler_points.clear()
            fig_2d.canvas.draw()

# Toggle dimension
def toggle_dimension(event):
    global dimension_active
    if event.key == 'd':
        dimension_active = not dimension_active
        print(f"Dimension tool {'enabled' if dimension_active else 'disabled'}")
        fig_2d.canvas.draw()

# On click for dimension
def on_click_dimension(event):
    if dimension_active and event.inaxes == ax_2d and event.button == 1:
        if ruler_active and ruler_text:
            dimension_labels.append(ruler_text)
        elif selected_curve:
            x, y = selected_curve.get_data()
            length = np.sum(np.sqrt(np.diff(x)**2 + np.diff(y)**2))
            mid_x = np.mean(x)
            mid_y = np.mean(y)
            dim_text = ax_2d.text(mid_x, mid_y + 0.05, f'Len: {length:.4f}', ha='center', va='center', fontsize=8, bbox=dict(facecolor='white', alpha=0.8))
            dimension_labels.append(dim_text)
        fig_2d.canvas.draw()

# Toggle pro mode (lock/unlock)
def toggle_pro_mode(event):
    global pro_mode
    if event.key == 'x':
        pro_mode = not pro_mode
        print(f"Pro mode {'locked' if pro_mode else 'unlocked'}")
        fig_2d.canvas.draw()

# On pick event for nodes
def on_pick(event):
    global selected_node_index
    artist = event.artist
    if artist in node_scatter:
        selected_node_index = node_scatter.index(artist)
        artist.set_color('yellow')  # Highlight selected node
        if pro_mode:
            show_ghost_handles()
        fig_2d.canvas.draw()

# Show ghost handles (theta points, midpoints between nodes)
def show_ghost_handles():
    global ghost_handles
    for handle in ghost_handles:
        handle.remove()
    ghost_handles = []
    num_points = len(drawing_points) if not is_closed else len(drawing_points) - 1  # Avoid double midpoint on close
    for i in range(num_points):
        next_i = (i + 1) % len(drawing_points) if is_closed else i + 1
        if next_i >= len(drawing_points):
            continue
        mid_x = (drawing_points[i][0] + drawing_points[next_i][0]) / 2
        mid_y = (drawing_points[i][1] + drawing_points[next_i][1]) / 2
        handle = ax_2d.scatter(mid_x, mid_y, color='yellow', s=30, marker='o')
        ghost_handles.append(handle)
    fig_2d.canvas.draw()

# On button press for dragging
def on_button_press(event):
    global dragging
    if pro_mode and selected_node_index != -1 and event.inaxes == ax_2d and event.button == 1:
        dragging = True

# On button release for dragging
def on_button_release(event):
    global dragging
    dragging = False

# On motion for dragging and preview
def on_motion(event):
    global previous_kappa, dragging, selected_node_index
    if dragging and pro_mode and selected_node_index != -1 and event.inaxes == ax_2d:
        drawing_points[selected_node_index] = (event.xdata, event.ydata)
        node_scatter[selected_node_index].set_offsets([[event.xdata, event.ydata]])
        recalculate_kappas()
        redraw_green_curve(is_closed=is_closed)
        if is_closed:
            update_3d_model()
        fig_2d.canvas.draw()
        return
    if draw_mode and len(drawing_points) > 0 and event.inaxes == ax_2d and not (protractor_active or ruler_active or dimension_active):
        x, y = event.xdata, event.ydata
        preview_points = drawing_points + [(x, y)]
        preview_kappas = kappas + [curvature]
        close_preview = False
        if len(preview_points) > 2:
            dx_first = x - drawing_points[0][0]
            dy_first = y - drawing_points[0][1]
            dist_first = np.sqrt(dx_first**2 + dy_first**2)
            if dist_first < CLOSE_THRESHOLD:
                preview_points[-1] = drawing_points[0]
                preview_kappas[-1] = curvature
                # Preview kappa1 adjustment for closure
                last_theta = np.sqrt((drawing_points[-1][0] - preview_points[-1][0])**2 + (drawing_points[-1][1] - preview_points[-1][1])**2)
                if last_theta < 1e-10:  # Manage '0' snap error in preview
                    last_theta = 1e-10
                decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                preview_kappas[0] = preview_kappas[-1] * decay_factor * curvature
                close_preview = True
        # Compute kappa for preview segment (cursor at theta)
        if len(preview_points) > 1:
            preview_kappa = compute_segment_kappa(preview_points[-2], preview_points[-1], curvature, previous_kappa)
            preview_kappas[-1] = preview_kappa
        x_ghost, y_ghost = custom_interoperations_green_curve(preview_points, preview_kappas, is_closed=close_preview)
        ghost_curve.set_data(x_ghost, y_ghost)
        fig_2d.canvas.draw()

# Generate G-code for the curve with variable speeds (for 2D plotting/CNC, scaled to mm)
def generate_gcode(x, y, speeds, scale=297):
    """
    Generates simple G-code for linear moves along the curve with variable feedrates.
    Args:
        x (array): X coordinates (normalized).
        y (array): Y coordinates (normalized).
        speeds (list): Normalized speeds (0-1) for each point.
        scale (float): Scale factor to convert normalized units to mm (based on A3 height=297mm).
    Returns:
        str: G-code string.
    """
    gcode = "G21 ; Set units to millimeters\n"
    gcode += "G90 ; Absolute positioning\n"
    # Move to start position (rapid)
    gcode += f"G0 X{x[0] * scale:.2f} Y{y[0] * scale:.2f}\n"
    # Linear moves with varying feedrate
    for i in range(1, len(x)):
        feedrate = speeds[i] * 900 + 100  # Scale speed to 100-1000 mm/min
        gcode += f"G1 X{x[i] * scale:.2f} Y{y[i] * scale:.2f} F{feedrate:.0f}\n"
    return gcode

# Drawing mode: Add kappa nodes and update continuous greencurve
def on_click_draw(event):
    global green_curve_line, selected_curve, previous_kappa, vanishing_points, current_vertices, current_faces, is_closed
    if event.inaxes == ax_2d and event.button == 1:
        x, y = event.xdata, event.ydata
        # Snap to dividers if close (UX improvement for precise alignment)
        for div in PURPLE_LINES:
            div_x = div * WIDTH
            if abs(x - div_x) < SNAP_THRESHOLD:
                x = div_x
                break
        if draw_mode and not (protractor_active or ruler_active or dimension_active):
            # Check if near first point to close
            if len(drawing_points) > 2:
                dx_first = x - drawing_points[0][0]
                dy_first = y - drawing_points[0][1]
                dist_first = np.sqrt(dx_first**2 + dy_first**2)
                if dist_first < CLOSE_THRESHOLD:
                    # Adjust kappa1 based on last theta and kappa
                    last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
                    if last_theta < 1e-10:  # Manage '0' snap error
                        last_theta = 1e-10
                    decay_factor = np.exp(-last_theta / WIDTH / 20.0)
                    kappas[0] = kappas[-1] * decay_factor * curvature  # Affect kappa1 with last kappa and decay
                    drawing_points.append(drawing_points[0])
                    kappas.append(kappas[0])  # Last kappa inherits first kappa's theta (via same value)
                    recalculate_kappas()  # Recalculate for closure consistency
                    is_closed = True
                    redraw_green_curve(is_closed=True)  # Use closed NURKS for ellipse conditions
                    # Get closed curve
                    x_curve, y_curve = green_curve_line.get_data()
                    if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
                        x_curve = np.append(x_curve, x_curve[0])
                        y_curve = np.append(y_curve, y_curve[0])
                    ax_3d.cla()
                    current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
                    verts = [[current_vertices[i] for i in f] for f in current_faces]
                    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
                    ax_3d.set_xlabel('X')
                    ax_3d.set_ylabel('Y')
                    ax_3d.set_zlabel('Z')
                    ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
                    fig_3d.canvas.draw()
                    print("Polyhedron closed and 3D model generated")
                    # Compute and print speeds for user generated curve
                    print("User Generated Curve Speeds:")
                    speeds = []
                    for i in range(len(x_curve)):
                        speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
                        print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
                        speeds.append(speed)
                    # Generate G-Code
                    gcode = generate_gcode(x_curve, y_curve, speeds)
                    with open('model.gcode', 'w') as f:
                        f.write(gcode)
                    print("G-Code saved to model.gcode")
                    print(gcode)
                    fig_2d.canvas.draw()
                    return
            # Add new kappa node (first endpoint)
            roygbiv = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
            color = roygbiv[len(drawing_points) % 7]
            node = ax_2d.scatter(x, y, color=color, s=50, picker=True, label='Kappa Node' if len(drawing_points) == 0 else None)
            node_scatter.append(node)
            original_colors.append(color)
            drawing_points.append((x, y))
            kappas.append(curvature)
            if len(drawing_points) > 1:
                previous_kappa = compute_segment_kappa(drawing_points[-2], drawing_points[-1], curvature, previous_kappa)
                redraw_green_curve(is_closed=is_closed)
                if len(drawing_points) >= 2:
                    t = np.linspace(0, 1, 100)
                    x_green, y_green = green_curve_line.get_data()
                    curv = compute_curvature(x_green, y_green, t)
                    print(f"Green curve curvature: Max={curv.max():.4f}, Min={curv.min():.4f}")
            if len(drawing_points) >= 3:
                print("Third point added: Introducing depth and triangulation")
                tri_points = drawing_points[-3:]
                vp = compute_vanishing_point(tri_points)
                vanishing_points.append(vp)
                ax_2d.scatter(vp[0], vp[1], color='purple', s=30, label='Vanishing Point' if len(vanishing_points) == 1 else None)
            fig_2d.canvas.draw()
        elif not draw_mode and not (protractor_active or ruler_active or dimension_active):
            min_dist = float('inf')
            selected_curve = None
            if green_curve_line:
                x_curve, y_curve = green_curve_line.get_data()
                dist = np.min(np.sqrt((x_curve - x)**2 + (y_curve - y)**2))
                if dist < min_dist and dist < 0.05:
                    min_dist = dist
                    selected_curve = green_curve_line
            if selected_curve:
                selected_curve.set_linewidth(3.0)
                print("Green curve selected")
                fig_2d.canvas.draw()

# Close polyhedron (manual trigger)
def close_polyhedron(event):
    if event.key == 'c':
        print("Close via clicking near first point when ghosted")

# Auto close on 'c'
def auto_close(event):
    global is_closed, drawing_points, kappas, previous_kappa
    if event.key == 'c' and len(drawing_points) > 2:
        # Adjust kappa1 based on last theta and kappa
        last_theta = np.sqrt((drawing_points[-1][0] - drawing_points[0][0])**2 + (drawing_points[-1][1] - drawing_points[0][1])**2)
        if last_theta < 1e-10:  # Manage '0' snap error
            last_theta = 1e-10
        decay_factor = np.exp(-last_theta / WIDTH / 20.0)
        kappas[0] = kappas[-1] * decay_factor * curvature  # Affect kappa1 with last kappa and decay
        drawing_points.append(drawing_points[0])
        kappas.append(kappas[0])  # Last kappa inherits first kappa's theta (via same value)
        recalculate_kappas()  # Recalculate for closure consistency
        is_closed = True
        redraw_green_curve(is_closed=True)  # Use closed NURKS for ellipse conditions
        # Get closed curve
        x_curve, y_curve = green_curve_line.get_data()
        if np.hypot(x_curve[-1] - x_curve[0], y_curve[-1] - y_curve[0]) > 1e-5:
            x_curve = np.append(x_curve, x_curve[0])
            y_curve = np.append(y_curve, y_curve[0])
        ax_3d.cla()
        current_vertices, current_faces = build_mesh(x_curve, y_curve, np.zeros(len(x_curve)))
        verts = [[current_vertices[i] for i in f] for f in current_faces]
        ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
        ax_3d.set_xlabel('X')
        ax_3d.set_ylabel('Y')
        ax_3d.set_zlabel('Z')
        ax_3d.set_title('3D User Model (Compound Curvature with End Caps)')
        fig_3d.canvas.draw()
        print("Polyhedron closed and 3D model generated")
        # Compute and print speeds for user generated curve
        print("User Generated Curve Speeds:")
        speeds = []
        for i in range(len(x_curve)):
            speed = int(hashlib.sha256(f"{x_curve[i]}{y_curve[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
            print(f"Point {i}: ({x_curve[i]:.4f}, {y_curve[i]:.4f}), Speed: {speed:.4f}")
            speeds.append(speed)
        # Generate G-Code
        gcode = generate_gcode(x_curve, y_curve, speeds)
        with open('model.gcode', 'w') as f:
            f.write(gcode)
        print("G-Code saved to model.gcode")
        print(gcode)
        fig_2d.canvas.draw()

# Change to construction geometry
def to_construction(event):
    global selected_curve
    if event.key == 'g' and selected_curve:
        selected_curve.set_linestyle('--')
        selected_curve.set_color('gray')
        print("Green curve changed to construction geometry")
        selected_curve = None
        fig_2d.canvas.draw()

# Hide/show
def hide_show(event):
    global hidden_elements, selected_curve
    if event.key == 'h':
        if selected_curve:
            if selected_curve.get_visible():
                selected_curve.set_visible(False)
                hidden_elements.append(selected_curve)
                print("Green curve hidden")
            else:
                selected_curve.set_visible(True)
                if selected_curve in hidden_elements:
                    hidden_elements.remove(selected_curve)
                print("Green curve shown")
            selected_curve = None
        else:
            for elem in hidden_elements:
                elem.set_visible(True)
            hidden_elements.clear()
            print("All hidden elements shown")
        fig_2d.canvas.draw()

# Reset canvas
def reset_canvas(event):
    global drawing_points, kappas, previous_kappa, green_curve_line, vanishing_points, selected_curve, current_vertices, current_faces, last_angle, node_scatter, ghost_handles, is_closed, original_colors
    if event.key == 'e':
        drawing_points = []
        kappas = []
        previous_kappa = 1.0
        if green_curve_line:
            green_curve_line.remove()
            green_curve_line = None
        for node in node_scatter:
            node.remove()
        node_scatter = []
        original_colors = []
        for handle in ghost_handles:
            handle.remove()
        ghost_handles = []
        vanishing_points = []
        selected_curve = None
        ax_3d.cla()
        current_vertices = None
        current_faces = None
        last_angle = 0.0
        is_closed = False
        display_pod_surface()
        print("Canvas reset")
        fig_2d.canvas.draw()

# Compute curvature for continuity check
def compute_curvature(x, y, t):
    dt = t[1] - t[0]
    dx_dt = np.gradient(x, dt)
    dy_dt = np.gradient(y, dt)
    d2x_dt2 = np.gradient(dx_dt, dt)
    d2y_dt2 = np.gradient(dy_dt, dt)
    numerator = np.abs(dx_dt * d2y_dt2 - dy_dt * d2x_dt2)
    denominator = (dx_dt**2 + dy_dt**2)**1.5
    denominator = np.where(denominator == 0, 1e-10, denominator)
    return numerator / denominator

# Generate base pod curve (closed for boundary surface, now 3D curve)
def generate_pod_curve_closed(num_points=200, phase=0.0):  # Increased num_points for better resolution
    t = np.linspace(0, 2 * np.pi, num_points)  # Full closed loop
    r = radial_chord + tangential_chord * np.cos(6 * t + phase)  # Flower-like top profile
    x = r * np.cos(t)
    y = r * np.sin(t)
    z = height_chord * np.sin(6 * t + phase)  # Add z variation for 3D curve
    return x, y, z

# Function to compute normals
def compute_normal(v1, v2, v3):
    vec1 = v2 - v1
    vec2 = v3 - v1
    normal = np.cross(vec1, vec2)
    norm = np.linalg.norm(normal)
    return normal / norm if norm != 0 else normal

# Export current model to STL
def export_stl():
    global current_vertices, current_faces
    if current_vertices is None or current_faces is None:
        print("No model to export")
        return
    stl_data = b'\x00' * 80  # Header
    stl_data += struct.pack('<I', len(current_faces))  # Number of triangles
    for face in current_faces:
        v1 = current_vertices[face[0]]
        v2 = current_vertices[face[1]]
        v3 = current_vertices[face[2]]
        normal = compute_normal(v1, v2, v3)
        stl_data += struct.pack('<3f', *normal)
        stl_data += struct.pack('<3f', *v1)
        stl_data += struct.pack('<3f', *v2)
        stl_data += struct.pack('<3f', *v3)
        stl_data += b'\x00\x00'  # Attribute byte count
    filename = 'model.stl'
    with open(filename, 'wb') as f:
        f.write(stl_data)
    print(f"Saved to {filename}")
    stl_base64 = base64.b64encode(stl_data).decode('utf-8')
    print("Base64 STL:")
    print(stl_base64)

# Save STL on key press
def save_stl(event):
    if event.key == 's':
        export_stl()

# Display pod surface by default in 3D with curvature continuous end caps
def display_pod_surface():
    global current_vertices, current_faces
    x_curve, y_curve, z_curve = generate_pod_curve_closed(200)  # Increased for resolution
    current_vertices, current_faces = build_mesh(x_curve, y_curve, z_curve)
    verts = [[current_vertices[i] for i in f] for f in current_faces]
    ax_3d.add_collection3d(Poly3DCollection(verts, alpha=0.5, facecolors=cm.viridis(np.linspace(0, 1, len(verts)))))
    ax_3d.set_xlabel('X')
    ax_3d.set_ylabel('Y')
    ax_3d.set_zlabel('Z')
    ax_3d.set_title('3D pod Projected Surface (Compound Curvature with End Caps)')
    fig_3d.canvas.draw()

# Draw default pod ellipse as green curve on 2D canvas
def draw_default_pod(ax, color='g'):
    x, y, _ = generate_pod_curve_closed(num_points=36)  # Increased to 36 for better flower
    x_control = x[:-1]
    y_control = y[:-1]
    scale = 0.6  # Scale for large curve
    x_control *= scale
    y_control *= scale
    x_control += WIDTH / 2
    y_control += HEIGHT / 2
    points = list(zip(x_control, y_control))
    kappas_pod = [1.0] * len(points)
    x_interp, y_interp = custom_interoperations_green_curve(points, kappas_pod, is_closed=True)
    ax.plot(x_interp, y_interp, color=color, linewidth=3, linestyle='-')
    # Compute and print speeds for default curve
    print("Default Curve Speeds:")
    for i in range(len(x_interp)):
        speed = int(hashlib.sha256(f"{x_interp[i]}{y_interp[i]}".encode()).hexdigest()[-4:], 16) % 1000 / 1000.0
        print(f"Point {i}: ({x_interp[i]:.4f}, {y_interp[i]:.4f}), Speed: {speed:.4f}")

# Add Mersenne elements to the plot
# First A4 page (adjusted)
ax_2d.plot([0, WIDTH/2, WIDTH/2, 0, 0], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 1')
# Second A4 page
ax_2d.plot([WIDTH/2, WIDTH, WIDTH, WIDTH/2, WIDTH/2], [0, 0, HEIGHT, HEIGHT, 0], 'k--', label='A4 Page 2')
# Purple lines (in first A4)
for x in PURPLE_LINES:
    ax_2d.plot([x * (WIDTH/2), x * (WIDTH/2)], [0, HEIGHT], 'm-')
# Red datum line
ax_2d.plot([0, WIDTH], [0, 0], 'r-')
# A4 short edge divisions (first A4 only)
for x in division_positions:
    ax_2d.plot([x, x], [0, 0.02], 'k-', alpha=0.3)
# Plot circle division markers
for x_marker, y_marker in circle_markers:
    ax_2d.plot(x_marker, y_marker, 'k.', markersize=3)
# Full spiral
ax_2d.plot(x_full, y_full, 'k-')
# Green segment
ax_2d.plot(x_green_final, y_green_scaled, 'g-')
# 52 Mersenne prime curves
for i, (x_new, y_new, label) in enumerate(curves):
    line, = ax_2d.plot(x_new, y_new, color=colors[i])
    curve_lines[i] = line
# Flags and staggered labels
label_y_offset = 0.05
for i, (x_end, y_end, x_start, y_start, x_flag, y_flag, label, freq) in enumerate(flag_positions):
    ax_2d.plot([x_end, x_start], [y_end, y_start], 'k--', alpha=0.3)
    ax_2d.plot([x_start, x_flag], [y_start, y_flag], 'k-', alpha=0.5)
    y_label = y_flag - (i % 5) * label_y_offset
    text = ax_2d.text(x_flag, y_label, label, ha='left', va='top', fontsize=6, rotation=45, picker=5)
    harmonic_text = ax_2d.text(x_flag, y_label - 0.05, f'{freq:.2f} Hz', ha='left', va='top', fontsize=6, color='blue', visible=show_harmonics)
    annotation_objects.append(text)
    harmonic_texts.append(harmonic_text)

# Toggle harmonic frequency display
def toggle_harmonics(event):
    global show_harmonics
    if event.key == 'f':
        show_harmonics = not show_harmonics
        for text in harmonic_texts:
            text.set_visible(show_harmonics)
        print(f"Harmonic frequencies {'shown' if show_harmonics else 'hidden'}")
        fig_2d.canvas.draw()

# Connect event handlers
fig_2d.canvas.mpl_connect('key_press_event', toggle_draw)
fig_2d.canvas.mpl_connect('key_press_event', toggle_protractor)
fig_2d.canvas.mpl_connect('key_press_event', toggle_ruler)
fig_2d.canvas.mpl_connect('key_press_event', toggle_dimension)
fig_2d.canvas.mpl_connect('key_press_event', toggle_pro_mode)
fig_2d.canvas.mpl_connect('key_press_event', close_polyhedron)
fig_2d.canvas.mpl_connect('key_press_event', auto_close)
fig_2d.canvas.mpl_connect('key_press_event', to_construction)
fig_2d.canvas.mpl_connect('key_press_event', hide_show)
fig_2d.canvas.mpl_connect('key_press_event', reset_canvas)
fig_2d.canvas.mpl_connect('key_press_event', save_stl)
fig_2d.canvas.mpl_connect('key_press_event', toggle_harmonics)
fig_2d.canvas.mpl_connect('button_press_event', on_click_protractor)
fig_2d.canvas.mpl_connect('button_press_event', on_click_ruler)
fig_2d.canvas.mpl_connect('button_press_event', on_click_dimension)
fig_2d.canvas.mpl_connect('button_press_event', on_click_draw)
fig_2d.canvas.mpl_connect('pick_event', on_pick)
fig_2d.canvas.mpl_connect('button_press_event', on_button_press)
fig_2d.canvas.mpl_connect('button_release_event', on_button_release)
fig_2d.canvas.mpl_connect('motion_notify_event', on_motion)

# Draw default pod curve
draw_default_pod(ax_2d)

# Set plot limits and labels
ax_2d.set_xlim(-0.1, WIDTH + 0.1)
ax_2d.set_ylim(-0.2, HEIGHT + 0.1)
ax_2d.set_xlabel('X (Normalized A3 Width)')
ax_2d.set_ylabel('Y (Normalized A3 Height)')
ax_2d.set_title(f'Mersenne Prime Curves with Green Segment\n{scale_key_text}\n{scale_label}')
ax_2d.legend(loc='upper right', fontsize=6)
ax_2d.grid(True)

# Display pod surface by default
display_pod_surface()

# Export to HTML if mpld3 is available
if MPLD3_AVAILABLE:
    output = mpld3.fig_to_html(fig_2d)
    with open('mersenne_plot.html', 'w') as f:
        f.write(output)
    print("Interactive plot saved to mersenne_plot.html")

# Show plots
plt.show()

----- END tetra.py -----

----- tetra_forge.py -----
# tetra_forge.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import forge_telemetry as telemetry
import solid as ribit
import rig as gyrogimbal
import friction as frictionvibe
import maptics as ghosthand
import haptics
from welding import weave, TIG, acetylene
from prep_tools import angle_grinder, swarf_vacuum, acetylene_mark, auto_markup
from test_tools import flex_until_break, ink_test
from post_process import anodize, viscosity_check, pack, quench, paint

def beam(env='garage', material='mild_steel'):
    ribit.mesh('W21x62')  # hyperbolic ellipse stub
    if material == 'stainless':
        anodize('sulfuric', temp=20, volts=20, dye='pearl_gold')
        viscosity_check(20)  # cps
    telemetry.log('material_set')

def prep(surface='burl'):
    if telemetry.rust_probe() > 2:
        angle_grinder(30, 20000, coolant='water')
        swarf_vacuum()  # model curls, sparks
    acetylene_mark(low_oxy=True, duration=0.8)  # carbon line
    auto_markup(30, 45, root_gap=2.0)  # V bevel

def weld(pass_num=1, style='stick', env='garage'):
    if style == 'TIG':
        TIG(tungsten='1%lan', argon=98, volts=25, hz=100)
    else:
        weave('christmas_tree', speed=18, arc=1.8)
    if env == 'space':
        vacuum = True
        no_flux = True
    telemetry.log(f'pass{pass_num}', puddle='sphere')
    if telemetry.depth_error():
        haptics.buzz('low')
    else:
        haptics.buzz('silent')

def post(process='case_harden'):
    if process == 'case_harden':
        pack('urea', 850, 4)  # hours
        quench('mineral_oil', 200)
    elif process == 'anodize':
        anodize(seal=True)
    else:
        paint('epoxy_primer', 'polyurethene', flakes='mica_gold')

def test():
    failure = flex_until_break(load='5mm/min', ram='hydraulic')
    if telemetry.crack_location() == 'root':
        telemetry.flag('hydrogen')
    ink_test('red_dye', uv=True)  # peng detection
    if failure:
        haptics.shake('hard')
    else:
        haptics.shake('quiet')

# Main simulation flow
def main():
    env = 'garage'  # Example environment, can be overridden
    beam(env=env, material='mild_steel')
    prep(surface='burl')
    weld(pass_num=1, style='stick', env=env)
    post(process='case_harden')
    test()

# Stubs – open for BOM, manufacturer hooks
def material_input(anything):
    pass

def license_override():
    pass

if __name__ == "__main__":
    main()

----- END tetra_forge.py -----

----- tetra_gen.py -----
# tetra_gen.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
from porosity import porosity_hashing  # Assume porosity_hashing.py is in the same directory

def generate_fractal_tetra(grid_size=50, levels=3, porosity_threshold=0.3):
    """
    Generates fractal tetrahedral patterns and simulates porosity buildup.
    - grid_size: Initial grid dimension for tetra mesh.
    - levels: Fractal recursion levels.
    - porosity_threshold: Threshold for porosity hashing (default 0.3 for 30% voids).
    Returns: Fractal grid with hashed porosity.
    """
    # Generate base tetra grid (placeholder for fractal generation)
    grid = np.random.rand(grid_size, grid_size, grid_size)  # Random values for porosity simulation
    # Recursively apply fractal levels (simplified)
    for level in range(levels):
        grid = np.pad(grid, pad_width=grid_size // (2 ** level), mode='symmetric')  # Expand grid fractally
    
    # Simulate uneven martensite layers with porosity
    grid = grid * (1 - porosity_threshold) + np.random.rand(*grid.shape) * porosity_threshold
    
    # Hash porosity voids
    hashed_porosity = porosity_hashing(grid, porosity_threshold)
    
    return grid, hashed_porosity

# Example usage
if __name__ == "__main__":
    fractal_grid, hashed_voids = generate_fractal_tetra()
    print(f"Fractal grid shape: {fractal_grid.shape}")
    print(f"Number of hashed voids: {len(hashed_voids)}")

----- END tetra_gen.py -----

----- tetras.py -----
# tetras.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np

def fractal_tetra(original_vertices, level, all_triangles):
    """
    Recursively generates Sierpinski tetrahedron triangles for the surface.
    Collects all base-level triangular faces in all_triangles (list of [v1, v2, v3] where vi = [x,y,z]).
   
    Args:
        original_vertices: List of 4 [x,y,z] for the initial tetrahedron.
        level: Current recursion depth.
        all_triangles: List to collect all base triangles.
    """
    if level == 0:
        # Add the 4 faces of the base tetra
        faces = [
            [original_vertices[0], original_vertices[1], original_vertices[2]],
            [original_vertices[0], original_vertices[1], original_vertices[3]],
            [original_vertices[0], original_vertices[2], original_vertices[3]],
            [original_vertices[1], original_vertices[2], original_vertices[3]]
        ]
        all_triangles.extend(faces)
        return
   
    # Compute midpoints for subdivision
    mid01 = [(original_vertices[0][j] + original_vertices[1][j])/2 for j in range(3)]
    mid02 = [(original_vertices[0][j] + original_vertices[2][j])/2 for j in range(3)]
    mid03 = [(original_vertices[0][j] + original_vertices[3][j])/2 for j in range(3)]
    mid12 = [(original_vertices[1][j] + original_vertices[2][j])/2 for j in range(3)]
    mid13 = [(original_vertices[1][j] + original_vertices[3][j])/2 for j in range(3)]
    mid23 = [(original_vertices[2][j] + original_vertices[3][j])/2 for j in range(3)]
   
    # 4 sub-tetras at corners
    sub0 = [original_vertices[0], mid01, mid02, mid03]
    sub1 = [original_vertices[1], mid01, mid12, mid13]
    sub2 = [original_vertices[2], mid02, mid12, mid23]
    sub3 = [original_vertices[3], mid03, mid13, mid23]
   
    # Recurse
    for sub in [sub0, sub1, sub2, sub3]:
        fractal_tetra(sub, level - 1, all_triangles)

def build_mesh(x_curve, y_curve, num_points, fractal_level=3):
    """
    Builds 3D mesh using fractal tetrahedron, scaled by curve length.
    Returns vertices (list of [x,y,z]) and faces (list of [idx1, idx2, idx3]).
    Note: Vertices may have duplicates; for optimization, deduplicate if needed.
    """
    # Compute curve length for scale
    curve_length = np.sum(np.sqrt(np.diff(x_curve)**2 + np.diff(y_curve)**2))
    scale = curve_length if curve_length > 0 else 1.0
   
    # Initial regular tetrahedron vertices
    orig = np.array([
        [0, 0, 0],
        [1, 0, 0],
        [0.5, np.sqrt(3)/2, 0],
        [0.5, np.sqrt(3)/6, np.sqrt(6)/3]
    ]) * scale
   
    all_triangles = [] # List of [[x1,y1,z1], [x2,y2,z2], [x3,y3,z3]]
    fractal_tetra(orig.tolist(), fractal_level, all_triangles)
   
    # Flatten to global vertices and faces
    vertices = []
    faces = []
    for tri in all_triangles:
        base_idx = len(vertices)
        vertices.extend(tri)
        faces.append([base_idx, base_idx+1, base_idx+2])
   
    return vertices, faces

----- END tetras.py -----

----- track_kappa_vector.py -----
# track_kappa_vector.py
# Copyright 2025 Beau Ayres
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Proprietary Software - All Rights Reserved
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, modification, or use is strictly prohibited without
# express written permission from Beau Ayres.
#
# AGPL-3.0-or-later licensed
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

# Existing frictionvibe.py content (assumed)
# ... (previous code)

from telemetry import log  # Assume telemetry.py has log function

def track_kappa_vector(particle_path, drag=0.05):
    """
    Tracks Kappa Vector for supply chain particles from forge to weld.
    - particle_path: List of (x, y, z, stage) tuples (stage: 'forge', 'ship', 'weld').
    - drag: Drag coefficient affecting vector curvature (default 0.05).
    Returns: List of adjusted vectors.
    """
    vectors = []
    for i, (x, y, z, stage) in enumerate(particle_path):
        # Apply drag to curve vector
        vector = np.array([x, y, z]) * (1 - drag)
        vectors.append(vector)
        log(f"Stage {stage}: Vector {vector}, Drag {drag}")
        
        # Simulate stage transitions
        if stage == 'forge':
            log("Particle born in forge at 800C")
        elif stage == 'ship':
            log("Particle rerouted due to drag")
        elif stage == 'weld':
            log("Particle reborn in weld")
    
    return vectors

# Example usage
if __name__ == "__main__":
    path = [(0, 0, 0, 'forge'), (10, 5, 0, 'ship'), (15, 5, 2, 'weld')]
    vectors = track_kappa_vector(path)
    print(f"Kappa vectors: {vectors}")

----- END track_kappa_vector.py -----

----- vorseed.py -----
# vorseed.py
# Copyright 2025 Beau Ayres
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider, Button
from mpl_toolkits.mplot3d import Axes3D
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
import hashlib
import struct
import math
import mpmath
mpmath.mp.dps = 19  # Precision for φ, π.
from kappasha import kappasha256, kappa_calc
from wise_transforms import bitwise_transform, hexwise_transform, hashwise_transform
from id_util_nurks_closure_hex import custom_interoperations_green_curve
from ribit import ribit_generate
from knots_rops import Knot, Rope, knots_rops_sequence
from left_weighted_scale import left_weighted_scale
from tetras import build_mesh, fractal_tetra  # For Sierpinski tetrahedron (mail mesh)
from green_curve import custom_interoperations_green_curve
from scipy.spatial import Voronoi, Delaunay  # For Voronoi hex integration
from regulate_hexagons_on_curve import regulate_hexagons_on_curve
from nurks_surface import generate_nurks_surface

u_num = 36
v_num = 20
v_num_cap = 10

def generate_voronoi_seeds(X, Y, Z, inner_radius, param_str):
    """Modular function to generate Voronoi seeds using regulate_hexagons_on_curve."""
    hex_positions = regulate_hexagons_on_curve(X, Y, Z, inner_radius, param_str)
    seeds = np.array([[pos[0], pos[1]] for pos in hex_positions])  # Extract centers as seeds
    return seeds

def export_to_stl(triangles, filename, surface_id):
    """Export mesh to binary STL with embedded hash in header."""
    header = f"ID: {surface_id}".ljust(80, ' ').encode('utf-8')
    num_tri = len(triangles)
    with open(filename, 'wb') as f:
        f.write(header)
        f.write(struct.pack('<I', num_tri))
        for tri in triangles:
            # Compute normal with handling for degenerate cases.
            v1 = np.array(tri[1][1:]) - np.array(tri[0][1:])
            v2 = np.array(tri[2][1:]) - np.array(tri[0][1:])
            normal = np.cross(v1, v2)
            norm_len = np.linalg.norm(normal)
            if norm_len > 0:
                normal /= norm_len
            else:
                normal = np.array([0.0, 0.0, 1.0]) # Default upward normal.
            f.write(struct.pack('<3f', *normal))
            for p in tri:
                f.write(struct.pack('<3f', *p[1:]))
            f.write(struct.pack('<H', 0)) # Attribute byte count.
# Interactive visualization.
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')
X, Y, Z, surface_id, X_cap, Y_cap, Z_cap = generate_nurks_surface()
surf = ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.8)
ax.set_title('Interactive NURKS Surface')
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
# Adjust layout for sliders.
plt.subplots_adjust(left=0.25, bottom=0.35)
# Sliders for all parameters (positioned vertically).
slider_params = [
    ('NS Diam', 0.5, 2.0, 1.0),
    ('SW/NE Diam', 0.5, 2.0, 1.0),
    ('NW/SE Diam', 0.5, 2.0, 1.0),
    ('Twist', -np.pi, np.pi, 0.0),
    ('Amplitude', -1.0, 1.0, 0.3),
    ('Radii', 0.5, 2.0, 1.0),
    ('Kappa', 0.1, 5.0, 1.0),
    ('Height', 0.5, 2.0, 1.0),
    ('Inflection', 0.0, 1.0, 0.5),
    ('Morph', 0.0, 2.0, 0.0) # Add morph slider
]
sliders = []
y_pos = 0.25
for label, vmin, vmax, vinit in slider_params:
    ax_slider = plt.axes([0.1, y_pos, 0.65, 0.03])
    slider = Slider(ax_slider, label, vmin, vmax, valinit=vinit)
    sliders.append(slider)
    y_pos -= 0.03
# Hex mode toggle using Button.
ax_hex = plt.axes([0.1, 0.01, 0.1, 0.03])
btn_hex = Button(ax_hex, 'Hex Mode: Off')
hex_mode = False
def toggle_hex(event):
    global hex_mode
    hex_mode = not hex_mode
    btn_hex.label.set_text(f'Hex Mode: {"On" if hex_mode else "Off"}')
    update(None)
btn_hex.on_clicked(toggle_hex)
def update(val):
    """Update surface based on current slider values."""
    params = [s.val for s in sliders[:-1]] + [sliders[-1].val, hex_mode] # Morph is last slider
    X, Y, Z, surface_id, X_cap, Y_cap, Z_cap = generate_nurks_surface(*params)
    global surf, surf_cap
    surf.remove()
    surf = ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.8)
    if hex_mode:
        if surf_cap is not None:
            surf_cap.remove()
        surf_cap = ax.plot_surface(X_cap, Y_cap, Z_cap, cmap='viridis', alpha=0.8)
    else:
        if surf_cap is not None:
            surf_cap.remove()
        surf_cap = None
    fig.canvas.draw_idle()
for s in sliders:
    s.on_changed(update)
# Export button.
ax_export = plt.axes([0.8, 0.05, 0.1, 0.075])
btn_export = Button(ax_export, 'Export STL')
u_num = 36
v_num = 20
v_num_cap = 10
def on_export(event):
    params = [s.val for s in sliders[:-1]] + [sliders[-1].val, hex_mode] # Morph is last slider
    X, Y, Z, surface_id, X_cap, Y_cap, Z_cap = generate_nurks_surface(*params)
    triangles_main = tessellate_mesh(X, Y, Z, u_num, v_num)
    triangles = triangles_main
    if hex_mode:
        triangles_cap = tessellate_mesh(X_cap, Y_cap, Z_cap, u_num, v_num_cap, is_cap=True)
        triangles += triangles_cap
    export_to_stl(triangles, 'nurks_surface.stl', surface_id)
    print(f"Exported to nurks_surface.stl with ID: {surface_id}")
btn_export.on_clicked(on_export)
surf_cap = None
plt.show()

----- END vorseed.py -----

----- welding.py -----
# welding.py
# Copyright 2025 Beau Ayres
# Licensed under AGPL-3.0-or-later

def weave(pattern, speed, arc):
    """Execute weld weave pattern (e.g., christmas_tree)."""
    print(f"Weaving: {pattern}, speed={speed} in/min, arc={arc} mm")

def TIG(tungsten, argon, volts, hz):
    """Perform TIG welding with specified parameters."""
    print(f"TIG weld: tungsten={tungsten}, argon={argon}%, volts={volts}, freq={hz} Hz")

def acetylene(low_oxy=False, duration=None):
    """Perform acetylene cutting or marking."""
    print(f"Acetylene process: low_oxy={low_oxy}, duration={duration}s")

# Example usage
if __name__ == "__main__":
    weave("christmas_tree", 18, 1.8)
    TIG("1%lan", 98, 25, 100)
    acetylene(low_oxy=True, duration=0.8)

----- END welding.py -----
